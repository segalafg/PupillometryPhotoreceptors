---
title: 'Chapter 4: Binocular combination in the Autonomic Nervous System'
author: |
 | Federico G. Segala$^1$, Joel T. Martin$^1$, Alex R. Wade$^1,2$ & Daniel H. Baker$^1,2$
output:
  bookdown::pdf_document2:
    fig_caption: yes
    toc: no
  html_document: default
bibliography: references.bib
link-citations: yes
linkcolor: black
csl: elife.csl
header-includes:
- \usepackage{caption}
---

```{r setup, include=FALSE}

processdata <- 0  # this flag determines the amount of processing, with 4 levels:
# 0 - do no processing, generate the pdf using existing versions of all figures
# 1 - generate figures using the processed group data
# 2 - average data across participants, do bootstrapping
# 3 - download all raw data and analyse (requires 48GB of storage)
cleanupraw <- 0  # if downloading raw data, delete once processed to save space

domodelling <- 0    # if set to 1, run the Stan models (takes ~24 hours)

localdir <- 'local/'    # all files are stored in the project directory /local/ which git is told to ignore
if (!file.exists(localdir)){dir.create(localdir)}   # create a local directory to store data and outputs
rawdir <- 'local/rawdata/'
if (!file.exists(rawdir)){dir.create(rawdir)}   # create a local directory to store raw data
figdir <- 'Figures/'
if (!file.exists(figdir)){dir.create(figdir)}   # create a local directory to store figures
datadir <- 'local/processeddata/'
if (!file.exists(datadir)){dir.create(datadir)}   # create a local directory to store processed data

# cut off for data inclusion (Mahalanobis distance for complex data)
SDthresh <<- 3
SDthreshcond <- 1.85
nbootstraps <<- 1000
legaltriggers <- 1:55
targetelectrodes1 <- c('POz','POz')

# check which packages are installed, install the missing ones, and activate
packagelist <- c('knitr','remotes','tictoc','R.matlab','bookdown','grImport','png','tiff','pals','ez','gtools','signal','boot','quickpsy','rstan','rstatix','coda','parallel','utils','osfr','ggplot2','grid','gridExtra','cowplot','ggsignif') # list of CRAN packages

missingpackages <- packagelist[!packagelist %in% installed.packages()[,1]]
if (length(missingpackages)>0){install.packages(missingpackages,repos = "http://cran.us.r-project.org")}
if (!'FourierStats' %in% installed.packages()[,1]){remotes::install_github("bakerdh/FourierStats")}
packagelist <- c(packagelist,'FourierStats')
toinstall <- packagelist[which(!packagelist %in% (.packages()))]
invisible(lapply(toinstall,library,character.only=TRUE))

devtools::install_github("kupietz/kableExtra")
library(kableExtra)

knitr::opts_chunk$set(echo = TRUE)

# settings for sampler 
numSavedSteps <- 100000    # total number of MCMC steps
adaptSteps <- 1000  # Number of steps to "tune" the samplers
burnInSteps <- 2000 
thinSteps <- 10
nChains <- 16
ncores <- 8  # because of multi-threading, this is usually double the true number of physical cores, so we halve the number as Stan can only use physical cores
options(mc.cores=ncores)

# helper function to make colours transparent
addalpha <- function(col, alpha=1){apply(sapply(col, col2rgb)/255, 2, function(x) rgb(x[1], x[2], x[3], alpha=alpha))}

v4Interp <- function(df, xo, yo, rmax = .75, gridRes = 67) {
  ## Create a function to perform Matlab's v4 interpolation.
  ## Takes as input a data-frame with columns x, y, and z (x co-ordinates, y co-ordinates, and amplitude)
  ## and variables xo and yo, the co-ordinates which will be use to create a grid for interpolation
  xo <- matrix(rep(xo,length(yo)),nrow = length(xo),ncol = length(yo))
  yo <- t(matrix(rep(yo,length(xo)),nrow = length(yo),ncol = length(xo)))
  xy <- df$x + df$y*sqrt(as.complex(-1))
  d <- matrix(rep(xy,length(xy)),nrow = length(xy), ncol = length(xy))
  d <- abs(d - t(d))
  diag(d) <- 1
  g <- (d^2) * (log(d)-1)   # Green's function.
  diag(g) <- 0
  weights <- qr.solve(g,df$z)
  xy <- t(xy)
  outmat <- matrix(nrow = gridRes,ncol = gridRes)
  for (i in 1:gridRes){
    for (j in 1:gridRes) {
      test4 <- abs((xo[i,j] + sqrt(as.complex(-1))*yo[i,j]) - xy)
      g <- (test4^2) * (log(test4)-1)
      outmat[i,j] <- g %*% weights}}
  outDf <- data.frame(x = xo[,1],outmat)
  names(outDf)[1:length(yo[1,])+1] <- yo[1,]
  return(outDf)}

anovacirc2way <- function(data, groupA=NULL, groupB=NULL, participant=NULL){
  
  grouplabelsA <- groupA
  grouplabelsB <- groupB
  participantlabels <- participant
  datavals <- data

  grouplabelsA <- as.factor(grouplabelsA)
  factorlistA <- levels(grouplabelsA)
  grouplabelsB <- as.factor(grouplabelsB)
  factorlistB <- levels(grouplabelsB)
  participantlabels <- as.factor(participantlabels)
  participantlist <- levels(participantlabels)
  
  grandmean <- mean(datavals)
  grandvar <- sum(abs(datavals - grandmean)^2)/(length(datavals)-1)
  
    SST <- grandvar*(length(datavals) - 1)
    
    SSW <- 0
    for (n in 1:nlevels(participantlabels)){SSW <- SSW + sum(abs(datavals[which(participantlabels==participantlist[n])] - mean(datavals[which(participantlabels==participantlist[n])]))^2)}
    dfW <- 2*(nlevels(participantlabels)*(nlevels(grouplabelsA)*nlevels(grouplabelsB)-1))
    
    SSBet <- SST - SSW  # between subjects SS - not actually used
    SSM <- 0
    for (a in 1:nlevels(grouplabelsA)){
      for (b in 1:nlevels(grouplabelsB)){
        i <- as.numeric(((grouplabelsA==grouplabelsA[a])))
        j <- as.numeric(((grouplabelsB==grouplabelsB[b])))
        indices <- which((i*j)>0)
        SSM <- SSM + (nlevels(participantlabels)*sum(abs(datavals[indices] - grandmean)^2))
      }
    }
    dfM <- 2*((nlevels(grouplabelsA)*nlevels(grouplabelsB))-1)
    
    SSR <- 0
    for (a in 1:nlevels(grouplabelsA)){
      for (b in 1:nlevels(grouplabelsB)){
        i <- as.numeric(((grouplabelsA==grouplabelsA[a])))
        j <- as.numeric(((grouplabelsB==grouplabelsB[b])))
        indices <- which((i*j)>0)
        condvar <- sum(abs(datavals[indices] - mean(datavals[indices]))^2)/(length(indices)-1)
        SSR <- SSR + (nlevels(participantlabels)-1)*condvar
      }
    }    
    dfR <- 2*(nlevels(participantlabels)-1)*(nlevels(grouplabelsA)*nlevels(grouplabelsB))
    
    groupmeansA <- NULL
    for (n in 1:nlevels(grouplabelsA)){groupmeansA[n] <- mean(datavals[which(grouplabelsA==factorlistA[n])])}
    SSA <- 0
    for (n in 1:nlevels(grouplabelsA)){SSA <- SSA + length(which(grouplabelsA==factorlistA[n]))*abs(groupmeansA[n]-grandmean)^2}
    dfA <- 2*(nlevels(grouplabelsA)-1)
    
    groupmeansB <- NULL
    for (n in 1:nlevels(grouplabelsB)){groupmeansB[n] <- mean(datavals[which(grouplabelsB==factorlistB[n])])}
    SSB <- 0
    for (n in 1:nlevels(grouplabelsB)){SSB <- SSB + length(which(grouplabelsB==factorlistB[n]))*abs(groupmeansB[n]-grandmean)^2}
    dfB <- 2*(nlevels(grouplabelsB)-1)
    
    SSAB <- SSW - (SSA + SSB)
    dfAB <- 2 * (nlevels(grouplabelsA)-1) * (nlevels(grouplabelsB)-1)
    
    MSA <- SSA/dfA
    MSB <- SSB/dfB
    MSAB <- SSAB/dfAB
    MSR <- SSR/dfR
    
    FratioA <- MSA/MSR
    pvalA <- pf(FratioA,df1=dfA,df2=dfR,lower.tail=FALSE)
    FratioB <- MSB/MSR
    pvalB <- pf(FratioB,df1=dfB,df2=dfR,lower.tail=FALSE)
    FratioAB <- MSAB/MSR
    pvalAB <- pf(FratioAB,df1=dfAB,df2=dfR,lower.tail=FALSE)
    
    method <- 'Factorial repeated measures ANOVA^2-circ'
    output <- data.frame(FratioA,pvalA,FratioB,pvalB,FratioAB,pvalAB,dfA,dfB,dfAB,dfR,method)
  
  return(output)
}

cleanup2D <- function(data){
  # helper function to clean up complex data by removing any data points more than 
  # SDthresh standard deviations from the mean (in Mahalanobis distance units)
  cartdata <- data.frame(Re(data),Im(data))
  output <- 0
  if (sum(cartdata)!=0){
    D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
    i <- which(D<SDthresh) 
    output <- mean(temp[i])}
return(output)}

bootstrap2D <- function(data){
  mbs <- data.frame(meanamp=0,lowerCI=0,upperCI=0)
    cartdata <- data.frame(Re(data),Im(data))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
    mbs <- amperrors(data[i],method='boot',quantiles=68,nresamples=nbootstraps)}
return(mbs)}

contrastsdB <- 20*log10(c(6,12,24,48,96))
colpal <- c('#FE5000','#8783CF','#228B22','#808080','#6d008b','#8B8000')
colpalmod <- c('#808080','#8B8000','#FE5000','#8783CF')

if (processdata==2){
# if we're going to need the pre-processed files, extract from zip file
  if (!file.exists(paste0(datadir,'P101summary.RData'))){
   if (file.exists('resources/allprocessed.zip')){file.copy('resources/allprocessed.zip',localdir)}
   if (!file.exists('resources/allprocessed.zip')){ 
          osfnode <- '2qu6y'
          osfproject <- osf_retrieve_node(osfnode)
          osffiles <- osf_ls_files(osfproject,n_max=300)
          fid <- which(osffiles$name=='allprocessed.zip')
          osf_download(osffiles[fid,],localdir,progress=TRUE)
   }
          unzip(paste0(localdir,'allprocessed.zip'),exdir=localdir)
          d <- dir(paste0(localdir,'allprocessed'),full.names=TRUE)
          file.copy(d,datadir)
  }
}


```

$^1$Department of Psychology, University of York, York, UK. YO10 5DD  
$^2$York Biomedical Research Institute, University of York, York, United Kingdom

Address for correspondence: Federico G. Segala, [federico.segala\@york.ac.uk](federico.segala@york.ac.uk)

# Abstract

The size of the pupils changes in response to levels of ambient light and is regulated by the autonomic nervous system. The role of the retinal photoreceptors in determining pupil size has been investigated using silent substitution. They have been shown to be directly involved in controlling and maintaining the size of the pupils, with the cones and rods driving the initial constriction and the intrinsically photosensitive retinal ganglion cells maintaining the size over prolonged time periods. Here, we used silent substitution and pupillometry to investigate binocular combination while targeting the intrinsically-photoreceptive retinal ganglion cells, the L-M pathway and the S-(L+M) pathway. We found that the signals between the two pupils are combined in a non-linear manner when targeting all the different photoreceptor classes and that the non-linear combination was different between each class, as reflected by the different magnitudes of interocular suppression measured for each pathway.

# Introduction

The autonomic nervous system regulates many involuntary bodily processes, including the constriction and dilation of the pupils in response to light [@McDougal2015]. The anatomical pathway from the retina to the subcortical nuclei controlling the pupillary light response (PLR) is well established: it includes the Pretectal Olivary nucleus (PON), the Superior Cervical ganglion and the Edinger-Westphal nucleus, which project to the iris sphincter muscles that directly control the pupil size [@McDougal2008; @McDougal2015; @Wang2015]. Additionally, the retinal photoreceptors (cones, rods and the recently discovered melanopsin-containing intrinsically photosensitive retinal ganglion cells, ipRGCs) have been shown to be directly involved in controlling and maintaining the size of the pupils [@Barrionuevo2014; @Barrionuevo2018; @Dacey2005; @Murray2018; @Spitschan2014; @Spitschan2019; @Woelders2018]. The cones have been shown to drive the initial rapid constriction of the pupils [@Mathot2018], while the slower and longer activation of the ipRGCs shows their role in maintaining the constriction over a prolonged period of time and in regulating the post-illumination pupillary response [@Markwell2010; @McDougal2010].

The ipRGCs are a unique photoreceptor class that has been discovered recently [@Provencio2000]. They express the photopigment melanopsin, which is involved in the regulation of the circadian rhythm [@Provencio2000; @Panda2002; @Ruby2002], and form a major input to the PON [@Dacey2003]. The first direct evidence of the involvement of the ipRGCs in the PLR was shown in rats by @Lucas2003 who genetically deleted the melanopsin gene from rats, resulting in the loss of the intrinsic photosensitivity of the cells and a reduced pupil constriction. This same behaviour was later also observed in primates and humans [@Gamlin2007], where it was demonstrated that the PLR continues during light presentation even when cone and rod signalling is blocked. This also demonstrates the primary role of the ipRGCs in maintaining pupil constriction over a prolonged time. It has also been shown that the ipRGCs receive inputs from the other photoreceptors (cones and rods) and are activated by them [@Dacey2005].

To investigate how specific photoreceptor classes control the size of the pupils, a technique known as silent substitution is used. Silent substitution exploits the fact that each photoreceptor class has a distinct spectral tuning that overlaps with the others. Using a multiprimary system, in which the primaries have different spectra, it is possible to target one class of photoreceptors while maintaining the others at a constant activity level, effectively silencing them [@Shapiro1996; @Spitschan2018, this paper also offers a clear explanation of how to implement silent substitution]. Studies using silent substitution have shown that the pupils behave differently depending on which photoreceptor or pathway is being stimulated. For example, pupil responses have been shown to be out of phase when the S cones are stimulated, relative to when the ipRGCs or the L+M cones are stimulated [@Spitschan2014; @Cao2015]. Additionally, when L and M cones are stimulated individually, there appears to be a paradoxical pupil response: increments in L cone stimulation cause a constriction of the pupil, while increments in M cone stimulation lead to a dilation of the pupil [@Woelders2018; @Murray2018].

Interaction between the two eyes and the rules of binocular combination have been extensively studied. For pattern vision in the visual cortex, at low contrast, binocular summation occurs [binocular presentation confers higher sensitivity than monocular presentation, @Baker2018; @Campbell1965; @Legge1984], while, at high contrast, ocularity invariance is implemented [the response to monocularly- and binocularly-presented patterns is equalised, @Baker2007; @Ding2006; @Meese2006]. Additionally, evidence of a binocular component to the PLR is shown by the existence of a consensual response of the pupil [the stimulation of one eye will cause constriction of the other eye, @Wyatt1981] and the rules of binocular combination between the pupils have also been recently investigated [@Segala2023], finding that combination happens non-linearly with evidence of interocular suppression.

Most of the studies that use silent substitution and that investigate the PLR stimulate only one eye. If the stimulated eye is pharmacologically dilated to control pupil size, the response from the unstimulated eye (known as the consensual response) can be recorded [e.g. @McDougal2010; @Spitschan2014]. While this approach controls the total amount of light incident at the retina, it does not permit investigation of binocular combination for specific photoreceptor pathways. Seeing that it is possible to directly investigate binocular combination of signals between the pupils, we decided to investigate this by designing an experiment that allowed us to binocularly target the ipRGCs, the L-M pathway and the S-(L+M) pathway individually while recording binocular pupillometric measures. We chose a primary flicker frequency of 0.5 Hz, which has been shown to elicit pupil responses from all three pathways [@Spitschan2014]. The final results are interpreted using a hierarchical Bayesian computational model of binocular vision.

# Methods

## Participants

Twenty-four participants were recruited for each of the four experiments for a total of ninety-six (68 females) adult participants, whose age ranged from 18 to 41. All participants had normal or corrected to normal binocular vision and normal colour vision, and gave written informed consent. Our procedures were approved by the Ethics Committee of the Department of Psychology at the University of York (identification number 184).

## Apparatus & stimuli

To present synchronised silent substitution contrast modulations independently to each eye, two light engines, each with 10 independently addressable LED colour channels (SpectraTuneLAB: LEDMOTIVE Technologies, LLC, Barcelona, Spain), were integrated into a customised viewing system. The light engines were operated via a Python interface to their REST API [@Martin2022], which supports synchronous launch and playback of spectral sequences prepared in advance and stored in JSON format. When preparing the spectral sequences, the age of participants was recorded to account for the yellowing of the lenses.

```{r allcons, fig.cap="Summary of the spectral power distributions and alpha-opic irradiances for the background and each experiment. Panel (a) shows a schematic of the binocular stimulation system for presenting spectrally tuned modulations independently to each eye. The VR headset was attached to a clamp stand that the experimenters could use to adjust the height and align the headset with the eyes of the participant. The participant's head was positioned on a chin rest to keep it in position throughout the entire experiment. Panels (b) and (c) show the spectral power distributions and the alpha-opic irradiances of the background spectra used for both eyes. Panels (d-k) show the power distributions and the alpha-opic irradiances relative to the background for the four experiments: luminance (d, e), melanopsin (f, g), L-M pathway (h, i) and S-(L+M) pathway (j, k). A positive difference power shows a positive modulation (white disc for the luminance experiment, magenta for the L-M pathway experiment and purple for the S-(L+M) experiment) and a negative difference power shows a negative modulation (black disc for the luminance experiment, cyan for the L-M pathway experiment and lime for the S-(L+M) experiment).", fig.align="center", out.width = '80%', echo=FALSE}

knitr::include_graphics(paste0(figdir,'allcons.pdf'))

```

The output from the light engines was directed through liquid light guides (LLG3-8H: Thorlabs Ltd, Cambridgeshire, UK) and diffused onto semi-opaque and highly diffusive white glass discs with a diameter of 50 mm for even illumination (34-473: Edmund Optics, York, UK). The light guide gaskets were butt-coupled to the light engine diffusers with threaded adapters (SM1A9, AD3LLG: Thorlabs Ltd, Cambridgeshire, UK) and the exiting ends of the light guides were mated with 51 mm depth optical cylinders (SM2L20: Thorlabs Ltd, Cambridgeshire, UK) via appropriately threaded adapters (AD3LLG, SM2A6: Thorlabs Ltd, Cambridgeshire, UK). The stimulus diffuser discs were retained at the front end of the optical cylinders approximately 51 mm from the light source, at which distance the output beam was sufficiently dispersed to afford even illumination of the diffuser when viewed from the front. To guarantee safe illumination levels, a circular neutral-density filter with the same diameter of the white glass discs (50 mm) and an optical density of 0.6 log units was placed in the optical path between the light source and the diffusers. A small circular piece of blackout material with a diameter of approximately 8 degrees (10 mm) was positioned centrally on the front of each diffuser disc to aid as a fusion lock, as a fixation point and to occlude the fovea.

The diffuser discs were positioned in the objective planes of the lenses of a modified VR headset (SHINECON SC-G01, Dongguan Shinecon Industrial Co. Ltd), which was used by the participants to view the stimuli. The stimuli were two discs of flickering light with a diameter of approximately 30 degrees, which were fused together into a cyclopean percept resembling a donut-shaped ring of light, similar to that used in other studies [e.g., @Barrionuevo2016; @Murray2018; @Spitschan2014; @Zele2018]. The VR headset modifications allowed for small adjustments to account for individual differences in interpupillary distance and focal length. The use of this set up allowed us to modulate the stimuli in three different ocular configurations, similar to the ones we used in our previous experiment [@Segala2023]: monocular, binocular and dichoptic. In the monocular configuration, the unstimulated eye still saw a non-flickering disc of mean luminance. A schematic of the stimulation system is shown in Figure \@ref(fig:allcons)a. Pupillometry data were collected using a binocular Pupil Core eye-tracker headset [Pupil Labs GmbH, Berlin, Germany, @Kassner2014] running at 120 Hz, and the signals were recorded with the Pupil Capture software.

## Procedure

Before the start of each experiment, participants adjusted the objective planes of the lenses with the help of the experimenter until the stimulus was in focus and they perceived the two pieces of blackout material as one fused piece.

```{r ExampleStims, fig.cap="Example of the different experimental conditions. Panel (a) shows one cycle of flicker in the achromatic luminance experiment. In this experiment, the stimulus flickers between black and white. At the beginning of the cycle (0s), the stimulus appears at half the intesity and appears grey to the viewer. At 0.5s, the stimulus reaches the maximum intensity of the flicker and appears white to the viewer. At 1s, the stimulus appears again at half maximum and once again appears to be grey to the viewer. At 1.5s, the stimulus reaches the minimum intensity of the flicker and appears black to the viewer. Panel (b) shows one cycle of the flickering in the L-M pathway experiment. In this experiment, the stimulus flickers between magenta (+L-M) and cyan (-L+M). At the beginning of the cycle (0s), the stimulus appears at zero cone contrast and appears to be grey to the viewer. At 0.5s, the stimulus reaches the maximum L-cone contrast and appears magenta to the viewer. At 1s, the stimulus appears again at zero cone contrast and switches colour, once again appearing to be grey to the viewer. At 1.5s, the stimulus reaches the minimum L-cone contrast and appears cyan to the viewer. Panel (c) shows one cycle of the flickering in the S-(L+M) pathway experiment. In this experiment, the stimulus flickers between purple (+S-(L+M)) and lime (-S+(L+M)). At the beginning of the cycle (0s), the stimulus appears at zero cone contrast and appears to be grey to the viewer. At 0.5s, the stimulus reaches the maximum S-cone contrast and appears purple to the viewer. At 1s, the stimulus appears again at zero cone contrast and switches colour, once again appearing to be grey to the viewer. At 1.5s, the stimulus reaches the minimum S-cone contrast and appears lime to the viewer.", fig.align="center", out.width = '95%', echo=FALSE}

knitr::include_graphics(paste0(figdir,'ExampleStims.pdf'))

```

We initially planned to examine pupil responses and EEG responses simultaneously to temporal modulations flickering at 2 Hz and 1.6 Hz while stimulating the periphery of the retina. While the experiment produced clear responses when presenting an achromatic light (see Figures \@ref(fig:appendixfig1) and \@ref(fig:appendixfig2) in Appendix 1), the responses were very noisy for the targeted photoreceptor class experiments (see Figures \@ref(fig:pupildataMel2Hz)-\@ref(fig:EEGdataS2Hz) in Appendix 2) for both the pupillometry and the EEG data. Therefore, we decided to lower the main frequency to 0.5 Hz as previous literature showed that it was slow enough to elicit a pupil response from all photoreceptor classes [@Spitschan2014] and we focussed on only recording pupillometry data as this frequency would be well below the minimum threshold to elicit EEG responses [@Norcia2015].

Pupil responses to binocular temporal contrast modulations were examined in a factorial design that combined six ocular conditions, two temporal frequencies (0.4 and 0.5 Hz) and five temporal contrast levels relative to the mean illuminance (6, 12, 24, 48 and 96%). This design, similar to what we used in our previous study [@Segala2023], was applied in four separate experiments, each with a different mode of photoreceptor stimulation. In the first three conditions, the discs flickered at 0.5 Hz, in either a monocular, binocular or dichoptic arrangement. In the dichoptic condition the non-target eye saw a flickering fixed contrast of 48%. In the remaining three conditions (the cross-frequency conditions) one eye’s disc flickered at 0.4 Hz, and the other eye’s disc flickered at 0.5 Hz. We also tested monocular responses at 0.4 Hz, as well as binocular (one eye sees each frequency at the target contrast) and dichoptic (target stimulus flickering at 0.5 Hz, mask contrast of 48% at 0.4 Hz in the other eye) arrangements. We counterbalanced presentation of the target stimulus across the left and right eyes.

For all experiments, sinusoidal contrast modulations were presented against the same background spectrum (matched between the eyes), which was used to achieve silent substitution in the three photoreceptor modulation experiments. The background spectra were defined by setting all channels to half maximum output for the brighter of the two devices (STLab 1, left eye) and then using the STLab 1/STLab 2 calibration ratio to find the equivalent settings for the companion device (STLab 2, right eye). The background spectrum illuminance was approximately 74 lux. The spectral power distributions and alpha-opic irradiances of the background spectra for both eyes are shown in Figures \@ref(fig:allcons)b-c.

### Experiment 1: luminance

The experiment was conducted in a windowless room, in which the only source of light was the modified VR headset. The participants sat as close as possible to the VR headset, leaving enough space for the eye-tracker to record the eyes. The experiment was carried out in a single session of 45 minutes, divided into three blocks of 15 minutes each. In each block, there were a total of 60 trials lasting 15 seconds each (12s of stimulus presentation, followed by 3s of interstimulus interval). The participants were given no task other than look at the black fixation dot while trying to minimise their blinking during the presentation period.

In this experiment, the participants saw a disc of achromatic flickering light (average illuminance of approximately 74 lux), flickering between black and white, at the different contrast levels defined earlier. An example of one cycle of flickering for the luminance experiment is shown in Figure \@ref(fig:ExampleStims)a. The spectral power distributions and alpha-opic irradiances relative to the background for the luminance experiment are shown in Figures \@ref(fig:allcons)d-e.

### Experiment 2: melanopsin

The experiment used the same equipment set-up and the same experimental conditions as Experiment 5. The procedure was also the same. However, at the beginning of each block, participants habituated for 2 minutes to the background that would be present throughout the entire experiment. During this adaptation period, participants were asked to fixate on the same black fixation dot positioned in the middle of the stimulus and were told that they could blink normally. At the end of the adaptation period, the experiment started immediately and the participants followed the same instructions given in Experiment 1.

In this experiment, the participants experienced contrast modulations that targeted the melanopsin-containing intrinsically photosensitive Retinal Ganglion cells, while ignoring rods and nominally silencing the cones. Michelson contrast levels represented a percentage of the maximum melanopic contrast available, which was predetermined to be approximately 22 \%. Under perfect silent substitution conditions, these modulations do not entail any changes in brightness or chromaticity: it is therefore very difficult to include an example to visualise the stimulus. However, silent substitution is never perfect, so participants reported small fluctuations in reddishness, greenishness and brightness due to open-field cone contrast artefacts. These fluctuations were especially present at higher contrasts. This can be observed in the alpha-opic irradiances relative to the background for the melanopsin experiment shown in Figure \@ref(fig:allcons)g, where a small activation of the S, L and M cones is observable. The spectral power distributions relative to the background for the melanopsin experiment is also shown in Figure \@ref(fig:allcons)f.

### Experiment 3: L-M postreceptoral ‘parvocellular’ pathway

The experiment used the same equipment set-up and the same experimental conditions as Experiment 5. The procedure was the same as Experiment 6, including the presence of a 2-minute adaptation period at the beginning of each block. Additionally, before the start of the experiment, participants completed a luminance nulling perceptual calibration procedure in L-M cone space on an Iiyama $\textrm{VisionMaster}^{\textrm{TM}}$ Pro 510 display (800 x 600 pixels, 60 Hz refresh rate). During the task, participants were presented with a disc flickering within the L-M cone space (between magenta and cyan). Using a trackball, participants adjusted the angle in cone space to find their subjective isoluminant point, which resulted in changing the flickering intensity of the stimulus until the amplitude of the flicker appeared to be minimised. The result was used to modify the requested contrasts during stimulus preparation so as to account for individual differences affecting perceived illuminance, principally the L:M cone ratio [@Carroll2002; @Hofer2005].

In this experiment, the participants experienced contrast modulations that targeted the L-M postreceptoral ‘parvocellular’ pathway while ignoring rods and nominally silencing S-cones and melanopsin. Michelson contrast levels represented a percentage of the maximum L-M contrast available for the background spectrum, which was determined in advance to be approximately 10 \%. As shown in Figure \@ref(fig:ExampleStims)b, participants experienced an isoluminant chromatic modulation between magenta (+L-M) and cyan (-L+M). The spectral power distributions and alpha-opic irradiances relative to the background for the L-M pathway experiment are shown in Figures \@ref(fig:allcons)h-i.

### Experiment 4: S-(L+M) ‘koniocelluar’ pathway 

The experiment used the same equipment set-up and the same experimental conditions as Experiment 5. The procedure was the same as Experiment 6, including the presence of a 2-minute adaptation period at the beginning of each block.

In this experiment, the participants experienced contrast modulations that targeted the S-(L+M) ‘koniocelluar’ pathway while ignoring rods and nominally silencing L/M cones and melanopsin. Michelson contrast levels represented a percentage of the maximum S-cone contrast available for the background spectrum, which was predetermined to be approximately 45 \%. As shown in Figure \@ref(fig:ExampleStims)c, participants experienced an isoluminant chromatic modulation between purple (+S-(L+M)) and lime (-S+(L+M)). The spectral power distributions and alpha-opic irradiances relative to the background for the S-(L+M) pathway experiment are shown in Figures \@ref(fig:allcons)j-k.

## Data analysis

The pupillometry data were analysed using the same method we used in our previous study [@Segala2023]. The data were converted from mp4 videos to a csv text file using the Pupil Player software [@Kassner2014], which estimated pupil diameter for each eye on each frame using a 3D model of the eyeball. The individual data were then loaded into R for analysis, where a ten-second waveform for each trial in each eye was extracted (excluding the first two seconds after stimulus onset). We interpolated across any dropped or missing frames to ensure regular and continuous sampling over time. The Fourier transform was calculated for each waveform, and all repetitions of each condition were pooled across eye and then averaged. Finally, data were averaged across all participants to obtain the group results. We used coherent averaging and at each stage we excluded data points with a Mahalanobis distance exceeding $D$ = `r SDthresh` from the complex-valued mean. The consensual response was also analysed (see Appendix 3 for more details and the results).

For all experiments, we used a bootstrapping procedure with `r nbootstraps` iterations to estimate standard errors across participants. All analysis and figure construction was conducted using a single R-script, available online, making this study fully computationally reproducible: https://osf.io/gdvt4/.

## Computational model and parameter estimation

To describe our data, we chose the same model described in our previous study [@Segala2023]. The model has the same general form as the first stage of the contrast gain control model proposed by @Meese2006 and omits the second stage. For the previous model that we used [@Segala2023], the exponent of the numerator had a fixed value of 2. Here, we allow this parameter (called _p_) to be free, in order to permit different shapes of contrast response function, e.g. saturating or super-saturating. The responses of the left eye and right eye channels are as follows:

\begin{equation}
\label{eq:respLchap4}
Resp_L = \frac{L^p}{Z + L^q + wR^q},
\end{equation}

\begin{equation}
\label{eq:respRchap4}
Resp_R = \frac{R^p}{Z + R^q + wL^q},
\end{equation}

\noindent where _L_ and _R_ are the contrast signals from the left and right eyes, _p_ and _q_ are exponents, _Z_ is a saturation constant that shifts the contrast-response function laterally, and _w_ is the weight of suppression from the other eye.

The responses from the two eyes are then summed binocularly:

\begin{equation}
\label{eq:respBchap4}
Resp_B = R_{max}(Resp_L + Resp_R) + k,
\end{equation}

\noindent where _n_ is a noise parameter, and $R_{max}$ scales the overall response amplitude.

We performed model fitting on the normalised amplitudes to account for amplitude differences between the experiments.

# Results

## Experiment 1

```{r luminance individual, include=FALSE, results='hide'}

# (download and) analyse individual participant data for the luminance experiment
if (processdata > 2){

  for(participant in 1:24){
    
    # only download and process data if this has not been done already for this participant
    if (!file.exists(paste0(datadir,'P',600+participant,'summary.RData'))){   

      # if there is no directory for this participant's data
      if (!file.exists(paste0(rawdir,'P',600+participant))){
        dir.create(paste0(rawdir,'P',600+participant))
        
       d <- dir(paste0(rawdir,'P',600+participant))
       
       if (length(d)==0){
         
         # if the tar file of this participant's data doesn't exist
         if (!file.exists(paste0(rawdir,'P',600+participant,'.zip'))){
           # download it from OSF
           if (!exists('osffiles')){
           osfnode <- '6u7db'
           osfproject <- osf_retrieve_node(osfnode)
          osffiles <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffiles$name==paste0('P',600+participant,'.zip'))
          osf_download(osffiles[fid,],rawdir,progress=TRUE)
         }
         
         # then unzip the tar file
         unzip(paste0(rawdir,'P',600+participant,'.zip'),exdir=paste0(rawdir,'P',600+participant))
         
         # and delete the tar file to save storage space
         file.remove(paste0(rawdir,'P',600+participant,'.zip'))
       }
      }
      
      d <- dir(paste0(rawdir,'P',600+participant),full.names=TRUE)

    tic()
  
    pupiltargets <- array(0,dim=c(3,2,60))
    pupilmasks <- pupiltargets
    pupiltargets2 <- pupiltargets
    pupilmasks2 <- pupiltargets
    pupilwaveforms <- array(0,dim=c(3,2,60,120*14))
    pupilspectra <- array(0,dim=c(3,2,60,300))
    timeseq <- seq(1/120,10,length.out=120*10)
    timeseq2 <- seq(1/120,14,length.out=120*14)
    targetindex <- (0.5*10)+1
    maskindex <- (0.4*10)+1
    targetindex2 <- (0.5*2*10)+1
    maskindex2 <- (2*0.4*10)+1
      
      
    repcounterP <- (1:60)*0
    afiles <- dir(path=paste0(rawdir,'P',600+participant),pattern='*annotations.csv',full.names=TRUE)

    for (block in 1:length(afiles)){
        tic()
        adata <- read.csv(paste0(rawdir,'P',600+participant,'/',paste0('P',600+participant,'_S',block),'_annotations.csv'))
        
        trialtimes <- NULL
        trialtypes <- NULL
        for (t in 1:(nrow(adata)/2)){
          trialtimes[t] <- mean(adata$timestamp[(t*2 - 1):(t*2)])
          trialtypes[t] <- adata$condition_code[t*2]
        }
        
        trialtypes[which(trialtypes>15)] <- trialtypes[which(trialtypes>15)] + 5
        inclist <- NULL
        for (t in 11:15){
          i <- which(trialtypes==t)
          inclist[t-10] <- i[2]
        }
        inclist <- inclist[which(!is.na(inclist))]
        trialtypes[inclist] <- trialtypes[inclist] + 5
        
        pdata <- read.csv(paste(rawdir,'P',600+participant,'/',paste0('P',600+participant,'_S',block),'_pupil_positions.csv',sep=''))
        pdata2 <- pdata[,c(1,3,4,14)]
        pdata2 <- pdata2[which(pdata2[,3]>0.2),]
        
        
        for (trialno in 1:length(trialtypes)){
          repcounterP[trialtypes[trialno]] <- repcounterP[trialtypes[trialno]] + 1
          for (eye in 1:2){
            eyedata <- pdata2[which(pdata2[,2]==(2-eye)),]      
            a <- which(eyedata[,1]>trialtimes[trialno]+2)
            b <- which(eyedata[,1]<(trialtimes[trialno]+12))
            i <- intersect(a,b)
            trial <- eyedata[i,]
            trial <- trial[which(!is.na(trial[,4])),]
            trial[,1] <- trial[,1] - trial[1,1]
            if (nrow(trial)>3){
              resampled <- interp1(trial[,1],trial[,4],timeseq,method='linear',extrap=TRUE)
              fspec <- (fft(resampled)/length(resampled))
              pupiltargets[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[targetindex]
              pupilmasks[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[maskindex]
              pupiltargets2[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[targetindex2]
              pupilmasks2[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[maskindex2]
              pupilspectra[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno],1:300] <- fspec[1:300]
            }
            
            a <- which(eyedata[,1]>(trialtimes[trialno]-1))
            b <- which(eyedata[,1]<(trialtimes[trialno]+13))
            i <- intersect(a,b)
            trial <- eyedata[i,]
            trial[,1] <- trial[,1] - trial[1,1]
            if (nrow(trial)>3){
              trial <- trial[which(!is.na(trial[,4])),]
              resampled <- interp1(trial[,1],trial[,4],timeseq2,method='linear',extrap=TRUE)
              pupilwaveforms[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno],] <- resampled - mean(resampled[1:120])
            }
          }
        }
    }
  
    cleanmeansP <- matrix(0,nrow=6,ncol=5)
    cleanmasksP <- matrix(0,nrow=6,ncol=5)
    cleanmeansP2 <- matrix(0,nrow=6,ncol=5)
    cleanmasksP2 <- matrix(0,nrow=6,ncol=5)

    for (cond in 1:6){
        startindex <- (10*(cond-1))
        for (level in 1:5){
          temp <- c(pupiltargets[,,startindex+level],pupiltargets[,,startindex+level+5])
          cartdata <- data.frame(Re(temp),Im(temp))
          if (sum(cartdata)!=0){
            D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
            i <- which(D<SDthresh)
            cleanmeansP[cond,level] <- mean(temp[i])}
          
          temp <- c(pupiltargets2[,,startindex+level],pupiltargets2[,,startindex+level+5])
          cartdata <- data.frame(Re(temp),Im(temp))
          if (sum(cartdata)!=0){
            D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
            i <- which(D<SDthresh)
            cleanmeansP2[cond,level] <- mean(temp[i])}
          
          temp <- c(pupilmasks[,,startindex+level],pupilmasks[,,startindex+level+5])
          cartdata <- data.frame(Re(temp),Im(temp))
          if (sum(cartdata)!=0){
            D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
            i <- which(D<SDthresh)
            cleanmasksP[cond,level] <- mean(temp[i])}
          
          temp <- c(pupilmasks2[,,startindex+level],pupilmasks2[,,startindex+level+5])
          cartdata <- data.frame(Re(temp),Im(temp))
          if (sum(cartdata)!=0){
            D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
            i <- which(D<SDthresh)
            cleanmasksP2[cond,level] <- mean(temp[i])}
        }
    }
  
    meanwavesP <- apply(pupilwaveforms[,,c(15,20),],4,mean,na.rm=TRUE)
    meanspectraP <- apply(pupilspectra[,,c(15,20),],4,mean,na.rm=TRUE)
    save(file=paste(datadir,'P',600+participant,'_summaryLum.RData',sep=''),list=c('cleanmeansP','cleanmasksP','cleanmeansP2','cleanmasksP2','meanspectraP','meanwavesP'))
    
    if (cleanupraw==1){file.remove(d)} # delete raw data files to save space
  }
  
  }}
```

```{r luminance group, include=FALSE, results='hide'}

# load in individual participant data and average, save group data
if (processdata > 1){
  for (participant in 1:24){
         # if the summary file of this participant's data doesn't exist
         if (!file.exists(paste0(datadir,'P',600+participant,'summaryLum.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '9ebtd'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name==paste0('P',600+participant,'summaryLum.RData'))
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }
}
  
  
  
  d <- dir(datadir,pattern='summaryLum.RData', full.names = TRUE)
  
  tempmasksP <- array(0,dim=c(length(d),6,5))
  tempmeansP <- tempmasksP
  tempmeansP2 <- tempmasksP
  tempmasksP2 <- tempmasksP
  tempspectraP <- array(0,dim=c(length(d),300))
  tempwavesP <- array(0,dim=c(length(d),1680))
  
  for (s in 1:length(d)){
    
    load(d[s])
    
    tempmasksP[s,,] <- cleanmasksP
    tempmeansP[s,,] <- cleanmeansP
    tempmasksP2[s,,] <- cleanmasksP2
    tempmeansP2[s,,] <- cleanmeansP2
    tempspectraP[s,] <- meanspectraP
    tempwavesP[s,] <- meanwavesP
  }
  
  tempspectraP <- tempspectraP[-c(2,4,13,20,26),]
  
  cleanmeansP <- matrix(0,nrow=6,ncol=5)
  cleanmeansPCI <- array(0,c(2,6,5))
  cleanmasksP <- matrix(0,nrow=6,ncol=5)
  cleanmasksPCI <- array(0,c(2,6,5))
  cleanmeansP2 <- matrix(0,nrow=6,ncol=5)
  cleanmeansP2CI <- array(0,c(2,6,5))
  cleanmasksP2 <- matrix(0,nrow=6,ncol=5)
  cleanmasksP2CI <- array(0,c(2,6,5))
  
  for (cond in 1:6){
    for (level in 1:5){
      
      temp <- tempmeansP[,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh)
        mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
        cleanmeansP[cond,level] <- mean(temp[i])
        cleanmeansPCI[1,cond,level] <- mbs$lowerCI
        cleanmeansPCI[2,cond,level] <- mbs$upperCI
      }
      
      temp <- tempmasksP[,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh)
        mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
        cleanmasksP[cond,level] <- mean(temp[i])
        cleanmasksPCI[1,cond,level] <- mbs$lowerCI
        cleanmasksPCI[2,cond,level] <- mbs$upperCI
      }
      
      temp <- tempmeansP2[,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh)
        mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
        cleanmeansP2[cond,level] <- mean(temp[i])
        cleanmeansP2CI[1,cond,level] <- mbs$lowerCI
        cleanmeansP2CI[2,cond,level] <- mbs$upperCI
      }
      
      temp <- tempmasksP2[,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh)
        mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
        cleanmasksP2[cond,level] <- mean(temp[i])
        cleanmasksP2CI[1,cond,level] <- mbs$lowerCI
        cleanmasksP2CI[2,cond,level] <- mbs$upperCI
      }
    }
  }
  
  meanspectraP <- (1:300)*0
  meanspectraPCI <- array(0,c(2,300))
  
  for (f in 2:300){
    temp <- tempspectraP[,f]
    cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
      mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
      meanspectraP[f] <- mbs$meanamp
      meanspectraPCI[1,f] <- mbs$lowerCI
      meanspectraPCI[2,f] <- mbs$upperCI
    }
  }
  
  meanwavesP <- NULL
  meanwavesPCI <- array(0,dim=c(2,dim(tempwavesP)[2]))
  
  nsubjs <- dim(tempwavesP)[1]
  for (t in 1:dim(tempwavesP)[2]){
    temp <- tempwavesP[,t]
    i <- which(abs(temp-mean(temp))<(SDthresh*sd(temp)))
    meanwavesP[t] <- mean(temp[i])
    bspop <- NULL
    for (s in 1:nbootstraps){bspop[s] <- mean(sample(temp[i],length(i),replace=TRUE))}
    meanwavesPCI[,t] <- quantile(bspop,c(0.16,0.84),na.rm=TRUE)
  }
  
  save(file=paste0(datadir,'AveragedataLum.RData'),list=c('meanwavesP','meanwavesPCI','cleanmeansP','cleanmeansPCI','cleanmasksP','cleanmasksPCI','cleanmeansP2','cleanmeansP2CI','cleanmasksP2','cleanmasksP2CI','meanspectraP','meanspectraPCI','tempmeansP','tempmeansP2','tempmasksP','tempmasksP2'))
  
  }
```

```{r luminance plot, include=FALSE, results='hide'}

# generate plot showing the group pupillometry data for the luminance experiment

         if (!file.exists(paste0(datadir,'AveragedataLum.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '9ebtd'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='AveragedataLum.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }

load(file=paste0(datadir,'AveragedataLum.RData'))


if (processdata > 0){
  
allPLumratios <- abs(cleanmeansP[2,])/abs(cleanmeansP[1,])
allPLum2ratios <- abs(cleanmeansP2[2,])/abs(cleanmeansP2[1,])

# plot figure  
plotlims <- c(15,40,0,3)  
ticklocsx <- contrastsdB
ticklabelsx <-c(6,12,24,48,96) 
ticklocsy <- seq(0,3,0.5)    # locations of tick marks on y axis
ticklabelsy <- ticklocsy

postscript("SumLum.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Bin:Mon ratio", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(contrastsdB,allPLumratios, col=colpal[1], lwd=3, cex=0.5)
lines(contrastsdB,allPLum2ratios, col=colpal[2], lwd=3, cex=0.5)
points(contrastsdB,allPLumratios, pch = 21, col='black', bg=colpal[1], cex=1.6, lwd=3)
points(contrastsdB,allPLum2ratios, pch = 22, col='black', bg=colpal[2], cex=1.6, lwd=3)

legend(contrastsdB[4],3,c('Lum 1F','Lum 2F'), pch=21:24, pt.bg=colpal[1:2],box.lwd=2,pt.cex=1.6,pt.lwd=3)
text(17,2.8,'(c)',adj=0.5,cex=2.5)

dev.off()

plotlims <- c(15,40,0,0.15)
plotlims2 <- c(15,40,0,0.015) 
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,0.15,0.05)
ticklocsy2 <- seq(0,0.015,0.005)    # locations of tick marks on y axis
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy
ticklabelsy2 <- ticklocsy2     # set labels for y ticks

postscript("CRF1p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 0.5Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansP[cond,]),contrastsdB,cleanmeansPCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP[cond,]),contrastsdB,cleanmeansPCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansP[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(22,0.15,c('Monocular','Binocular','Dichoptic'),pch=21:23,pt.bg=colpal[1:3],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.14,'(d)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF2p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Amplitude at 0.5Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

condlist <- c(1,5,6)
pointlist <- c(21,24,25)
for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)  
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)  
  points(contrastsdB,abs(cleanmeansP[condlist[cond],]), pch = pointlist[cond], col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
legend(22,0.15,c('Monocular','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[condlist],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.14,'(e)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF3p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 0.4Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 4:6){
  lines(contrastsdB,abs(cleanmasksP[cond,]), col=colpal[cond], lwd=3, cex=0.5)   
  arrows(contrastsdB,abs(cleanmasksP[cond,]),contrastsdB,cleanmasksPCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmasksP[cond,]),contrastsdB,cleanmasksPCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)    
  points(contrastsdB,abs(cleanmasksP[cond,]), pch = pointlist[cond-3], col='black', bg=colpal[cond], cex=1.6, lwd=3) 
}
legend(22,0.15,c('Monocular 0.4Hz','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[4:6],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.14,'(f)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF1p2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims2[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy2, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy2, side = 2, at=ticklocsy2, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 1Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP2[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansP2[cond,]),contrastsdB,cleanmeansP2CI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP2[cond,]),contrastsdB,cleanmeansP2CI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansP2[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(22,0.015,c('Monocular','Binocular','Dichoptic'),pch=21:23,pt.bg=colpal[1:3],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.014,'(g)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF2p2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims2[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy2, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy2, side = 2, at=ticklocsy2, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Amplitude at 1Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

condlist <- c(1,5,6)
pointlist <- c(21,24,25)
for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP2[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)  
  arrows(contrastsdB,abs(cleanmeansP2[condlist[cond],]),contrastsdB,cleanmeansP2CI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP2[condlist[cond],]),contrastsdB,cleanmeansP2CI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)  
  points(contrastsdB,abs(cleanmeansP2[condlist[cond],]), pch = pointlist[cond], col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
legend(22,0.015,c('Monocular','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[condlist],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.014,'(h)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF3p2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims2[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy2, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy2, side = 2, at=ticklocsy2, line=0.2, las=1)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 0.8Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 4:6){
  lines(contrastsdB,abs(cleanmasksP2[cond,]), col=colpal[cond], lwd=3, cex=0.5)   
  arrows(contrastsdB,abs(cleanmasksP2[cond,]),contrastsdB,cleanmasksP2CI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmasksP2[cond,]),contrastsdB,cleanmasksP2CI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)    
  points(contrastsdB,abs(cleanmasksP2[cond,]), pch = pointlist[cond-3], col='black', bg=colpal[cond], cex=1.6, lwd=3) 
}
legend(22,0.015,c('Monocular 0.4Hz','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[4:6],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.014,'(i)',adj=0.5,cex=2.5)

dev.off()

postscript("SpecP.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

frequencies <- (0:299)/10

plotlims <- c(0,2,0,0.15) 
ticklocsx <- seq(0,2,0.25)    # locations of tick marks on x axis
ticklocsy <- seq(0,0.15,0.05)    # locations of tick marks on y axis
ticklabelsx <-ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

polygon(frequencies[c(3:21,21:3)],c(meanspectraPCI[1,3:21],meanspectraPCI[2,21:3]),col=colpal[2],border=NA)

lines(frequencies[3:21],abs(meanspectraP[3:21]), col=colpal[2], lwd=3, cex=0.5) 

text(0.1,0.14,'(a)',adj=0.5,cex=2.5)

dev.off()

postscript("timecourseP.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

times <- seq((1/120)-1,13,1/120)
sinewave <- sin(0.5*times * 2*pi)
sinewave[1:120] <- 0
sinewave[1560:1680] <- 0

plotlims <- c(-1,13,-1,0.5)
ticklocsx <- seq(-1,13,1)    # locations of tick marks on x axis
ticklocsy <- seq(-1,0.5,0.5)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)
title(ylab="Amplitude (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

filt <- butter(3,0.083)
filtwaveP <- signal::filter(filt, meanwavesP)
filtU <- signal::filter(filt,meanwavesPCI[1,])
filtL <- signal::filter(filt,meanwavesPCI[2,])
polygon(times[c(1:length(times),length(times):1)],c(filtL,filtU[length(filtU):1]),col=colpal[2],border=NA)
lines(times, filtwaveP, col=colpal[2], lwd=1.5)
lines(times, (sinewave/10)-0.9, col='black', lwd=3)

text(-0.7,0.4,'(b)',adj=0.5,cex=2.5)

dev.off()

PostScriptTrace('CRF1p.ps')
p1 <- readPicture('CRF1p.ps.xml')
PostScriptTrace('CRF2p.ps')
p2 <- readPicture('CRF2p.ps.xml')
PostScriptTrace('CRF3p.ps')
p3 <- readPicture('CRF3p.ps.xml')
PostScriptTrace('CRF1p2.ps')
p4 <- readPicture('CRF1p2.ps.xml')
PostScriptTrace('CRF2p2.ps')
p5 <- readPicture('CRF2p2.ps.xml')
PostScriptTrace('CRF3p2.ps')
p6 <- readPicture('CRF3p2.ps.xml')
PostScriptTrace('SpecP.ps')
p7 <- readPicture('SpecP.ps.xml')
PostScriptTrace('timecourseP.ps')
p8 <- readPicture('timecourseP.ps.xml')
PostScriptTrace('SumLum.ps')
p9 <- readPicture('SumLum.ps.xml')

for (n in 1:length(p7@paths)){
  temp <- class(p7@paths[n]$path)[1]
  if (pmatch(temp,"PictureFill",nomatch=0)){
    if (sum(col2rgb(p7@paths[n]$path@rgb))<765){p7@paths[n]$path@rgb <- addalpha(p7@paths[n]$path@rgb,alpha=0.2)}}}

for (n in 1:length(p8@paths)){
  temp <- class(p8@paths[n]$path)[1]
  if (pmatch(temp,"PictureFill",nomatch=0)){
    if (sum(col2rgb(p8@paths[n]$path@rgb))<765){p8@paths[n]$path@rgb <- addalpha(p8@paths[n]$path@rgb,alpha=0.2)}}}

pdf(paste0(figdir,"pupildataLum.pdf"), bg="transparent", height = 20, width = 15)

par(mar=c(0.1,0.1,0.1,0.1))
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))

grid.picture(p1,x=0.17,y=0.4,width=0.32,height=1)
grid.picture(p2,x=0.5,y=0.4,width=0.32,height=1)
grid.picture(p3,x=0.83,y=0.4,width=0.32,height=1)
grid.picture(p4,x=0.17,y=0.15,width=0.32,height=1)
grid.picture(p5,x=0.5,y=0.15,width=0.32,height=1)
grid.picture(p6,x=0.83,y=0.15,width=0.32,height=1)
grid.picture(p7,x=0.25,y=0.83,width=0.5,height=1)
grid.picture(p8,x=0.25,y=0.63,width=0.5,height=1)
grid.picture(p9,x=0.75,y=0.71,width=0.5,height=1)

text(0.5,0.98,'Luminance',cex=4)

dev.off()

file.remove(c('CRF1p.ps','CRF2p.ps','CRF3p.ps','CRF1p2.ps','CRF2p2.ps','CRF3p2.ps','SpecP.ps','timecourseP.ps','SumLum.ps'))
file.remove(c('CRF1p.ps.xml','CRF2p.ps.xml','CRF3p.ps.xml','CRF1p2.ps.xml','CRF2p2.ps.xml','CRF3p2.ps.xml','SpecP.ps.xml','timecourseP.ps.xml','SumLum.ps.xml'))
   
  }
```

```{r luminance statistics, include=FALSE, results='hide'}

# do statistics on the luminance data
alldata <- NULL
groupID <- NULL
allP <- NULL
counter <- 0
for (cont in 1:dim(tempmeansP)[3]){
  for (p in 1:dim(tempmeansP)[1]){
    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,3,cont]
    groupID[counter] <- cont
    allP[counter] <- p
  }
}

# stats for the dichoptic (green line) condition (fig. 1c)
dichA2c <- anovacirc.test(alldata,group=groupID,participant=allP)

alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:12){
  for (lev in 1:5){
    for (cond in 1:2){
    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,cond,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- cond
    allP[counter] <- p
    }
  }
}

# stats for the mon and bin conditions (fig. 1c)
monbinPstats <- anovacirc2way(alldata,allgroupA,allgroupB,allP)

alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:12){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,1,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,3,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}

# stats for the mon and dich conditions (fig. 1c)
mondichPstats <- anovacirc2way(alldata,allgroupA,allgroupB,allP)

alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:12){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,1,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,5,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}

# stats for the mon and binX conditions (fig. 1d)
monbinPstatsX <- anovacirc2way(alldata,allgroupA,allgroupB,allP)

alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:12){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,1,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,6,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}

# stats for the mon and dichX conditions (fig. 1d)
mondichPstatsX <- anovacirc2way(alldata,allgroupA,allgroupB,allP)

```

The results of the luminance experiment are summarised in Figure \@ref(fig:pupildataLum). The average Fourier spectrum is displayed in Figure \@ref(fig:pupildataLum)a, and shows a strong response at the first harmonic frequency (0.5 Hz) and a weaker but still clear response at the second harmonic frequency (1 Hz). These results demonstrate that we can evoke measurable steady-state pupil responses at 0.5 Hz by stimulating the periphery of the retina. The group average waveform for binocular presentation is shown in Figure \@ref(fig:pupildataLum)b. There is a substantial pupil constriction at stimulus onset, followed by very visible oscillations at the flicker frequency (0.5 Hz, see waveform at foot).

Figure \@ref(fig:pupildataLum)d shows contrast response functions in response to stimuli flickering only at 0.5 Hz. The amplitude of the binocular condition (blue squares) is consistently greater than that of the monocular condition (red circles) across all target contrasts. A $2\times5$ repeated measures $ANOVA^2_{circ}$ [@Baker2021] comparing these conditions revealed a significant main effect of target contrast (F(`r monbinPstats$dfA`,`r monbinPstats$dfR`) = `r round(monbinPstats$FratioA,digits=2)`, $p$ < 0.001), a significant effect of condition (F(`r monbinPstats$dfB`,`r monbinPstats$dfR`) = `r round(monbinPstats$FratioB,digits=2)`, $p$ < 0.001), and a significant interaction (F(`r monbinPstats$dfAB`,`r monbinPstats$dfR`) = `r round(monbinPstats$FratioAB,digits=2)`, $p$ < 0.001). The dichoptic condition (green diamonds) begins at a much higher amplitude, owing to binocular combination of the target and high (48%) contrast mask, and then increases with increasing target contrast (main effect of target contrast: F(`r dichA2c$dfM`,`r dichA2c$dfR`) = `r round(dichA2c$Fratio,digits=2)`, $p$ < 0.001). Similar results can be observed at the second harmonic in Figure \@ref(fig:pupildataLum)g (see Tables \@ref(tab:TableStatsFig3g) and \@ref(tab:TableStatsMonDichFig3g) for summary of statistical results). 

In Figure \@ref(fig:pupildataLum)e, we plot responses to monocular target stimuli flickering at 0.5 Hz, when the other eye viewed stimuli flickering at 0.4 Hz (the red monocular-only data are replotted from Figure \@ref(fig:pupildataLum)d for comparison). When the 0.4 Hz component had the same contrast as the target (the binocular cross condition, shown in purple) responses were suppressed slightly across all target contrasts (interaction between contrast and condition: F(`r monbinPstatsX$dfAB`,`r monbinPstatsX$dfR`) = `r round(monbinPstatsX$FratioAB,digits=2)`, $p$ < 0.001). When the 0.4 Hz component had a fixed contrast of 48 % (the dichoptic cross condition, shown in yellow), responses were also suppressed slightly across the contrast range (interaction between contrast and condition: F(`r mondichPstatsX$dfAB`,`r mondichPstatsX$dfR`) = `r round(mondichPstatsX$FratioAB,digits=2)`, $p$ < 0.001). The same pattern of results was generally observed at the second harmonic (Figure \@ref(fig:pupildataLum)h, see Tables \@ref(tab:TableStatsMonBinXFig3h) and \@ref(tab:TableStatsMonDichXFig3h) for summary of statistical results).

```{r pupildataLum, fig.cap="Summary of pupillometry results for the luminance experiment for N=12 participants. Panel (a) shows the average Fourier spectrum. Panel (b) shows a group average waveform for binocular presentation (low pass filtered at 5 Hz), with the driving signal plotted at the foot. Panel (c) shows the ratio of binocular to monocular response. The red circles show the ratios at the first harmonic (0.5 Hz) and the blue squares show the ratios at the second harmonic (1 Hz). Panels (d,e) show contrast response functions at 0.5 Hz for different conditions. Panel (f) shows contrast response functions at 0.4 Hz for three conditions. Panels (g-i) are in the same format but for the second harmonic responses. Shaded regions and error bars indicate bootstrapped standard errors.", fig.align="center", out.width = '85%', echo=FALSE}

knitr::include_graphics(paste0(figdir,'pupildataLum.pdf'))
```

Figure \@ref(fig:pupildataLum)f shows responses at 0.4 Hz, for the same conditions, as well as for a condition in which a monocular stimulus flickered at 0.4 Hz (grey circles). Again there was evidence of weak suppression between the eyes, as the purple triangles fall below the grey circles (see Table \@ref(tab:TableStatsMonXBinXFig3f) for summary of statistical results). The dichoptic cross condition also shows evidence of suppressive modulation with target contrast (see Table \@ref(tab:TableStatsMonXDichXFig3f) for summary of statistical results). The same pattern is also observed at the second harmonic (Figure \@ref(fig:pupildataLum)i, see Tables \@ref(tab:TableStatsMonXBinXFig3i) and \@ref(tab:TableStatsMonXDichXFig3i) for summary of statistical results).

Finally, we calculated the binocular to monocular ratio at the first and second harmonic frequencies. Figure \@ref(fig:pupildataLum)c shows that these ratios are generally below 2 at both frequencies, suggesting that there is summation happening between the eyes but also interocular suppression, therefore suggesting that the signals between the eyes are combined non-linearly. At the highest contrast at the second harmonic, the ratio is close to 2, perhaps indicating that a more linear combination is happening for higher contrasts.

## Experiment 2

```{r melanopsin individual, include=FALSE, results='hide'}

# (download and) analyse individual participant data for the melanopsin experiment
if (processdata > 2){

  for(participant in 1:24){
    
    # only download and process data if this has not been done already for this participant
    if (!file.exists(paste0(datadir,'P',500+participant,'summary.RData'))){   

      # if there is no directory for this participant's data
      if (!file.exists(paste0(rawdir,'P',500+participant))){
        dir.create(paste0(rawdir,'P',500+participant))
        
       d <- dir(paste0(rawdir,'P',500+participant))
       
       if (length(d)==0){
         
         # if the tar file of this participant's data doesn't exist
         if (!file.exists(paste0(rawdir,'P',500+participant,'.zip'))){
           # download it from OSF
           if (!exists('osffiles')){
           osfnode <- 'xkgd9'
           osfproject <- osf_retrieve_node(osfnode)
          osffiles <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffiles$name==paste0('P',500+participant,'.zip'))
          osf_download(osffiles[fid,],rawdir,progress=TRUE)
         }
         
         # then unzip the tar file
         unzip(paste0(rawdir,'P',500+participant,'.zip'),exdir=paste0(rawdir,'P',500+participant))
         
         # and delete the tar file to save storage space
         file.remove(paste0(rawdir,'P',500+participant,'.zip'))
       }
      }
      
      d <- dir(paste0(rawdir,'P',500+participant),full.names=TRUE)

    tic()
  
    pupiltargets <- array(0,dim=c(3,2,60))
    pupilmasks <- pupiltargets
    pupiltargets2 <- pupiltargets
    pupilmasks2 <- pupiltargets
    pupilwaveforms <- array(0,dim=c(3,2,60,120*14))
    pupilspectra <- array(0,dim=c(3,2,60,300))
    timeseq <- seq(1/120,10,length.out=120*10)
    timeseq2 <- seq(1/120,14,length.out=120*14)
    targetindex <- (0.5*10)+1
    maskindex <- (0.4*10)+1
    targetindex2 <- (0.5*2*10)+1
    maskindex2 <- (2*0.4*10)+1
      
      
    repcounterP <- (1:60)*0
    afiles <- dir(path=paste0(rawdir,'P',500+participant),pattern='*annotations.csv',full.names=TRUE)

    for (block in 1:length(afiles)){
        tic()
        adata <- read.csv(paste0(rawdir,'P',500+participant,'/',paste0('P',500+participant,'_S',block),'_annotations.csv'))
        
        trialtimes <- NULL
        trialtypes <- NULL
        for (t in 1:(nrow(adata)/2)){
          trialtimes[t] <- mean(adata$timestamp[(t*2 - 1):(t*2)])
          trialtypes[t] <- adata$condition_code[t*2]
        }
        
        trialtypes[which(trialtypes>15)] <- trialtypes[which(trialtypes>15)] + 5
        inclist <- NULL
        for (t in 11:15){
          i <- which(trialtypes==t)
          inclist[t-10] <- i[2]
        }
        inclist <- inclist[which(!is.na(inclist))]
        trialtypes[inclist] <- trialtypes[inclist] + 5
        
        pdata <- read.csv(paste(rawdir,'P',500+participant,'/',paste0('P',500+participant,'_S',block),'_pupil_positions.csv',sep=''))
        pdata2 <- pdata[,c(1,3,4,14)]
        pdata2 <- pdata2[which(pdata2[,3]>0.2),]
        
        
        for (trialno in 1:length(trialtypes)){
          repcounterP[trialtypes[trialno]] <- repcounterP[trialtypes[trialno]] + 1
          for (eye in 1:2){
            eyedata <- pdata2[which(pdata2[,2]==(2-eye)),]      
            a <- which(eyedata[,1]>trialtimes[trialno]+2)
            b <- which(eyedata[,1]<(trialtimes[trialno]+12))
            i <- intersect(a,b)
            trial <- eyedata[i,]
            trial <- trial[which(!is.na(trial[,4])),]
            trial[,1] <- trial[,1] - trial[1,1]
            if (nrow(trial)>3){
              resampled <- interp1(trial[,1],trial[,4],timeseq,method='linear',extrap=TRUE)
              fspec <- (fft(resampled)/length(resampled))
              pupiltargets[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[targetindex]
              pupilmasks[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[maskindex]
              pupiltargets2[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[targetindex2]
              pupilmasks2[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[maskindex2]
              pupilspectra[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno],1:300] <- fspec[1:300]
            }
            
            a <- which(eyedata[,1]>(trialtimes[trialno]-1))
            b <- which(eyedata[,1]<(trialtimes[trialno]+13))
            i <- intersect(a,b)
            trial <- eyedata[i,]
            trial[,1] <- trial[,1] - trial[1,1]
            if (nrow(trial)>3){
              trial <- trial[which(!is.na(trial[,4])),]
              resampled <- interp1(trial[,1],trial[,4],timeseq2,method='linear',extrap=TRUE)
              pupilwaveforms[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno],] <- resampled - mean(resampled[1:120])
            }
          }
        }
    }
  
    cleanmeansP <- matrix(0,nrow=6,ncol=5)
    cleanmasksP <- matrix(0,nrow=6,ncol=5)
    cleanmeansP2 <- matrix(0,nrow=6,ncol=5)
    cleanmasksP2 <- matrix(0,nrow=6,ncol=5)

    for (cond in 1:6){
        startindex <- (10*(cond-1))
        for (level in 1:5){
          temp <- c(pupiltargets[,,startindex+level],pupiltargets[,,startindex+level+5])
          cartdata <- data.frame(Re(temp),Im(temp))
          if (sum(cartdata)!=0){
            D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
            i <- which(D<SDthresh)
            cleanmeansP[cond,level] <- mean(temp[i])}
          
          temp <- c(pupiltargets2[,,startindex+level],pupiltargets2[,,startindex+level+5])
          cartdata <- data.frame(Re(temp),Im(temp))
          if (sum(cartdata)!=0){
            D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
            i <- which(D<SDthresh)
            cleanmeansP2[cond,level] <- mean(temp[i])}
          
          temp <- c(pupilmasks[,,startindex+level],pupilmasks[,,startindex+level+5])
          cartdata <- data.frame(Re(temp),Im(temp))
          if (sum(cartdata)!=0){
            D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
            i <- which(D<SDthresh)
            cleanmasksP[cond,level] <- mean(temp[i])}
          
          temp <- c(pupilmasks2[,,startindex+level],pupilmasks2[,,startindex+level+5])
          cartdata <- data.frame(Re(temp),Im(temp))
          if (sum(cartdata)!=0){
            D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
            i <- which(D<SDthresh)
            cleanmasksP2[cond,level] <- mean(temp[i])}
        }
    }
  
    meanwavesP <- apply(pupilwaveforms[,,c(15,20),],4,mean,na.rm=TRUE)
    meanspectraP <- apply(pupilspectra[,,c(15,20),],4,mean,na.rm=TRUE)
    save(file=paste(datadir,'P',500+participant,'_summaryMel.RData',sep=''),list=c('cleanmeansP','cleanmasksP','cleanmeansP2','cleanmasksP2','meanspectraP','meanwavesP'))
    
    if (cleanupraw==1){file.remove(d)} # delete raw data files to save space
    }
  }}
```

```{r melanopsin group, include=FALSE, results='hide'}

# load in individual participant data and average, save group data
if (processdata > 1){
  for (participant in 1:24){
         # if the summary file of this participant's data doesn't exist
         if (!file.exists(paste0(datadir,'P',500+participant,'summaryMel.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '9ebtd'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name==paste0('P',500+participant,'summaryMel.RData'))
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }
}
  
  d <- dir(datadir,pattern='summaryMel.RData', full.names = TRUE)
  
  tempmasksP <- array(0,dim=c(length(d),6,5))
  tempmeansP <- tempmasksP
  tempmeansP2 <- tempmasksP
  tempmasksP2 <- tempmasksP
  tempspectraP <- array(0,dim=c(length(d),300))
  tempwavesP <- array(0,dim=c(length(d),1680))
  
  for (s in 1:length(d)){
    
    load(d[s])
    
    tempmasksP[s,,] <- cleanmasksP
    tempmeansP[s,,] <- cleanmeansP
    tempmasksP2[s,,] <- cleanmasksP2
    tempmeansP2[s,,] <- cleanmeansP2
    tempspectraP[s,] <- meanspectraP
    tempwavesP[s,] <- meanwavesP
  }
  
  tempspectraP <- tempspectraP[-c(2,4,13,20,26),]
  
  cleanmeansP <- matrix(0,nrow=6,ncol=5)
  cleanmeansPCI <- array(0,c(2,6,5))
  cleanmasksP <- matrix(0,nrow=6,ncol=5)
  cleanmasksPCI <- array(0,c(2,6,5))
  cleanmeansP2 <- matrix(0,nrow=6,ncol=5)
  cleanmeansP2CI <- array(0,c(2,6,5))
  cleanmasksP2 <- matrix(0,nrow=6,ncol=5)
  cleanmasksP2CI <- array(0,c(2,6,5))
  
  for (cond in 1:6){
    for (level in 1:5){
      
      temp <- tempmeansP[,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh)
        mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
        cleanmeansP[cond,level] <- mean(temp[i])
        cleanmeansPCI[1,cond,level] <- mbs$lowerCI
        cleanmeansPCI[2,cond,level] <- mbs$upperCI
      }
      
      temp <- tempmasksP[,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh)
        mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
        cleanmasksP[cond,level] <- mean(temp[i])
        cleanmasksPCI[1,cond,level] <- mbs$lowerCI
        cleanmasksPCI[2,cond,level] <- mbs$upperCI
      }
      
      temp <- tempmeansP2[,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh)
        mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
        cleanmeansP2[cond,level] <- mean(temp[i])
        cleanmeansP2CI[1,cond,level] <- mbs$lowerCI
        cleanmeansP2CI[2,cond,level] <- mbs$upperCI
      }
      
      temp <- tempmasksP2[,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh)
        mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
        cleanmasksP2[cond,level] <- mean(temp[i])
        cleanmasksP2CI[1,cond,level] <- mbs$lowerCI
        cleanmasksP2CI[2,cond,level] <- mbs$upperCI
      }
    }
  }
  
  meanspectraP <- (1:300)*0
  meanspectraPCI <- array(0,c(2,300))
  
  for (f in 2:300){
    temp <- tempspectraP[,f]
    cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
      mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
      meanspectraP[f] <- mbs$meanamp
      meanspectraPCI[1,f] <- mbs$lowerCI
      meanspectraPCI[2,f] <- mbs$upperCI
    }
  }
  
  meanwavesP <- NULL
  meanwavesPCI <- array(0,dim=c(2,dim(tempwavesP)[2]))
  
  nsubjs <- dim(tempwavesP)[1]
  for (t in 1:dim(tempwavesP)[2]){
    temp <- tempwavesP[,t]
    i <- which(abs(temp-mean(temp))<(SDthresh*sd(temp)))
    meanwavesP[t] <- mean(temp[i])
    bspop <- NULL
    for (s in 1:nbootstraps){bspop[s] <- mean(sample(temp[i],length(i),replace=TRUE))}
    meanwavesPCI[,t] <- quantile(bspop,c(0.16,0.84),na.rm=TRUE)
  }
  
  save(file=paste0(datadir,'AveragedataMel.RData'),list=c('meanwavesP','meanwavesPCI','cleanmeansP','cleanmeansPCI','cleanmasksP','cleanmasksPCI','cleanmeansP2','cleanmeansP2CI','cleanmasksP2','cleanmasksP2CI','meanspectraP','meanspectraPCI','tempmeansP','tempmeansP2','tempmasksP','tempmasksP2'))

  }
```

```{r melanopsin plot, include=FALSE, results='hide'}

# generate plot showing the group pupillometry data for the melanopsin experiment 
if (!file.exists(paste0(datadir,'AveragedataMel.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '9ebtd'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='AveragedataMel.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }

load(file=paste0(datadir,'AveragedataMel.RData'))

if (processdata > 0){
  
allPMelratios <- abs(cleanmeansP[2,])/abs(cleanmeansP[1,])
allPMel2ratios <- abs(cleanmeansP2[2,])/abs(cleanmeansP2[1,])

# plot figure  
plotlims <- c(15,40,0,5)  
ticklocsx <- contrastsdB
ticklabelsx <-c(6,12,24,48,96) 
ticklocsy <- seq(0,5,0.5)    # locations of tick marks on y axis
ticklabelsy <- ticklocsy

postscript("SumMel.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (% of max)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Bin:Mon ratio", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(contrastsdB,allPMelratios, col=colpal[1], lwd=3, cex=0.5)
lines(contrastsdB,allPMel2ratios, col=colpal[2], lwd=3, cex=0.5)
points(contrastsdB,allPMelratios, pch = 21, col='black', bg=colpal[1], cex=1.6, lwd=3)
points(contrastsdB,allPMel2ratios, pch = 22, col='black', bg=colpal[2], cex=1.6, lwd=3)

legend(contrastsdB[2],5,c('Mel 1F','Mel 2F'), pch=21:24, pt.bg=colpal[1:2],box.lwd=2,pt.cex=1.6,pt.lwd=3)
text(17,4.8,'(c)',adj=0.5,cex=2.5)

dev.off()

plotlims <- c(15,40,0,0.02)
plotlims2 <- c(15,40,0,0.015) 
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,0.02,0.005)
ticklocsy2 <- seq(0,0.015,0.005)    # locations of tick marks on y axis
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy
ticklabelsy2 <- ticklocsy2     # set labels for y ticks

postscript("CRF1p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (% of max)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 0.5Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansP[cond,]),contrastsdB,cleanmeansPCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP[cond,]),contrastsdB,cleanmeansPCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansP[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(22,0.02,c('Monocular','Binocular','Dichoptic'),pch=21:23,pt.bg=colpal[1:3],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.019,'(d)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF2p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (% of max)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Amplitude at 0.5Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

condlist <- c(1,5,6)
pointlist <- c(21,24,25)
for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)  
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)  
  points(contrastsdB,abs(cleanmeansP[condlist[cond],]), pch = pointlist[cond], col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
legend(22,0.02,c('Monocular','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[condlist],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.019,'(e)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF3p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (% of max)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 0.4Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 4:6){
  lines(contrastsdB,abs(cleanmasksP[cond,]), col=colpal[cond], lwd=3, cex=0.5)   
  arrows(contrastsdB,abs(cleanmasksP[cond,]),contrastsdB,cleanmasksPCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmasksP[cond,]),contrastsdB,cleanmasksPCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)    
  points(contrastsdB,abs(cleanmasksP[cond,]), pch = pointlist[cond-3], col='black', bg=colpal[cond], cex=1.6, lwd=3) 
}
legend(22,0.02,c('Monocular 0.4Hz','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[4:6],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.019,'(f)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF1p2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims2[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy2, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy2, side = 2, at=ticklocsy2, line=0.2, las=1) 
title(xlab="Target contrast (% of max)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 1Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP2[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansP2[cond,]),contrastsdB,cleanmeansP2CI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP2[cond,]),contrastsdB,cleanmeansP2CI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansP2[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(22,0.015,c('Monocular','Binocular','Dichoptic'),pch=21:23,pt.bg=colpal[1:3],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.014,'(g)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF2p2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims2[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy2, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy2, side = 2, at=ticklocsy2, line=0.2, las=1)
title(xlab="Target contrast (% of max)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Amplitude at 1Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

condlist <- c(1,5,6)
pointlist <- c(21,24,25)
for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP2[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)  
  arrows(contrastsdB,abs(cleanmeansP2[condlist[cond],]),contrastsdB,cleanmeansP2CI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP2[condlist[cond],]),contrastsdB,cleanmeansP2CI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)  
  points(contrastsdB,abs(cleanmeansP2[condlist[cond],]), pch = pointlist[cond], col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
legend(22,0.015,c('Monocular','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[condlist],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.014,'(h)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF3p2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims2[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy2, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy2, side = 2, at=ticklocsy2, line=0.2, las=1)
title(xlab="Target contrast (% of max)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 0.8Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 4:6){
  lines(contrastsdB,abs(cleanmasksP2[cond,]), col=colpal[cond], lwd=3, cex=0.5)   
  arrows(contrastsdB,abs(cleanmasksP2[cond,]),contrastsdB,cleanmasksP2CI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmasksP2[cond,]),contrastsdB,cleanmasksP2CI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)    
  points(contrastsdB,abs(cleanmasksP2[cond,]), pch = pointlist[cond-3], col='black', bg=colpal[cond], cex=1.6, lwd=3) 
}
legend(22,0.015,c('Monocular 0.4Hz','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[4:6],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.014,'(i)',adj=0.5,cex=2.5)

dev.off()

postscript("SpecP.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

frequencies <- (0:299)/10

plotlims <- c(0,2,0,0.015) 
ticklocsx <- seq(0,2,0.25)    # locations of tick marks on x axis
ticklocsy <- seq(0,0.015,0.005)    # locations of tick marks on y axis
ticklabelsx <-ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

polygon(frequencies[c(3:21,21:3)],c(meanspectraPCI[1,3:21],meanspectraPCI[2,21:3]),col=colpal[2],border=NA)

lines(frequencies[3:21],abs(meanspectraP[3:21]), col=colpal[2], lwd=3, cex=0.5) 

text(0.1,0.014,'(a)',adj=0.5,cex=2.5)

dev.off()

postscript("timecourseP.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

times <- seq((1/120)-1,13,1/120)
sinewave <- sin(0.5*times * 2*pi)
sinewave[1:120] <- 0
sinewave[1560:1680] <- 0

plotlims <- c(-1,13,-0.5,0.5)
ticklocsx <- seq(-1,13,1)    # locations of tick marks on x axis
ticklocsy <- seq(-0.5,0.5,0.5)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)
title(ylab="Amplitude (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

filt <- butter(3,0.083)
filtwaveP <- signal::filter(filt, meanwavesP)
filtU <- signal::filter(filt,meanwavesPCI[1,])
filtL <- signal::filter(filt,meanwavesPCI[2,])
polygon(times[c(1:length(times),length(times):1)],c(filtL,filtU[length(filtU):1]),col=colpal[2],border=NA)
lines(times, filtwaveP, col=colpal[2], lwd=1.5)
lines(times, (sinewave/10)-0.4, col='black', lwd=3)

text(-0.7,0.4,'(b)',adj=0.5,cex=2.5)

dev.off()

PostScriptTrace('CRF1p.ps')
p1 <- readPicture('CRF1p.ps.xml')
PostScriptTrace('CRF2p.ps')
p2 <- readPicture('CRF2p.ps.xml')
PostScriptTrace('CRF3p.ps')
p3 <- readPicture('CRF3p.ps.xml')
PostScriptTrace('CRF1p2.ps')
p4 <- readPicture('CRF1p2.ps.xml')
PostScriptTrace('CRF2p2.ps')
p5 <- readPicture('CRF2p2.ps.xml')
PostScriptTrace('CRF3p2.ps')
p6 <- readPicture('CRF3p2.ps.xml')
PostScriptTrace('SpecP.ps')
p7 <- readPicture('SpecP.ps.xml')
PostScriptTrace('timecourseP.ps')
p8 <- readPicture('timecourseP.ps.xml')
PostScriptTrace('SumMel.ps')
p9 <- readPicture('SumMel.ps.xml')

for (n in 1:length(p7@paths)){
  temp <- class(p7@paths[n]$path)[1]
  if (pmatch(temp,"PictureFill",nomatch=0)){
    if (sum(col2rgb(p7@paths[n]$path@rgb))<765){p7@paths[n]$path@rgb <- addalpha(p7@paths[n]$path@rgb,alpha=0.2)}}}

for (n in 1:length(p8@paths)){
  temp <- class(p8@paths[n]$path)[1]
  if (pmatch(temp,"PictureFill",nomatch=0)){
    if (sum(col2rgb(p8@paths[n]$path@rgb))<765){p8@paths[n]$path@rgb <- addalpha(p8@paths[n]$path@rgb,alpha=0.2)}}}

pdf(paste0(figdir,"pupildataMel.pdf"), bg="transparent", height = 20, width = 15)

par(mar=c(0.1,0.1,0.1,0.1))
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))

grid.picture(p1,x=0.17,y=0.4,width=0.32,height=1)
grid.picture(p2,x=0.5,y=0.4,width=0.32,height=1)
grid.picture(p3,x=0.83,y=0.4,width=0.32,height=1)
grid.picture(p4,x=0.17,y=0.15,width=0.32,height=1)
grid.picture(p5,x=0.5,y=0.15,width=0.32,height=1)
grid.picture(p6,x=0.83,y=0.15,width=0.32,height=1)
grid.picture(p7,x=0.25,y=0.85,width=0.5,height=1)
grid.picture(p8,x=0.25,y=0.63,width=0.5,height=1)
grid.picture(p9,x=0.75,y=0.73,width=0.5,height=1)

text(0.5,0.98,'Melanopsin',cex=4)

dev.off()

file.remove(c('CRF1p.ps','CRF2p.ps','CRF3p.ps','CRF1p2.ps','CRF2p2.ps','CRF3p2.ps','SpecP.ps','timecourseP.ps','SumMel.ps'))
file.remove(c('CRF1p.ps.xml','CRF2p.ps.xml','CRF3p.ps.xml','CRF1p2.ps.xml','CRF2p2.ps.xml','CRF3p2.ps.xml','SpecP.ps.xml','timecourseP.ps.xml','SumMel.ps.xml'))
  
  }
```

```{r melanopsin statistics, include=FALSE, results='hide'}

# do statistics on the melanopsin data
alldata <- NULL
groupID <- NULL
allP <- NULL
counter <- 0
for (cont in 1:dim(tempmeansP)[3]){
  for (p in 1:dim(tempmeansP)[1]){
    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,3,cont]
    groupID[counter] <- cont
    allP[counter] <- p
  }
}
dichA2c <- anovacirc.test(alldata,group=groupID,participant=allP)

alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:12){
  for (lev in 1:5){
    for (cond in 1:2){
    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,cond,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- cond
    allP[counter] <- p
    }
  }
}
monbinPstats <- anovacirc2way(alldata,allgroupA,allgroupB,allP)

alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:12){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,1,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,3,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}

mondichPstats <- anovacirc2way(alldata,allgroupA,allgroupB,allP)

alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:12){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,1,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,5,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}

monbinPstatsX <- anovacirc2way(alldata,allgroupA,allgroupB,allP)

alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:12){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,1,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,6,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}

mondichPstatsX <- anovacirc2way(alldata,allgroupA,allgroupB,allP)

```

The results of the melanopsin experiment are summarised in Figure \@ref(fig:pupildataMel). The average Fourier spectrum is displayed in Figure \@ref(fig:pupildataMel)a, and also shows clear responses at both the first harmonic frequency (0.5 Hz) and the second harmonic frequency (1 Hz) of approximately equal amplitude. These results demonstrate that we can evoke measurable steady-state pupil responses at 0.5 Hz by selectively stimulating the melanopsin-containing retinal ganglion cells whilst ignoring rods and nominally silencing all three cone classes. The group average waveform for binocular presentation is shown in Figure \@ref(fig:pupildataMel)b and shows a substantial pupil constriction at stimulus onset, followed by visible oscillations at approximately the flicker frequency (0.5 Hz, see waveform at foot).

Figure \@ref(fig:pupildataMel)d shows contrast response functions for melanopsin-directed stimuli flickering at 0.5 Hz. The amplitude of the binocular condition (blue squares) is similar to that of the monocular condition (red circles) across all target contrasts (all error bars overlap, see Table \@ref(tab:TableStatsFig4d) for summary of statistical results). At the second harmonic the binocular response is substantially greater than the monocular response at higher contrasts where the response is above baseline (Figure \@ref(fig:pupildataMel)g, see Table \@ref(tab:TableStatsFig4g) for summary of statistical results).

```{r pupildataMel, fig.cap="Summary of pupillometry results for the melanopsin experiment for N=12 participants. Panel (a) shows the average Fourier spectrum. Panel (b) shows a group average waveform for binocular presentation (low pass filtered at 5 Hz), with the driving signal plotted at the foot. Panel (c) shows the ratio of binocular to monocular response. The red circles show the ratios at the first harmonic (0.5 Hz) and the blue squares show the ratios at the second harmonic (1 Hz). Panels (d,e) show contrast response functions at 0.5 Hz for different conditions. Panel (f) shows contrast response functions at 0.4 Hz for three conditions. Panels (g-i) are in the same format but for the second harmonic responses. Shaded regions and error bars indicate bootstrapped standard errors.", fig.align="center", out.width = '85%', echo=FALSE}

knitr::include_graphics(paste0(figdir,'pupildataMel.pdf'))
```

In Figure \@ref(fig:pupildataMel)e, we again plot responses to monocular target stimuli flickering at 0.5 Hz, when the other eye viewed stimuli flickering at 0.4 Hz (here too, the red monocular-only data are replotted from Figure \@ref(fig:pupildataMel)d for comparison). For the binocular cross condition (shown in purple), responses were slightly suppressed across all target contrasts (see Table \@ref(tab:TableStatsMonBinXFig4e) for summary of statistical results). For the dichoptic cross condition (shown in yellow), responses were also slightly suppressed across the contrast range (see Table \@ref(tab:TableStatsMonDichXFig4e) for summary of statistical results). This pattern is also observed at the second harmonic (Figure \@ref(fig:pupildataMel)h, see Tables \@ref(tab:TableStatsMonBinXFig4h) and \@ref(tab:TableStatsMonDichXFig4h) for summary of statistical results).

Figure \@ref(fig:pupildataMel)f shows responses at 0.4 Hz, for the same conditions, as well as for a condition in which a monocular stimulus flickered at 0.4 Hz (grey circles). These data are perhaps too noisy to interpret, though we note that the binocular cross data (purple triangles) are generally below the monocular data (grey circles), perhaps indicating suppression (see Table \@ref(tab:TableStatsMonXBinXFig4f) for summary of statistical results). The same pattern is generally also observed at the second harmonic (Figure \@ref(fig:pupildataMel)i, see Table \@ref(tab:TableStatsMonXBinXFig4i) for summary of statistical results).

Finally, we calculated the binocular to monocular ratio at the first and second harmonic frequencies. Figure \@ref(fig:pupildataMel)c shows that these ratios are around 1 at the first harmonic, suggesting that there is strong interocular suppression between the eyes, and binocular signal combination is therefore strongly non-linear.

## Experiment 3

```{r L-M individual, include=FALSE, results='hide'}

# (download and) analyse individual participant data for the L-M experiment
if (processdata > 2){

  for(participant in 1:24){
    
    # only download and process data if this has not been done already for this participant
    if (!file.exists(paste0(datadir,'P',700+participant,'summary.RData'))){   

      # if there is no directory for this participant's data
      if (!file.exists(paste0(rawdir,'P',700+participant))){
        dir.create(paste0(rawdir,'P',700+participant))
        
       d <- dir(paste0(rawdir,'P',700+participant))
       
       if (length(d)==0){
         
         # if the tar file of this participant's data doesn't exist
         if (!file.exists(paste0(rawdir,'P',700+participant,'.zip'))){
           # download it from OSF
           if (!exists('osffiles')){
           osfnode <- 'pexyk'
           osfproject <- osf_retrieve_node(osfnode)
          osffiles <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffiles$name==paste0('P',700+participant,'.zip'))
          osf_download(osffiles[fid,],rawdir,progress=TRUE)
         }
         
         # then unzip the tar file
         unzip(paste0(rawdir,'P',700+participant,'.zip'),exdir=paste0(rawdir,'P',700+participant))
         
         # and delete the tar file to save storage space
         file.remove(paste0(rawdir,'P',700+participant,'.zip'))
       }
      }
      
      d <- dir(paste0(rawdir,'P',700+participant),full.names=TRUE)

    tic()
  
    pupiltargets <- array(0,dim=c(3,2,60))
    pupilmasks <- pupiltargets
    pupiltargets2 <- pupiltargets
    pupilmasks2 <- pupiltargets
    pupilwaveforms <- array(0,dim=c(3,2,60,120*14))
    pupilspectra <- array(0,dim=c(3,2,60,300))
    timeseq <- seq(1/120,10,length.out=120*10)
    timeseq2 <- seq(1/120,14,length.out=120*14)
    targetindex <- (0.5*10)+1
    maskindex <- (0.4*10)+1
    targetindex2 <- (0.5*2*10)+1
    maskindex2 <- (2*0.4*10)+1
      
      
    repcounterP <- (1:60)*0
    afiles <- dir(path=paste0(rawdir,'P',700+participant),pattern='*annotations.csv',full.names=TRUE)

    for (block in 1:length(afiles)){
        tic()
        adata <- read.csv(paste0(rawdir,'P',700+participant,'/',paste0('P',700+participant,'_S',block),'_annotations.csv'))
        
        trialtimes <- NULL
        trialtypes <- NULL
        for (t in 1:(nrow(adata)/2)){
          trialtimes[t] <- mean(adata$timestamp[(t*2 - 1):(t*2)])
          trialtypes[t] <- adata$condition_code[t*2]
        }
        
        trialtypes[which(trialtypes>15)] <- trialtypes[which(trialtypes>15)] + 5
        inclist <- NULL
        for (t in 11:15){
          i <- which(trialtypes==t)
          inclist[t-10] <- i[2]
        }
        inclist <- inclist[which(!is.na(inclist))]
        trialtypes[inclist] <- trialtypes[inclist] + 5
        
        pdata <- read.csv(paste(rawdir,'P',700+participant,'/',paste0('P',700+participant,'_S',block),'_pupil_positions.csv',sep=''))
        pdata2 <- pdata[,c(1,3,4,14)]
        pdata2 <- pdata2[which(pdata2[,3]>0.2),]
        
        
        for (trialno in 1:length(trialtypes)){
          repcounterP[trialtypes[trialno]] <- repcounterP[trialtypes[trialno]] + 1
          for (eye in 1:2){
            eyedata <- pdata2[which(pdata2[,2]==(2-eye)),]      
            a <- which(eyedata[,1]>trialtimes[trialno]+2)
            b <- which(eyedata[,1]<(trialtimes[trialno]+12))
            i <- intersect(a,b)
            trial <- eyedata[i,]
            trial <- trial[which(!is.na(trial[,4])),]
            trial[,1] <- trial[,1] - trial[1,1]
            if (nrow(trial)>3){
              resampled <- interp1(trial[,1],trial[,4],timeseq,method='linear',extrap=TRUE)
              fspec <- (fft(resampled)/length(resampled))
              pupiltargets[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[targetindex]
              pupilmasks[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[maskindex]
              pupiltargets2[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[targetindex2]
              pupilmasks2[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[maskindex2]
              pupilspectra[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno],1:300] <- fspec[1:300]
            }
            
            a <- which(eyedata[,1]>(trialtimes[trialno]-1))
            b <- which(eyedata[,1]<(trialtimes[trialno]+13))
            i <- intersect(a,b)
            trial <- eyedata[i,]
            trial[,1] <- trial[,1] - trial[1,1]
            if (nrow(trial)>3){
              trial <- trial[which(!is.na(trial[,4])),]
              resampled <- interp1(trial[,1],trial[,4],timeseq2,method='linear',extrap=TRUE)
              pupilwaveforms[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno],] <- resampled - mean(resampled[1:120])
            }
          }
        }
    }
  
    cleanmeansP <- matrix(0,nrow=6,ncol=5)
    cleanmasksP <- matrix(0,nrow=6,ncol=5)
    cleanmeansP2 <- matrix(0,nrow=6,ncol=5)
    cleanmasksP2 <- matrix(0,nrow=6,ncol=5)

    for (cond in 1:6){
        startindex <- (10*(cond-1))
        for (level in 1:5){
          temp <- c(pupiltargets[,,startindex+level],pupiltargets[,,startindex+level+5])
          cartdata <- data.frame(Re(temp),Im(temp))
          if (sum(cartdata)!=0){
            D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
            i <- which(D<SDthresh)
            cleanmeansP[cond,level] <- mean(temp[i])}
          
          temp <- c(pupiltargets2[,,startindex+level],pupiltargets2[,,startindex+level+5])
          cartdata <- data.frame(Re(temp),Im(temp))
          if (sum(cartdata)!=0){
            D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
            i <- which(D<SDthresh)
            cleanmeansP2[cond,level] <- mean(temp[i])}
          
          temp <- c(pupilmasks[,,startindex+level],pupilmasks[,,startindex+level+5])
          cartdata <- data.frame(Re(temp),Im(temp))
          if (sum(cartdata)!=0){
            D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
            i <- which(D<SDthresh)
            cleanmasksP[cond,level] <- mean(temp[i])}
          
          temp <- c(pupilmasks2[,,startindex+level],pupilmasks2[,,startindex+level+5])
          cartdata <- data.frame(Re(temp),Im(temp))
          if (sum(cartdata)!=0){
            D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
            i <- which(D<SDthresh)
            cleanmasksP2[cond,level] <- mean(temp[i])}
        }
    }
  
    meanwavesP <- apply(pupilwaveforms[,,c(15,20),],4,mean,na.rm=TRUE)
    meanspectraP <- apply(pupilspectra[,,c(15,20),],4,mean,na.rm=TRUE)
    save(file=paste(datadir,'P',700+participant,'_summaryLM.RData',sep=''),list=c('cleanmeansP','cleanmasksP','cleanmeansP2','cleanmasksP2','meanspectraP','meanwavesP'))
    
    if (cleanupraw==1){file.remove(d)} # delete raw data files to save space
  }
  
  }}
```

```{r L-M group, include=FALSE, results='hide'}

# load in individual participant data and average, save group data
if (processdata > 1){
  for (participant in 1:24){
         # if the summary file of this participant's data doesn't exist
         if (!file.exists(paste0(datadir,'P',700+participant,'summaryLM.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '9ebtd'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name==paste0('P',700+participant,'summaryLM.RData'))
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }
}
  
  d <- dir(datadir,pattern='summaryLM.RData', full.names = TRUE)
  
  tempmasksP <- array(0,dim=c(length(d),6,5))
  tempmeansP <- tempmasksP
  tempmeansP2 <- tempmasksP
  tempmasksP2 <- tempmasksP
  tempspectraP <- array(0,dim=c(length(d),300))
  tempwavesP <- array(0,dim=c(length(d),1680))
  
  for (s in 1:length(d)){
    
    load(d[s])
    
    tempmasksP[s,,] <- cleanmasksP
    tempmeansP[s,,] <- cleanmeansP
    tempmasksP2[s,,] <- cleanmasksP2
    tempmeansP2[s,,] <- cleanmeansP2
    tempspectraP[s,] <- meanspectraP
    tempwavesP[s,] <- meanwavesP
  }
  
  tempspectraP <- tempspectraP[-c(2,4,13,20,26),]
  
  cleanmeansP <- matrix(0,nrow=6,ncol=5)
  cleanmeansPCI <- array(0,c(2,6,5))
  cleanmasksP <- matrix(0,nrow=6,ncol=5)
  cleanmasksPCI <- array(0,c(2,6,5))
  cleanmeansP2 <- matrix(0,nrow=6,ncol=5)
  cleanmeansP2CI <- array(0,c(2,6,5))
  cleanmasksP2 <- matrix(0,nrow=6,ncol=5)
  cleanmasksP2CI <- array(0,c(2,6,5))
  
  for (cond in 1:6){
    for (level in 1:5){
      
      temp <- tempmeansP[,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh)
        mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
        cleanmeansP[cond,level] <- mean(temp[i])
        cleanmeansPCI[1,cond,level] <- mbs$lowerCI
        cleanmeansPCI[2,cond,level] <- mbs$upperCI
      }
      
      temp <- tempmasksP[,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh)
        mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
        cleanmasksP[cond,level] <- mean(temp[i])
        cleanmasksPCI[1,cond,level] <- mbs$lowerCI
        cleanmasksPCI[2,cond,level] <- mbs$upperCI
      }
      
      temp <- tempmeansP2[,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh)
        mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
        cleanmeansP2[cond,level] <- mean(temp[i])
        cleanmeansP2CI[1,cond,level] <- mbs$lowerCI
        cleanmeansP2CI[2,cond,level] <- mbs$upperCI
      }
      
      temp <- tempmasksP2[,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh)
        mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
        cleanmasksP2[cond,level] <- mean(temp[i])
        cleanmasksP2CI[1,cond,level] <- mbs$lowerCI
        cleanmasksP2CI[2,cond,level] <- mbs$upperCI
      }
    }
  }
  
  meanspectraP <- (1:300)*0
  meanspectraPCI <- array(0,c(2,300))
  
  for (f in 2:300){
    temp <- tempspectraP[,f]
    cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
      mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
      meanspectraP[f] <- mbs$meanamp
      meanspectraPCI[1,f] <- mbs$lowerCI
      meanspectraPCI[2,f] <- mbs$upperCI
    }
  }
  
  meanwavesP <- NULL
  meanwavesPCI <- array(0,dim=c(2,dim(tempwavesP)[2]))
  
  nsubjs <- dim(tempwavesP)[1]
  for (t in 1:dim(tempwavesP)[2]){
    temp <- tempwavesP[,t]
    i <- which(abs(temp-mean(temp))<(SDthresh*sd(temp)))
    meanwavesP[t] <- mean(temp[i])
    bspop <- NULL
    for (s in 1:nbootstraps){bspop[s] <- mean(sample(temp[i],length(i),replace=TRUE))}
    meanwavesPCI[,t] <- quantile(bspop,c(0.16,0.84),na.rm=TRUE)
  }
  
  save(file=paste0(datadir,'AveragedataLM.RData'),list=c('meanwavesP','meanwavesPCI','cleanmeansP','cleanmeansPCI','cleanmasksP','cleanmasksPCI','cleanmeansP2','cleanmeansP2CI','cleanmasksP2','cleanmasksP2CI','meanspectraP','meanspectraPCI','tempmeansP','tempmeansP2','tempmasksP','tempmasksP2'))

  }
```

```{r L-M plot, include=FALSE, results='hide'}

# generate plot showing the group pupillometry data for the L-M experiment
if (!file.exists(paste0(datadir,'AveragedataLM.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '9ebtd'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='AveragedataLM.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }

load(file=paste0(datadir,'AveragedataLM.RData'))


if (processdata > 0){
  
allPLMratios <- abs(cleanmeansP[2,])/abs(cleanmeansP[1,])
allPLM2ratios <- abs(cleanmeansP2[2,])/abs(cleanmeansP2[1,])

# plot figure  
plotlims <- c(15,40,0,4)  
ticklocsx <- contrastsdB
ticklabelsx <-c(6,12,24,48,96) 
ticklocsy <- seq(0,4,0.5)    # locations of tick marks on y axis
ticklabelsy <- ticklocsy

postscript("SumLM.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (% of max)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Bin:Mon ratio", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(contrastsdB,allPLMratios, col=colpal[1], lwd=3, cex=0.5)
lines(contrastsdB,allPLM2ratios, col=colpal[2], lwd=3, cex=0.5)
points(contrastsdB,allPLMratios, pch = 21, col='black', bg=colpal[1], cex=1.6, lwd=3)
points(contrastsdB,allPLM2ratios, pch = 22, col='black', bg=colpal[2], cex=1.6, lwd=3)

legend(contrastsdB[4],4,c('L-M 1F','L-M 2F'), pch=21:24, pt.bg=colpal[1:2],box.lwd=2,pt.cex=1.6,pt.lwd=3)
text(17,3.8,'(c)',adj=0.5,cex=2.5)

dev.off()

plotlims <- c(15,40,0,0.02)
plotlims2 <- c(15,40,0,0.015) 
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,0.02,0.005)
ticklocsy2 <- seq(0,0.015,0.005)    # locations of tick marks on y axis
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy
ticklabelsy2 <- ticklocsy2     # set labels for y ticks

postscript("CRF1p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (% of max)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 0.5Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansP[cond,]),contrastsdB,cleanmeansPCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP[cond,]),contrastsdB,cleanmeansPCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansP[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(22,0.02,c('Monocular','Binocular','Dichoptic'),pch=21:23,pt.bg=colpal[1:3],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.019,'(d)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF2p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (% of max)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Amplitude at 0.5Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

condlist <- c(1,5,6)
pointlist <- c(21,24,25)
for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)  
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)  
  points(contrastsdB,abs(cleanmeansP[condlist[cond],]), pch = pointlist[cond], col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
legend(22,0.02,c('Monocular','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[condlist],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.019,'(e)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF3p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (% of max)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 0.4Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 4:6){
  lines(contrastsdB,abs(cleanmasksP[cond,]), col=colpal[cond], lwd=3, cex=0.5)   
  arrows(contrastsdB,abs(cleanmasksP[cond,]),contrastsdB,cleanmasksPCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmasksP[cond,]),contrastsdB,cleanmasksPCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)    
  points(contrastsdB,abs(cleanmasksP[cond,]), pch = pointlist[cond-3], col='black', bg=colpal[cond], cex=1.6, lwd=3) 
}
legend(22,0.02,c('Monocular 0.4Hz','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[4:6],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.019,'(f)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF1p2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims2[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy2, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy2, side = 2, at=ticklocsy2, line=0.2, las=1) 
title(xlab="Target contrast (% of max)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 1Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP2[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansP2[cond,]),contrastsdB,cleanmeansP2CI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP2[cond,]),contrastsdB,cleanmeansP2CI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansP2[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(22,0.015,c('Monocular','Binocular','Dichoptic'),pch=21:23,pt.bg=colpal[1:3],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.014,'(g)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF2p2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims2[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy2, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy2, side = 2, at=ticklocsy2, line=0.2, las=1)
title(xlab="Target contrast (% of max)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Amplitude at 1Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

condlist <- c(1,5,6)
pointlist <- c(21,24,25)
for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP2[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)  
  arrows(contrastsdB,abs(cleanmeansP2[condlist[cond],]),contrastsdB,cleanmeansP2CI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP2[condlist[cond],]),contrastsdB,cleanmeansP2CI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)  
  points(contrastsdB,abs(cleanmeansP2[condlist[cond],]), pch = pointlist[cond], col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
legend(22,0.015,c('Monocular','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[condlist],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.014,'(h)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF3p2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims2[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy2, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy2, side = 2, at=ticklocsy2, line=0.2, las=1)
title(xlab="Target contrast (% of max)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 0.8Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 4:6){
  lines(contrastsdB,abs(cleanmasksP2[cond,]), col=colpal[cond], lwd=3, cex=0.5)   
  arrows(contrastsdB,abs(cleanmasksP2[cond,]),contrastsdB,cleanmasksP2CI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmasksP2[cond,]),contrastsdB,cleanmasksP2CI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)    
  points(contrastsdB,abs(cleanmasksP2[cond,]), pch = pointlist[cond-3], col='black', bg=colpal[cond], cex=1.6, lwd=3) 
}
legend(22,0.015,c('Monocular 0.4Hz','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[4:6],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.014,'(i)',adj=0.5,cex=2.5)

dev.off()

postscript("SpecP.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

frequencies <- (0:299)/10

plotlims <- c(0,2,0,0.015) 
ticklocsx <- seq(0,2,0.25)    # locations of tick marks on x axis
ticklocsy <- seq(0,0.015,0.005)    # locations of tick marks on y axis
ticklabelsx <-ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

polygon(frequencies[c(3:21,21:3)],c(meanspectraPCI[1,3:21],meanspectraPCI[2,21:3]),col=colpal[2],border=NA)

lines(frequencies[3:21],abs(meanspectraP[3:21]), col=colpal[2], lwd=3, cex=0.5) 

text(0.1,0.014,'(a)',adj=0.5,cex=2.5)

dev.off()

postscript("timecourseP.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

times <- seq((1/120)-1,13,1/120)
sinewave <- sin(0.5*times * 2*pi)
sinewave[1:120] <- 0
sinewave[1560:1680] <- 0

plotlims <- c(-1,13,-0.5,0.5)
ticklocsx <- seq(-1,13,1)    # locations of tick marks on x axis
ticklocsy <- seq(-0.5,0.5,0.5)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)
title(ylab="Amplitude (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

filt <- butter(3,0.083)
filtwaveP <- signal::filter(filt, meanwavesP)
filtU <- signal::filter(filt,meanwavesPCI[1,])
filtL <- signal::filter(filt,meanwavesPCI[2,])
polygon(times[c(1:length(times),length(times):1)],c(filtL,filtU[length(filtU):1]),col=colpal[2],border=NA)
lines(times, filtwaveP, col=colpal[2], lwd=1.5)
lines(times, (sinewave/10)-0.4, col='black', lwd=3)

text(-0.7,0.4,'(b)',adj=0.5,cex=2.5)

dev.off()

PostScriptTrace('CRF1p.ps')
p1 <- readPicture('CRF1p.ps.xml')
PostScriptTrace('CRF2p.ps')
p2 <- readPicture('CRF2p.ps.xml')
PostScriptTrace('CRF3p.ps')
p3 <- readPicture('CRF3p.ps.xml')
PostScriptTrace('CRF1p2.ps')
p4 <- readPicture('CRF1p2.ps.xml')
PostScriptTrace('CRF2p2.ps')
p5 <- readPicture('CRF2p2.ps.xml')
PostScriptTrace('CRF3p2.ps')
p6 <- readPicture('CRF3p2.ps.xml')
PostScriptTrace('SpecP.ps')
p7 <- readPicture('SpecP.ps.xml')
PostScriptTrace('timecourseP.ps')
p8 <- readPicture('timecourseP.ps.xml')
PostScriptTrace('SumLM.ps')
p9 <- readPicture('SumLM.ps.xml')

for (n in 1:length(p7@paths)){
  temp <- class(p7@paths[n]$path)[1]
  if (pmatch(temp,"PictureFill",nomatch=0)){
    if (sum(col2rgb(p7@paths[n]$path@rgb))<765){p7@paths[n]$path@rgb <- addalpha(p7@paths[n]$path@rgb,alpha=0.2)}}}

for (n in 1:length(p8@paths)){
  temp <- class(p8@paths[n]$path)[1]
  if (pmatch(temp,"PictureFill",nomatch=0)){
    if (sum(col2rgb(p8@paths[n]$path@rgb))<765){p8@paths[n]$path@rgb <- addalpha(p8@paths[n]$path@rgb,alpha=0.2)}}}

pdf(paste0(figdir,"pupildataLM.pdf"), bg="transparent", height = 20, width = 15)

par(mar=c(0.1,0.1,0.1,0.1))
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))

grid.picture(p1,x=0.17,y=0.4,width=0.32,height=1)
grid.picture(p2,x=0.5,y=0.4,width=0.32,height=1)
grid.picture(p3,x=0.83,y=0.4,width=0.32,height=1)
grid.picture(p4,x=0.17,y=0.15,width=0.32,height=1)
grid.picture(p5,x=0.5,y=0.15,width=0.32,height=1)
grid.picture(p6,x=0.83,y=0.15,width=0.32,height=1)
grid.picture(p7,x=0.25,y=0.83,width=0.5,height=1)
grid.picture(p8,x=0.25,y=0.63,width=0.5,height=1)
grid.picture(p9,x=0.75,y=0.71,width=0.5,height=1)

text(0.5,0.98,'L-M',cex=4)

dev.off()

file.remove(c('CRF1p.ps','CRF2p.ps','CRF3p.ps','CRF1p2.ps','CRF2p2.ps','CRF3p2.ps','SpecP.ps','timecourseP.ps','SumLM.ps'))
file.remove(c('CRF1p.ps.xml','CRF2p.ps.xml','CRF3p.ps.xml','CRF1p2.ps.xml','CRF2p2.ps.xml','CRF3p2.ps.xml','SpecP.ps.xml','timecourseP.ps.xml','SumLM.ps.xml'))
  
  }
```

```{r L-M statistics, include=FALSE, results='hide'}

# do statistics on the L-M data
alldata <- NULL
groupID <- NULL
allP <- NULL
counter <- 0
for (cont in 1:dim(tempmeansP)[3]){
  for (p in 1:dim(tempmeansP)[1]){
    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,3,cont]
    groupID[counter] <- cont
    allP[counter] <- p
  }
}
dichA2c <- anovacirc.test(alldata,group=groupID,participant=allP)

alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:12){
  for (lev in 1:5){
    for (cond in 1:2){
    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,cond,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- cond
    allP[counter] <- p
    }
  }
}
monbinPstats <- anovacirc2way(alldata,allgroupA,allgroupB,allP)

alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:12){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,1,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,3,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}

mondichPstats <- anovacirc2way(alldata,allgroupA,allgroupB,allP)

alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:12){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,1,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,5,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}

monbinPstatsX <- anovacirc2way(alldata,allgroupA,allgroupB,allP)

alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:12){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,1,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,6,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}

mondichPstatsX <- anovacirc2way(alldata,allgroupA,allgroupB,allP)

```

The results of the L-M pathway experiment are summarised in Figure \@ref(fig:pupildataLM). The average Fourier spectrum is displayed in Figure \@ref(fig:pupildataLM)a, and shows clear responses at both the first harmonic frequency (0.5 Hz) and the second harmonic frequency (1 Hz) of approximately equal amplitude. These results demonstrate that we can evoke measurable steady-state pupil responses at 0.5 Hz by selectively stimulating the L-M postreceptoral ‘parvocellular’ pathway whilst ignoring rods and nominally silencing S-cones and melanopsin. The group average waveform for binocular presentation is shown in Figure \@ref(fig:pupildataLM)b and, as observed in the previous experiments, there is a substantial pupil constriction at stimulus onset, followed by visible oscillations at the flicker frequency (0.5 Hz, see waveform at foot) and its second harmonic (i.e. there are two peaks in the data for every one peak in the driving waveform).

```{r pupildataLM, fig.cap="Summary of pupillometry results for the L-M pathway experiment for N=12 participants. Panel (a) shows the average Fourier spectrum. Panel (b) shows a group average waveform for binocular presentation (low pass filtered at 5 Hz), with the driving signal plotted at the foot. Panel (c) shows the ratio of binocular to monocular response. The red circles show the ratios at the first harmonic (0.5 Hz) and the blue squares show the ratios at the second harmonic (1 Hz). Panels (d,e) show contrast response functions at 0.5 Hz for different conditions. Panel (f) shows contrast response functions at 0.4 Hz for three conditions. Panels (g-i) are in the same format but for the second harmonic responses. Shaded regions and error bars indicate bootstrapped standard errors.", fig.align="center", out.width = '85%', echo=FALSE}

knitr::include_graphics(paste0(figdir,'pupildataLM.pdf'))
```

Figure \@ref(fig:pupildataLM)d shows contrast response functions in response to stimuli flickering only at 0.5 Hz. The amplitude of the binocular condition (blue squares) is substantially smaller than that of the monocular condition (red circles) across the range of target contrasts, indicating a process of binocular suppression (see Table \@ref(tab:TableStatsFig5d) for summary of statistical results). At the second harmonic, the pattern is reversed, with the binocular responses being larger than the monocular responses (Figure \@ref(fig:pupildataLM)g, see Table \@ref(tab:TableStatsFig5g) for summary of statistical results).

In Figure \@ref(fig:pupildataLM)e, we plot responses to monocular target stimuli flickering at 0.5 Hz, when the other eye viewed stimuli flickering at 0.4 Hz (the red monocular-only data are replotted from Figure \@ref(fig:pupildataLM)d for comparison). For the binocular cross (purple triangles) and dichoptic cross (yellow triangles) conditions, we again observed a very strong suppression of the responses across all target contrasts (see Tables \@ref(tab:TableStatsMonBinXFig5e) and \@ref(tab:TableStatsMonDichXFig5e) for summary of statistical results). This was not observed at the second harmonic (Figure \@ref(fig:pupildataLM)h), where monocular and binocular responses appeared to be quite similar (see Tables \@ref(tab:TableStatsMonBinXFig5h) and \@ref(tab:TableStatsMonDichXFig5h) for summary of statistical results).

Figure \@ref(fig:pupildataLM)f shows responses at 0.4 Hz, for the same conditions, as well as for a condition in which a monocular stimulus flickered at 0.4 Hz (grey circles). Again, strong suppression can be observed across the contrast range (see Table \@ref(tab:TableStatsMonXBinXFig5f) for summary of statistical results). The dichoptic cross condition shows a clear modulation with target contrast, as we can see by the decrease of the response as the contrast increases (see Table \@ref(tab:TableStatsMonXDichXFig5f) for summary of statistical results). The same pattern is also observed at the second harmonic (Figure \@ref(fig:pupildataLM)i), though the suppression in the binocular cross condition is less extreme at the second harmonic (see Tables \@ref(tab:TableStatsMonXBinXFig5i) and \@ref(tab:TableStatsMonXDichXFig5i) for summary of statistical results).

Finally, we calculated the binocular to monocular ratio at the first and second harmonics. Figure \@ref(fig:pupildataLM)c shows that these ratios are generally below 1 at the first harmonic, again indicating very strong interocular suppression, and suggesting that the combination of the signals between the eyes is strongly non-linear. At the second harmonic, the ratios are generally between 1 and 2, suggesting that suppression between the eyes is weaker, but overall the combination remains non-linear.

## Experiment 4

```{r S individual, include=FALSE, results='hide'}

# (download and) analyse individual participant data for the S condition
if (processdata > 2){

  for(participant in 1:24){
    
    # only download and process data if this has not been done already for this participant
    if (!file.exists(paste0(datadir,'P',300+participant,'summary.RData'))){   

      # if there is no directory for this participant's data
      if (!file.exists(paste0(rawdir,'P',300+participant))){
        dir.create(paste0(rawdir,'P',300+participant))
        
       d <- dir(paste0(rawdir,'P',300+participant))
       
       if (length(d)==0){
         
         # if the tar file of this participant's data doesn't exist
         if (!file.exists(paste0(rawdir,'P',300+participant,'.zip'))){
           # download it from OSF
           if (!exists('osffiles')){
           osfnode <- 'k9mdq'
           osfproject <- osf_retrieve_node(osfnode)
          osffiles <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffiles$name==paste0('P',300+participant,'.zip'))
          osf_download(osffiles[fid,],rawdir,progress=TRUE)
         }
         
         # then unzip the tar file
         unzip(paste0(rawdir,'P',300+participant,'.zip'),exdir=paste0(rawdir,'P',300+participant))
         
         # and delete the tar file to save storage space
         file.remove(paste0(rawdir,'P',300+participant,'.zip'))
       }
      }
      
      d <- dir(paste0(rawdir,'P',300+participant),full.names=TRUE)

    tic()
  
    pupiltargets <- array(0,dim=c(3,2,60))
    pupilmasks <- pupiltargets
    pupiltargets2 <- pupiltargets
    pupilmasks2 <- pupiltargets
    pupilwaveforms <- array(0,dim=c(3,2,60,120*14))
    pupilspectra <- array(0,dim=c(3,2,60,300))
    timeseq <- seq(1/120,10,length.out=120*10)
    timeseq2 <- seq(1/120,14,length.out=120*14)
    targetindex <- (0.5*10)+1
    maskindex <- (0.4*10)+1
    targetindex2 <- (0.5*2*10)+1
    maskindex2 <- (2*0.4*10)+1
      
      
    repcounterP <- (1:60)*0
    afiles <- dir(path=paste0(rawdir,'P',300+participant),pattern='*annotations.csv',full.names=TRUE)

    for (block in 1:length(afiles)){
        tic()
        adata <- read.csv(paste0(rawdir,'P',300+participant,'/',paste0('P',300+participant,'_S',block),'_annotations.csv'))
        
        trialtimes <- NULL
        trialtypes <- NULL
        for (t in 1:(nrow(adata)/2)){
          trialtimes[t] <- mean(adata$timestamp[(t*2 - 1):(t*2)])
          trialtypes[t] <- adata$condition_code[t*2]
        }
        
        trialtypes[which(trialtypes>15)] <- trialtypes[which(trialtypes>15)] + 5
        inclist <- NULL
        for (t in 11:15){
          i <- which(trialtypes==t)
          inclist[t-10] <- i[2]
        }
        inclist <- inclist[which(!is.na(inclist))]
        trialtypes[inclist] <- trialtypes[inclist] + 5
        
        pdata <- read.csv(paste(rawdir,'P',300+participant,'/',paste0('P',300+participant,'_S',block),'_pupil_positions.csv',sep=''))
        pdata2 <- pdata[,c(1,3,4,14)]
        pdata2 <- pdata2[which(pdata2[,3]>0.2),]
        
        
        for (trialno in 1:length(trialtypes)){
          repcounterP[trialtypes[trialno]] <- repcounterP[trialtypes[trialno]] + 1
          for (eye in 1:2){
            eyedata <- pdata2[which(pdata2[,2]==(2-eye)),]      
            a <- which(eyedata[,1]>trialtimes[trialno]+2)
            b <- which(eyedata[,1]<(trialtimes[trialno]+12))
            i <- intersect(a,b)
            trial <- eyedata[i,]
            trial <- trial[which(!is.na(trial[,4])),]
            trial[,1] <- trial[,1] - trial[1,1]
            if (nrow(trial)>3){
              resampled <- interp1(trial[,1],trial[,4],timeseq,method='linear',extrap=TRUE)
              fspec <- (fft(resampled)/length(resampled))
              pupiltargets[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[targetindex]
              pupilmasks[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[maskindex]
              pupiltargets2[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[targetindex2]
              pupilmasks2[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[maskindex2]
              pupilspectra[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno],1:300] <- fspec[1:300]
            }
            
            a <- which(eyedata[,1]>(trialtimes[trialno]-1))
            b <- which(eyedata[,1]<(trialtimes[trialno]+13))
            i <- intersect(a,b)
            trial <- eyedata[i,]
            trial[,1] <- trial[,1] - trial[1,1]
            if (nrow(trial)>3){
              trial <- trial[which(!is.na(trial[,4])),]
              resampled <- interp1(trial[,1],trial[,4],timeseq2,method='linear',extrap=TRUE)
              pupilwaveforms[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno],] <- resampled - mean(resampled[1:120])
            }
          }
        }
    }
  
    cleanmeansP <- matrix(0,nrow=6,ncol=5)
    cleanmasksP <- matrix(0,nrow=6,ncol=5)
    cleanmeansP2 <- matrix(0,nrow=6,ncol=5)
    cleanmasksP2 <- matrix(0,nrow=6,ncol=5)

    for (cond in 1:6){
        startindex <- (10*(cond-1))
        for (level in 1:5){
          temp <- c(pupiltargets[,,startindex+level],pupiltargets[,,startindex+level+5])
          cartdata <- data.frame(Re(temp),Im(temp))
          if (sum(cartdata)!=0){
            D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
            i <- which(D<SDthresh)
            cleanmeansP[cond,level] <- mean(temp[i])}
          
          temp <- c(pupiltargets2[,,startindex+level],pupiltargets2[,,startindex+level+5])
          cartdata <- data.frame(Re(temp),Im(temp))
          if (sum(cartdata)!=0){
            D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
            i <- which(D<SDthresh)
            cleanmeansP2[cond,level] <- mean(temp[i])}
          
          temp <- c(pupilmasks[,,startindex+level],pupilmasks[,,startindex+level+5])
          cartdata <- data.frame(Re(temp),Im(temp))
          if (sum(cartdata)!=0){
            D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
            i <- which(D<SDthresh)
            cleanmasksP[cond,level] <- mean(temp[i])}
          
          temp <- c(pupilmasks2[,,startindex+level],pupilmasks2[,,startindex+level+5])
          cartdata <- data.frame(Re(temp),Im(temp))
          if (sum(cartdata)!=0){
            D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
            i <- which(D<SDthresh)
            cleanmasksP2[cond,level] <- mean(temp[i])}
        }
    }
  
    meanwavesP <- apply(pupilwaveforms[,,c(15,20),],4,mean,na.rm=TRUE)
    meanspectraP <- apply(pupilspectra[,,c(15,20),],4,mean,na.rm=TRUE)
    save(file=paste(datadir,'P',300+participant,'_summaryS.RData',sep=''),list=c('cleanmeansP','cleanmasksP','cleanmeansP2','cleanmasksP2','meanspectraP','meanwavesP'))
    
    if (cleanupraw==1){file.remove(d)} # delete raw data files to save space
  }
  
  }}
```

```{r S group, include=FALSE, results='hide'}

# load in individual participant data and average, save group data
if (processdata > 1){
  for (participant in 1:24){
         # if the summary file of this participant's data doesn't exist
         if (!file.exists(paste0(datadir,'P',300+participant,'summaryS.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '9ebtd'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name==paste0('P',300+participant,'summaryS.RData'))
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }
}
  
  d <- dir(datadir,pattern='summaryS.RData', full.names = TRUE)
  
  tempmasksP <- array(0,dim=c(length(d),6,5))
  tempmeansP <- tempmasksP
  tempmeansP2 <- tempmasksP
  tempmasksP2 <- tempmasksP
  tempspectraP <- array(0,dim=c(length(d),300))
  tempwavesP <- array(0,dim=c(length(d),1680))
  
  for (s in 1:length(d)){
    
    load(d[s])
    
    tempmasksP[s,,] <- cleanmasksP
    tempmeansP[s,,] <- cleanmeansP
    tempmasksP2[s,,] <- cleanmasksP2
    tempmeansP2[s,,] <- cleanmeansP2
    tempspectraP[s,] <- meanspectraP
    tempwavesP[s,] <- meanwavesP
  }
  
  tempspectraP <- tempspectraP[-c(2,4,13,20,26),]
  
  cleanmeansP <- matrix(0,nrow=6,ncol=5)
  cleanmeansPCI <- array(0,c(2,6,5))
  cleanmasksP <- matrix(0,nrow=6,ncol=5)
  cleanmasksPCI <- array(0,c(2,6,5))
  cleanmeansP2 <- matrix(0,nrow=6,ncol=5)
  cleanmeansP2CI <- array(0,c(2,6,5))
  cleanmasksP2 <- matrix(0,nrow=6,ncol=5)
  cleanmasksP2CI <- array(0,c(2,6,5))
  
  for (cond in 1:6){
    for (level in 1:5){
      
      temp <- tempmeansP[,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh)
        mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
        cleanmeansP[cond,level] <- mean(temp[i])
        cleanmeansPCI[1,cond,level] <- mbs$lowerCI
        cleanmeansPCI[2,cond,level] <- mbs$upperCI
      }
      
      temp <- tempmasksP[,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh)
        mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
        cleanmasksP[cond,level] <- mean(temp[i])
        cleanmasksPCI[1,cond,level] <- mbs$lowerCI
        cleanmasksPCI[2,cond,level] <- mbs$upperCI
      }
      
      temp <- tempmeansP2[,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh)
        mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
        cleanmeansP2[cond,level] <- mean(temp[i])
        cleanmeansP2CI[1,cond,level] <- mbs$lowerCI
        cleanmeansP2CI[2,cond,level] <- mbs$upperCI
      }
      
      temp <- tempmasksP2[,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh)
        mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
        cleanmasksP2[cond,level] <- mean(temp[i])
        cleanmasksP2CI[1,cond,level] <- mbs$lowerCI
        cleanmasksP2CI[2,cond,level] <- mbs$upperCI
      }
    }
  }
  
  meanspectraP <- (1:300)*0
  meanspectraPCI <- array(0,c(2,300))
  
  for (f in 2:300){
    temp <- tempspectraP[,f]
    cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
      mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
      meanspectraP[f] <- mbs$meanamp
      meanspectraPCI[1,f] <- mbs$lowerCI
      meanspectraPCI[2,f] <- mbs$upperCI
    }
  }
  
  meanwavesP <- NULL
  meanwavesPCI <- array(0,dim=c(2,dim(tempwavesP)[2]))
  
  nsubjs <- dim(tempwavesP)[1]
  for (t in 1:dim(tempwavesP)[2]){
    temp <- tempwavesP[,t]
    i <- which(abs(temp-mean(temp))<(SDthresh*sd(temp)))
    meanwavesP[t] <- mean(temp[i])
    bspop <- NULL
    for (s in 1:nbootstraps){bspop[s] <- mean(sample(temp[i],length(i),replace=TRUE))}
    meanwavesPCI[,t] <- quantile(bspop,c(0.16,0.84),na.rm=TRUE)
  }
  
  save(file=paste0(datadir,'AveragedataS.RData'),list=c('meanwavesP','meanwavesPCI','cleanmeansP','cleanmeansPCI','cleanmasksP','cleanmasksPCI','cleanmeansP2','cleanmeansP2CI','cleanmasksP2','cleanmasksP2CI','meanspectraP','meanspectraPCI','tempmeansP','tempmeansP2','tempmasksP','tempmasksP2'))

  }
```

```{r S plot, include=FALSE, results='hide'}

# generate plot showing the group pupillometry data for the S experiment
if (!file.exists(paste0(datadir,'AveragedataS.RData'))){
           # download it from OSF
           if (!exists('osffilesP')){
           osfnode <- '9ebtd'
           osfproject <- osf_retrieve_node(osfnode)
          osffilesP <- osf_ls_files(osfproject,n_max=300)}
          fid <- which(osffilesP$name=='AveragedataS.RData')
          osf_download(osffilesP[fid,],datadir,progress=TRUE)
         }

load(file=paste0(datadir,'AveragedataS.RData'))

if (processdata > 0){
  
allPSratios <- abs(cleanmeansP[2,])/abs(cleanmeansP[1,])
allPS2ratios <- abs(cleanmeansP2[2,])/abs(cleanmeansP2[1,])

# plot figure  
plotlims <- c(15,40,0,3)  
ticklocsx <- contrastsdB
ticklabelsx <-c(6,12,24,48,96) 
ticklocsy <- seq(0,3,0.5)    # locations of tick marks on y axis
ticklabelsy <- ticklocsy

postscript("SumS.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (% of max)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Bin:Mon ratio", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(contrastsdB,allPSratios, col=colpal[1], lwd=3, cex=0.5)
lines(contrastsdB,allPS2ratios, col=colpal[2], lwd=3, cex=0.5)
points(contrastsdB,allPSratios, pch = 21, col='black', bg=colpal[1], cex=1.6, lwd=3)
points(contrastsdB,allPS2ratios, pch = 22, col='black', bg=colpal[2], cex=1.6, lwd=3)

legend(contrastsdB[4],3,c('S 1F','S 2F'), pch=21:24, pt.bg=colpal[1:2],box.lwd=2,pt.cex=1.6,pt.lwd=3)
text(17,2.8,'(c)',adj=0.5,cex=2.5)

dev.off()

plotlims <- c(15,40,0,0.02)
plotlims2 <- c(15,40,0,0.015) 
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,0.02,0.005)
ticklocsy2 <- seq(0,0.015,0.005)    # locations of tick marks on y axis
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy
ticklabelsy2 <- ticklocsy2     # set labels for y ticks

postscript("CRF1p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (% of max)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 0.5Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansP[cond,]),contrastsdB,cleanmeansPCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP[cond,]),contrastsdB,cleanmeansPCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansP[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(22,0.02,c('Monocular','Binocular','Dichoptic'),pch=21:23,pt.bg=colpal[1:3],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.019,'(d)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF2p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (% of max)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Amplitude at 0.5Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

condlist <- c(1,5,6)
pointlist <- c(21,24,25)
for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)  
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)  
  points(contrastsdB,abs(cleanmeansP[condlist[cond],]), pch = pointlist[cond], col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
legend(22,0.02,c('Monocular','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[condlist],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.019,'(e)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF3p.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (% of max)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 0.4Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 4:6){
  lines(contrastsdB,abs(cleanmasksP[cond,]), col=colpal[cond], lwd=3, cex=0.5)   
  arrows(contrastsdB,abs(cleanmasksP[cond,]),contrastsdB,cleanmasksPCI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmasksP[cond,]),contrastsdB,cleanmasksPCI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)    
  points(contrastsdB,abs(cleanmasksP[cond,]), pch = pointlist[cond-3], col='black', bg=colpal[cond], cex=1.6, lwd=3) 
}
legend(22,0.02,c('Monocular 0.4Hz','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[4:6],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.019,'(f)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF1p2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (% of max)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 1Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP2[cond,]), col=colpal[cond], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansP2[cond,]),contrastsdB,cleanmeansP2CI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP2[cond,]),contrastsdB,cleanmeansP2CI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansP2[cond,]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
legend(22,0.02,c('Monocular','Binocular','Dichoptic'),pch=21:23,pt.bg=colpal[1:3],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.019,'(g)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF2p2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (% of max)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Amplitude at 1Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

condlist <- c(1,5,6)
pointlist <- c(21,24,25)
for (cond in 1:3){
  lines(contrastsdB,abs(cleanmeansP2[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)  
  arrows(contrastsdB,abs(cleanmeansP2[condlist[cond],]),contrastsdB,cleanmeansP2CI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP2[condlist[cond],]),contrastsdB,cleanmeansP2CI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)  
  points(contrastsdB,abs(cleanmeansP2[condlist[cond],]), pch = pointlist[cond], col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
legend(22,0.02,c('Monocular','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[condlist],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.019,'(h)',adj=0.5,cex=2.5)

dev.off()

postscript("CRF3p2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 5.5)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Target contrast (% of max)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 0.8Hz (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (cond in 4:6){
  lines(contrastsdB,abs(cleanmasksP2[cond,]), col=colpal[cond], lwd=3, cex=0.5)   
  arrows(contrastsdB,abs(cleanmasksP2[cond,]),contrastsdB,cleanmasksP2CI[1,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmasksP2[cond,]),contrastsdB,cleanmasksP2CI[2,cond,],lwd=3,col=colpal[cond],length=0.05,angle=90)    
  points(contrastsdB,abs(cleanmasksP2[cond,]), pch = pointlist[cond-3], col='black', bg=colpal[cond], cex=1.6, lwd=3) 
}
legend(22,0.02,c('Monocular 0.4Hz','Binocular cross','Dichoptic cross'),pch=pointlist,pt.bg=colpal[4:6],pt.lwd=3,pt.cex=1.6,box.lwd=2)
text(17,0.019,'(i)',adj=0.5,cex=2.5)

dev.off()

postscript("SpecP.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

frequencies <- (0:299)/10

plotlims <- c(0,2,0,0.015) 
ticklocsx <- seq(0,2,0.25)    # locations of tick marks on x axis
ticklocsy <- seq(0,0.015,0.005)    # locations of tick marks on y axis
ticklabelsx <-ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)  
title(ylab="Amplitude (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

polygon(frequencies[c(3:21,21:3)],c(meanspectraPCI[1,3:21],meanspectraPCI[2,21:3]),col=colpal[2],border=NA)

lines(frequencies[3:21],abs(meanspectraP[3:21]), col=colpal[2], lwd=3, cex=0.5) 

text(0.1,0.014,'(a)',adj=0.5,cex=2.5)

dev.off()

postscript("timecourseP.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5.5, width = 8)

times <- seq((1/120)-1,13,1/120)
sinewave <- sin(0.5*times * 2*pi)
sinewave[1:120] <- 0
sinewave[1560:1680] <- 0

plotlims <- c(-1,13,-0.5,0.5)
ticklocsx <- seq(-1,13,1)    # locations of tick marks on x axis
ticklocsy <- seq(-0.5,0.5,0.5)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)
title(ylab="Amplitude (mm)", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

filt <- butter(3,0.083)
filtwaveP <- signal::filter(filt, meanwavesP)
filtU <- signal::filter(filt,meanwavesPCI[1,])
filtL <- signal::filter(filt,meanwavesPCI[2,])
polygon(times[c(1:length(times),length(times):1)],c(filtL,filtU[length(filtU):1]),col=colpal[2],border=NA)
lines(times, filtwaveP, col=colpal[2], lwd=1.5)
lines(times, (sinewave/10)-0.4, col='black', lwd=3)

text(-0.7,0.4,'(b)',adj=0.5,cex=2.5)

dev.off()

PostScriptTrace('CRF1p.ps')
p1 <- readPicture('CRF1p.ps.xml')
PostScriptTrace('CRF2p.ps')
p2 <- readPicture('CRF2p.ps.xml')
PostScriptTrace('CRF3p.ps')
p3 <- readPicture('CRF3p.ps.xml')
PostScriptTrace('CRF1p2.ps')
p4 <- readPicture('CRF1p2.ps.xml')
PostScriptTrace('CRF2p2.ps')
p5 <- readPicture('CRF2p2.ps.xml')
PostScriptTrace('CRF3p2.ps')
p6 <- readPicture('CRF3p2.ps.xml')
PostScriptTrace('SpecP.ps')
p7 <- readPicture('SpecP.ps.xml')
PostScriptTrace('timecourseP.ps')
p8 <- readPicture('timecourseP.ps.xml')
PostScriptTrace('SumS.ps')
p9 <- readPicture('SumS.ps.xml')

for (n in 1:length(p7@paths)){
  temp <- class(p7@paths[n]$path)[1]
  if (pmatch(temp,"PictureFill",nomatch=0)){
    if (sum(col2rgb(p7@paths[n]$path@rgb))<765){p7@paths[n]$path@rgb <- addalpha(p7@paths[n]$path@rgb,alpha=0.2)}}}

for (n in 1:length(p8@paths)){
  temp <- class(p8@paths[n]$path)[1]
  if (pmatch(temp,"PictureFill",nomatch=0)){
    if (sum(col2rgb(p8@paths[n]$path@rgb))<765){p8@paths[n]$path@rgb <- addalpha(p8@paths[n]$path@rgb,alpha=0.2)}}}

pdf(paste0(figdir,"pupildataS.pdf"), bg="transparent", height = 20, width = 15)

par(mar=c(0.1,0.1,0.1,0.1))
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))

grid.picture(p1,x=0.17,y=0.4,width=0.32,height=1)
grid.picture(p2,x=0.5,y=0.4,width=0.32,height=1)
grid.picture(p3,x=0.83,y=0.4,width=0.32,height=1)
grid.picture(p4,x=0.17,y=0.15,width=0.32,height=1)
grid.picture(p5,x=0.5,y=0.15,width=0.32,height=1)
grid.picture(p6,x=0.83,y=0.15,width=0.32,height=1)
grid.picture(p7,x=0.25,y=0.83,width=0.5,height=1)
grid.picture(p8,x=0.25,y=0.63,width=0.5,height=1)
grid.picture(p9,x=0.75,y=0.71,width=0.5,height=1)

text(0.5,0.98,'S-(L+M)',cex=4)

dev.off()

file.remove(c('CRF1p.ps','CRF2p.ps','CRF3p.ps','CRF1p2.ps','CRF2p2.ps','CRF3p2.ps','SpecP.ps','timecourseP.ps','SumS.ps'))
file.remove(c('CRF1p.ps.xml','CRF2p.ps.xml','CRF3p.ps.xml','CRF1p2.ps.xml','CRF2p2.ps.xml','CRF3p2.ps.xml','SpecP.ps.xml','timecourseP.ps.xml','SumS.ps.xml'))
  
  }
```

```{r S statistics, include=FALSE, results='hide'}

# do statistics on the S data
alldata <- NULL
groupID <- NULL
allP <- NULL
counter <- 0
for (cont in 1:dim(tempmeansP)[3]){
  for (p in 1:dim(tempmeansP)[1]){
    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,3,cont]
    groupID[counter] <- cont
    allP[counter] <- p
  }
}
dichA2c <- anovacirc.test(alldata,group=groupID,participant=allP)

alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:12){
  for (lev in 1:5){
    for (cond in 1:2){
    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,cond,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- cond
    allP[counter] <- p
    }
  }
}
monbinPstats <- anovacirc2way(alldata,allgroupA,allgroupB,allP)

alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:12){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,1,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,3,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}

mondichPstats <- anovacirc2way(alldata,allgroupA,allgroupB,allP)

alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:12){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,1,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,5,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}

monbinPstatsX <- anovacirc2way(alldata,allgroupA,allgroupB,allP)

alldata <- NULL
allgroupA <- NULL
allgroupB <- NULL
allP <- NULL
counter <- 0
for (p in 1:12){
  for (lev in 1:5){
    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,1,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 1
    allP[counter] <- p

    counter <- counter + 1
    alldata[counter] <- tempmeansP[p,6,lev]
    allgroupA[counter] <- lev
    allgroupB[counter] <- 2
    allP[counter] <- p
  }
}

mondichPstatsX <- anovacirc2way(alldata,allgroupA,allgroupB,allP)

```

The results of the S-(L+M) pathway experiment are summarised in Figure \@ref(fig:pupildataS). The average Fourier spectrum is displayed in Figure \@ref(fig:pupildataS)a, and shows a clear response at both the first harmonic frequency (0.5 Hz) and a stronger response (by around 50%) at the second harmonic frequency (1 Hz). These results demonstrate that we can evoke measurable steady-state pupil responses at 0.5 Hz by selectively stimulating the S-(L+M) ‘koniocelluar’ pathway whilst ignoring rods and nominally silencing L/M cones and melanopsin. The group average waveform for binocular presentation is shown in Figure \@ref(fig:pupildataS)b. There is a substantial pupil constriction at stimulus onset, followed by very visible oscillations at the flicker frequency (0.5 Hz, see waveform at foot) and its second harmonic.

Figure \@ref(fig:pupildataS)d shows contrast response functions in response to stimuli flickering only at 0.5 Hz. For the first 3 target contrasts, response amplitudes increased monotonically with target contrast. At the higher contrasts, we observe a roll-over of the pupil response shown by the drop in the signals. This suggests that the S cones saturate at higher contrasts, and so are not able to drive larger pupil modulations. The amplitude of the binocular condition (blue squares) is consistently greater than that of the monocular condition (red circles) across the range of target contrasts (see Table \@ref(tab:TableStatsFig6d) for summary of statistical results). At the second harmonic, we observe quite different results, with the binocular and monocular conditions having the same amplitudes across the contrast range (Figure \@ref(fig:pupildataS)g), and no evidence of saturation (see Table \@ref(tab:TableStatsFig6g) for summary of statistical results).

In Figure \@ref(fig:pupildataS)e, we plot responses to monocular target stimuli flickering at 0.5 Hz, when the other eye viewed stimuli flickering at 0.4 Hz (the red monocular data are replotted from Figure \@ref(fig:pupildataS)d for comparison). There was very little evidence of suppression in the binocular cross (purple triangles) or dichoptic cross (yellow triangles) conditions at the first harmonic (see Tables \@ref(tab:TableStatsMonBinXFig6e) and \@ref(tab:TableStatsMonDichXFig6e) for summary of statistical results). However at the second harmonic (Figure \@ref(fig:pupildataS)h), strong suppression was apparent at the higher target contrasts (see Tables \@ref(tab:TableStatsMonBinXFig6h) and \@ref(tab:TableStatsMonDichXFig6h) for summary of statistical results).

Figure \@ref(fig:pupildataS)f shows responses at 0.4 Hz, for the same conditions, as well as for a condition in which a monocular stimulus flickered at 0.4 Hz (grey circles). At this frequency there was some evidence of suppression at the higher target contrasts (purple triangles below grey circles, see Table \@ref(tab:TableStatsMonXBinXFig6f) for summary of statistical results). At the second harmonic (Figure \@ref(fig:pupildataS)i), the binocular cross condition (purple triangles) shows a very strong suppression and the dichoptic cross condition shows a clear modulation with target contrast (yellow triangles), visible as a decrease of the response as the target contrast increases (see Tables \@ref(tab:TableStatsMonXBinXFig6i) and \@ref(tab:TableStatsMonXDichXFig6i) for summary of statistical results).

Finally, we calculated the binocular to monocular ratio at the first and second harmonics. Figure \@ref(fig:pupildataS)c shows that these ratios are generally between 1 and 2 at the first harmonic, indicating summation between the eyes with intermediate levels of interocular suppression. At the second harmonic, the ratios were around 1 for the three highest target contrasts, again consistent with strong interocular suppression.

```{r pupildataS, fig.cap="Summary of pupillometry results for the S-(L+M) pathway experiment for N=12 participants. Panel (a) shows the average Fourier spectrum. Panel (b) shows a group average waveform for binocular presentation (low pass filtered at 5 Hz), with the driving signal plotted at the foot. Panel (c) shows the ratio of binocular to monocular response. The red circles show the ratios at the first harmonic (0.5 Hz) and the blue squares show the ratios at the second harmonic (1 Hz). Panels (d,e) show contrast response functions at 0.5 Hz for different conditions. Panel (f) shows contrast response functions at 0.4 Hz for three conditions. Panels (g-i) are in the same format but for the second harmonic responses. Shaded regions and error bars indicate bootstrapped standard errors.", fig.align="center", out.width = '85%', echo=FALSE}

knitr::include_graphics(paste0(figdir,'pupildataS.pdf'))
```

## Computational modelling

```{r makestanmodels, include=FALSE, results='hide'}

# create text objects for Stan models

if (domodelling > 0){

CRFmodelstring = "
  data {
    int<lower=1> Nsubj ;
    int<lower=1> Ntotal ;
    real y[Ntotal] ;
    real x[Ntotal] ;
    real<lower=0> w[Ntotal] ;
    int<lower=1> c[Ntotal] ;
    int<lower=1> s[Ntotal] ;
  }
  parameters {
    real<lower=1> Z[Nsubj] ;
    real<lower=0> Rmax[Nsubj] ;
    real<lower=0> wt[Nsubj] ;
    real<lower=0> k[Nsubj] ;
    real<lower=0> p[Nsubj] ;    
    real<lower=0> q[Nsubj] ;    
    real<lower=0> sigma ;
    real<lower=1> Zmu ; 
    real<lower=0> Rmaxmu ; 
    real<lower=0> wtmu ; 
    real<lower=0> kmu ; 
    real<lower=0> pmu ;     
    real<lower=0> qmu ;     
    real<lower=0> Zsigma ;
    real<lower=0> Rmaxsigma ;
    real<lower=0> wtsigma ;
    real<lower=0> ksigma ;
    real<lower=0> psigma ;
    real<lower=0> qsigma ;
    real<lower=0> nu ;
  }
  model {
    Zmu ~ normal( 20 , 5 ) ;
    Rmaxmu ~ normal( 0.1 , 0.05 ) ;
    wtmu ~ normal( 1 , 0.5 ) ;
    kmu ~ normal( 0.1 , 0.05 ) ;
    pmu ~ normal( 2 , 0.1 ) ;
    qmu ~ normal( 1 , 0.5 ) ;
    sigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    Zsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    Rmaxsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    wtsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    ksigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    psigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    qsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    nu ~ exponential(1/30.0) ;
    Z ~ normal( Zmu , Zsigma ) ; // vectorized
    Rmax ~ normal( Rmaxmu , Rmaxsigma ) ; // vectorized
    wt ~ normal( wtmu , wtsigma ) ; // vectorized
    k ~ normal( kmu , ksigma ) ; // vectorized
    p ~ normal( pmu, psigma ) ;
    q ~ normal( qmu, qsigma ) ;
    for ( i in 1:Ntotal ) {
    
    if (c[i]==1)  // monocular condition
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*(pow(x[i],p[s[i]]))/(Z[s[i]] + (pow(x[i],q[s[i]])))) ,
                w[i]*sigma ) ;
                
     else if (c[i]==2)  // binocular condition 
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*((pow(x[i],p[s[i]]))/(Z[s[i]] + (pow(x[i],q[s[i]])) + wt[s[i]]*(pow(x[i],q[s[i]]))) + (pow(x[i],p[s[i]]))/(Z[s[i]] + (pow(x[i],q[s[i]])) + wt[s[i]]*(pow(x[i],q[s[i]]))))),
                w[i]*sigma ) ;   
                
     else if (c[i]==3)  // dichoptic condition
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*((pow(x[i],p[s[i]]))/(Z[s[i]] + (pow(x[i],q[s[i]])) + wt[s[i]]*(pow(48,q[s[i]]))) + (pow(48,p[s[i]]))/(Z[s[i]] + (pow(48,q[s[i]])) + wt[s[i]]*(pow(x[i],q[s[i]]))))),
                w[i]*sigma ) ;  
                
                
     else if (c[i]==4)  // binocular cross condition 
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*(pow(x[i],p[s[i]]))/(Z[s[i]] + (pow(x[i],q[s[i]])) + wt[s[i]]*(pow(x[i],q[s[i]])))) ,
                w[i]*sigma ) ;                  
                
                
     else if (c[i]==5)  // dichoptic cross condition
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*(pow(x[i],p[s[i]]))/(Z[s[i]] + (pow(x[i],q[s[i]])) + wt[s[i]]*(pow(48,q[s[i]])))) ,
                w[i]*sigma ) ;       
    }
  }

  " # close quote for CRFmodelstring

# Translate Stan models to C++ and compile to DSO:
CRFmodel <- stan_model(model_code=CRFmodelstring)  
}


```

```{r runstanmodelLum, include=FALSE, results='hide'}

# do computational modelling for luminance experiment

if (domodelling > 0){

# Luminance experiment
d <- paste0('P',601:612,'_summaryLum.RData')

allmasksP <- array(0,dim=c(length(d),6,5))
allmeansP <- allmasksP
allmasksP2 <- array(0,dim=c(length(d),6,5))
allmeansP2 <- allmasksP

  for (s in 1:length(d)){
    
    load(paste0(datadir,d[s]))
    
  allmasksP[s,,] <- cleanmasksP/cleanmasksP[2,5]
  allmeansP[s,,] <- cleanmeansP/cleanmeansP[2,5]
  allmasksP2[s,,] <- cleanmasksP2/cleanmasksP2[2,5]
  allmeansP2[s,,] <- cleanmeansP2/cleanmeansP2[2,5]

  }

  # 1st harmonic
  condlist <- c(1,2,3,5,6)
  contlist <- c(6,12,24,48,96)
  y <- NULL
  x <- NULL
  c <- NULL
  s <- NULL
  w <- NULL
  i <- 0
  for (subj in 1:dim(allmeansP)[1]){
    for (cond in 1:length(condlist)){
      for (cont in 1:length(contlist)){
        dp <- abs(allmeansP[subj,condlist[cond],cont])
        if (is.na(dp)==0){
          if (is.infinite(dp)==0){
          i <- i + 1
          x[i] <- contlist[cont]
          y[i] <- dp
          c[i] <- cond
          s[i] <- subj
          w[i] <- 1
          }
        }
      }
    }
  }
  
pupildatalist = list(x = x, y = y, s = s, w = w, c = c, Nsubj = max(s), Ntotal = length(y))

# Get MC sample of posterior:
pupilsamplesLum <- sampling(object=CRFmodel, 
                    data = pupildatalist, 
                    chains = nChains,
                    iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                    warmup = burnInSteps, 
                    thin = thinSteps,
                    cores = getOption("mc.cores", 1L))

  # 2nd harmonic
  condlist <- c(1,2,3,5,6)
  contlist <- c(6,12,24,48,96)
  y <- NULL
  x <- NULL
  c <- NULL
  s <- NULL
  w <- NULL
  i <- 0
  for (subj in 1:dim(allmeansP2)[1]){
    for (cond in 1:length(condlist)){
      for (cont in 1:length(contlist)){
        dp <- abs(allmeansP2[subj,condlist[cond],cont])
        if (is.na(dp)==0){
          if (is.infinite(dp)==0){
          i <- i + 1
          x[i] <- contlist[cont]
          y[i] <- dp
          c[i] <- cond
          s[i] <- subj
          w[i] <- 1
          }
        }
      }
    }
  }
  
pupildatalist = list(x = x, y = y, s = s, w = w, c = c, Nsubj = max(s), Ntotal = length(y))

# Get MC sample of posterior:
pupilsamplesLum2 <- sampling(object=CRFmodel, 
                    data = pupildatalist, 
                    chains = nChains,
                    iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                    warmup = burnInSteps, 
                    thin = thinSteps,
                    cores = getOption("mc.cores", 1L))

save(file=paste0(datadir,'modeloutputLum.RData'),list=c('pupilsamplesLum','pupilsamplesLum2'))

}

```

```{r runstanmodelMel, include=FALSE, results='hide'}

# do computational modelling for melanopsin experiment

if (domodelling > 0){

# Melanopsin experiment
d <- paste0('P',501:512,'_summaryMel.RData')

allmasksP <- array(0,dim=c(length(d),6,5))
allmeansP <- allmasksP
allmasksP2 <- array(0,dim=c(length(d),6,5))
allmeansP2 <- allmasksP

  for (s in 1:length(d)){
    
    load(paste0(datadir,d[s]))
    
  allmasksP[s,,] <- cleanmasksP/cleanmasksP[2,5]
  allmeansP[s,,] <- cleanmeansP/cleanmeansP[2,5]
  allmasksP2[s,,] <- cleanmasksP2/cleanmasksP2[2,5]
  allmeansP2[s,,] <- cleanmeansP2/cleanmeansP2[2,5]

  }

  # 1st harmonic
  condlist <- c(1,2,3,5,6)
  contlist <- c(6,12,24,48,96)
  y <- NULL
  x <- NULL
  c <- NULL
  s <- NULL
  w <- NULL
  i <- 0
  for (subj in 1:dim(allmeansP)[1]){
    for (cond in 1:length(condlist)){
      for (cont in 1:length(contlist)){
        dp <- abs(allmeansP[subj,condlist[cond],cont])
        if (is.na(dp)==0){
          if (is.infinite(dp)==0){
          i <- i + 1
          x[i] <- contlist[cont]
          y[i] <- dp
          c[i] <- cond
          s[i] <- subj
          w[i] <- 1
          }
        }
      }
    }
  }
  
pupildatalist = list(x = x, y = y, s = s, w = w, c = c, Nsubj = max(s), Ntotal = length(y))

# Get MC sample of posterior:
pupilsamplesMel <- sampling(object=CRFmodel, 
                    data = pupildatalist, 
                    chains = nChains,
                    iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                    warmup = burnInSteps, 
                    thin = thinSteps,
                    cores = getOption("mc.cores", 1L))

  # 2nd harmonic
  condlist <- c(1,2,3,5,6)
  contlist <- c(6,12,24,48,96)
  y <- NULL
  x <- NULL
  c <- NULL
  s <- NULL
  w <- NULL
  i <- 0
  for (subj in 1:dim(allmeansP2)[1]){
    for (cond in 1:length(condlist)){
      for (cont in 1:length(contlist)){
        dp <- abs(allmeansP2[subj,condlist[cond],cont])
        if (is.na(dp)==0){
          if (is.infinite(dp)==0){
          i <- i + 1
          x[i] <- contlist[cont]
          y[i] <- dp
          c[i] <- cond
          s[i] <- subj
          w[i] <- 1
          }
        }
      }
    }
  }
  
pupildatalist = list(x = x, y = y, s = s, w = w, c = c, Nsubj = max(s), Ntotal = length(y))

# Get MC sample of posterior:
pupilsamplesMel2 <- sampling(object=CRFmodel, 
                    data = pupildatalist, 
                    chains = nChains,
                    iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                    warmup = burnInSteps, 
                    thin = thinSteps,
                    cores = getOption("mc.cores", 1L))

save(file=paste0(datadir,'modeloutputMel.RData'),list=c('pupilsamplesMel','pupilsamplesMel2'))
}

```

```{r runstanmodelLM, include=FALSE, results='hide'}

# do computational modelling for LM experiment

if (domodelling > 0){

# L-M experiment
d <- paste0('P',701:712,'_summaryLM.RData')

allmasksP <- array(0,dim=c(length(d),6,5))
allmeansP <- allmasksP
allmasksP2 <- array(0,dim=c(length(d),6,5))
allmeansP2 <- allmasksP

  for (s in 1:length(d)){
    
    load(paste0(datadir,d[s]))
    
  allmasksP[s,,] <- cleanmasksP/cleanmasksP[2,5]
  allmeansP[s,,] <- cleanmeansP/cleanmeansP[2,5]
  allmasksP2[s,,] <- cleanmasksP2/cleanmasksP2[2,5]
  allmeansP2[s,,] <- cleanmeansP2/cleanmeansP2[2,5]

  }

  # 1st harmonic
  condlist <- c(1,2,3,5,6)
  contlist <- c(6,12,24,48,96)
  y <- NULL
  x <- NULL
  c <- NULL
  s <- NULL
  w <- NULL
  i <- 0
  for (subj in 1:dim(allmeansP)[1]){
    for (cond in 1:length(condlist)){
      for (cont in 1:length(contlist)){
        dp <- abs(allmeansP[subj,condlist[cond],cont])
        if (is.na(dp)==0){
          if (is.infinite(dp)==0){
          i <- i + 1
          x[i] <- contlist[cont]
          y[i] <- dp
          c[i] <- cond
          s[i] <- subj
          w[i] <- 1
          }
        }
      }
    }
  }
  
pupildatalist = list(x = x, y = y, s = s, w = w, c = c, Nsubj = max(s), Ntotal = length(y))

# Get MC sample of posterior:
pupilsamplesLM <- sampling(object=CRFmodel, 
                    data = pupildatalist, 
                    chains = nChains,
                    iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                    warmup = burnInSteps, 
                    thin = thinSteps,
                    cores = getOption("mc.cores", 1L))

  # 2nd harmonic
  condlist <- c(1,2,3,5,6)
  contlist <- c(6,12,24,48,96)
  y <- NULL
  x <- NULL
  c <- NULL
  s <- NULL
  w <- NULL
  i <- 0
  for (subj in 1:dim(allmeansP2)[1]){
    for (cond in 1:length(condlist)){
      for (cont in 1:length(contlist)){
        dp <- abs(allmeansP2[subj,condlist[cond],cont])
        if (is.na(dp)==0){
          if (is.infinite(dp)==0){
          i <- i + 1
          x[i] <- contlist[cont]
          y[i] <- dp
          c[i] <- cond
          s[i] <- subj
          w[i] <- 1
          }
        }
      }
    }
  }
  
pupildatalist = list(x = x, y = y, s = s, w = w, c = c, Nsubj = max(s), Ntotal = length(y))

# Get MC sample of posterior:
pupilsamplesLM2 <- sampling(object=CRFmodel, 
                    data = pupildatalist, 
                    chains = nChains,
                    iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                    warmup = burnInSteps, 
                    thin = thinSteps,
                    cores = getOption("mc.cores", 1L))

save(file=paste0(datadir,'modeloutputLM.RData'),list=c('pupilsamplesLM','pupilsamplesLM2'))

}

```

```{r runstanmodelS, include=FALSE, results='hide'}

# do computational modelling for S-cone experiment

if (domodelling > 0){

# S experiment
d <- paste0('P',301:312,'_summaryS.RData')

allmasksP <- array(0,dim=c(length(d),6,5))
allmeansP <- allmasksP
allmasksP2 <- array(0,dim=c(length(d),6,5))
allmeansP2 <- allmasksP

  for (s in 1:length(d)){
    
    load(paste0(datadir,d[s]))
    
  allmasksP[s,,] <- cleanmasksP/cleanmasksP[2,5]
  allmeansP[s,,] <- cleanmeansP/cleanmeansP[2,5]
  allmasksP2[s,,] <- cleanmasksP2/cleanmasksP2[2,5]
  allmeansP2[s,,] <- cleanmeansP2/cleanmeansP2[2,5]

  }

  # 1st harmonic
  condlist <- c(1,2,3,5,6)
  contlist <- c(6,12,24,48,96)
  y <- NULL
  x <- NULL
  c <- NULL
  s <- NULL
  w <- NULL
  i <- 0
  for (subj in 1:dim(allmeansP)[1]){
    for (cond in 1:length(condlist)){
      for (cont in 1:length(contlist)){
        dp <- abs(allmeansP[subj,condlist[cond],cont])
        if (is.na(dp)==0){
          if (is.infinite(dp)==0){
          i <- i + 1
          x[i] <- contlist[cont]
          y[i] <- dp
          c[i] <- cond
          s[i] <- subj
          w[i] <- 1
          }
        }
      }
    }
  }
  
pupildatalist = list(x = x, y = y, s = s, w = w, c = c, Nsubj = max(s), Ntotal = length(y))

# Get MC sample of posterior:
pupilsamplesS <- sampling(object=CRFmodel, 
                    data = pupildatalist, 
                    chains = nChains,
                    iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                    warmup = burnInSteps, 
                    thin = thinSteps,
                    cores = getOption("mc.cores", 1L))

  # 2nd harmonic
  condlist <- c(1,2,3,5,6)
  contlist <- c(6,12,24,48,96)
  y <- NULL
  x <- NULL
  c <- NULL
  s <- NULL
  w <- NULL
  i <- 0
  for (subj in 1:dim(allmeansP2)[1]){
    for (cond in 1:length(condlist)){
      for (cont in 1:length(contlist)){
        dp <- abs(allmeansP2[subj,condlist[cond],cont])
        if (is.na(dp)==0){
          if (is.infinite(dp)==0){
          i <- i + 1
          x[i] <- contlist[cont]
          y[i] <- dp
          c[i] <- cond
          s[i] <- subj
          w[i] <- 1
          }
        }
      }
    }
  }
  
pupildatalist = list(x = x, y = y, s = s, w = w, c = c, Nsubj = max(s), Ntotal = length(y))

# Get MC sample of posterior:
pupilsamplesS2 <- sampling(object=CRFmodel, 
                    data = pupildatalist, 
                    chains = nChains,
                    iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                    warmup = burnInSteps, 
                    thin = thinSteps,
                    cores = getOption("mc.cores", 1L))


save(file=paste0(datadir,'modeloutputS.RData'),list=c('pupilsamplesS','pupilsamplesS2'))

}

```

```{r makemodelfigurechap4, include=FALSE, results='hide'}

# create figure containing modelling results

  load(paste0(datadir,'modeloutputLum.RData'))
  load(paste0(datadir,'modeloutputMel.RData'))
  load(paste0(datadir,'modeloutputLM.RData'))
  load(paste0(datadir,'modeloutputS.RData'))
  
  nchains <- dim(pupilsamplesLum)[2]
  pupilweightpopLum <- NULL
  pupilZpopLum <- NULL
  pupilKpopLum <- NULL
  pupilPpopLum <- NULL
  pupilQpopLum <- NULL
  pupilRpopLum <- NULL
  
  for (n in 1:nchains){
    pupilweightpopLum <- c(pupilweightpopLum,pupilsamplesLum@sim$samples[[n]]$wtmu)
    pupilZpopLum <- c(pupilZpopLum,pupilsamplesLum@sim$samples[[n]]$Zmu)
    pupilKpopLum <- c(pupilKpopLum,pupilsamplesLum@sim$samples[[n]]$kmu)
    pupilPpopLum <- c(pupilPpopLum,pupilsamplesLum@sim$samples[[n]]$pmu)
    pupilQpopLum <- c(pupilQpopLum,pupilsamplesLum@sim$samples[[n]]$qmu)
    pupilRpopLum <- c(pupilRpopLum,pupilsamplesLum@sim$samples[[n]]$Rmaxmu)
  }
  
  pupilWLum <- median(pupilweightpopLum)
  pupilZLum <- median(pupilZpopLum)
  pupilKLum <- median(pupilKpopLum)/sqrt(12)
  pupilPLum <- median(pupilPpopLum)
  pupilQLum <- median(pupilQpopLum)
  pupilRmaxLum <- median(pupilRpopLum)
  
  nchains <- dim(pupilsamplesMel)[2]
  pupilweightpopMel <- NULL
  pupilZpopMel <- NULL
  pupilKpopMel <- NULL
  pupilPpopMel <- NULL
  pupilQpopMel <- NULL
  pupilRpopMel <- NULL
  
  for (n in 1:nchains){
    pupilweightpopMel <- c(pupilweightpopMel,pupilsamplesMel@sim$samples[[n]]$wtmu)
    pupilZpopMel <- c(pupilZpopMel,pupilsamplesMel@sim$samples[[n]]$Zmu)
    pupilKpopMel <- c(pupilKpopMel,pupilsamplesMel@sim$samples[[n]]$kmu)
    pupilPpopMel <- c(pupilPpopMel,pupilsamplesMel@sim$samples[[n]]$pmu)
    pupilQpopMel <- c(pupilQpopMel,pupilsamplesMel@sim$samples[[n]]$qmu)
    pupilRpopMel <- c(pupilRpopMel,pupilsamplesMel@sim$samples[[n]]$Rmaxmu)
  }
  
  pupilWMel <- median(pupilweightpopMel)
  pupilZMel <- median(pupilZpopMel)
  pupilKMel <- median(pupilKpopMel)/sqrt(12)
  pupilPMel <- median(pupilPpopMel)
  pupilQMel <- median(pupilQpopMel)
  pupilRmaxMel <- median(pupilRpopMel)
  
  nchains <- dim(pupilsamplesLM)[2]
  pupilweightpopLM <- NULL
  pupilZpopLM <- NULL
  pupilKpopLM <- NULL
  pupilPpopLM <- NULL
  pupilQpopLM <- NULL
  pupilRpopLM <- NULL
  
  for (n in 1:nchains){
    pupilweightpopLM <- c(pupilweightpopLM,pupilsamplesLM@sim$samples[[n]]$wtmu)
    pupilZpopLM <- c(pupilZpopLM,pupilsamplesLM@sim$samples[[n]]$Zmu)
    pupilKpopLM <- c(pupilKpopLM,pupilsamplesLM@sim$samples[[n]]$kmu)
    pupilPpopLM <- c(pupilPpopLM,pupilsamplesLM@sim$samples[[n]]$pmu)
    pupilQpopLM <- c(pupilQpopLM,pupilsamplesLM@sim$samples[[n]]$qmu)
    pupilRpopLM <- c(pupilRpopLM,pupilsamplesLM@sim$samples[[n]]$Rmaxmu)
  }
  
  pupilWLM <- median(pupilweightpopLM)
  pupilZLM <- median(pupilZpopLM)
  pupilKLM <- median(pupilKpopLM)/sqrt(12)
  pupilPLM <- median(pupilPpopLM)
  pupilQLM <- median(pupilQpopLM)
  pupilRmaxLM <- median(pupilRpopLM)
  
  nchains <- dim(pupilsamplesS)[2]
  pupilweightpopS <- NULL
  pupilZpopS <- NULL
  pupilKpopS <- NULL
  pupilPpopS <- NULL
  pupilQpopS <- NULL
  pupilRpopS <- NULL
  
  for (n in 1:nchains){
    pupilweightpopS <- c(pupilweightpopS,pupilsamplesS@sim$samples[[n]]$wtmu)
    pupilZpopS <- c(pupilZpopS,pupilsamplesS@sim$samples[[n]]$Zmu)
    pupilKpopS <- c(pupilKpopS,pupilsamplesS@sim$samples[[n]]$kmu)
    pupilPpopS <- c(pupilPpopS,pupilsamplesS@sim$samples[[n]]$pmu)
    pupilQpopS <- c(pupilQpopS,pupilsamplesS@sim$samples[[n]]$qmu)
    pupilRpopS <- c(pupilRpopS,pupilsamplesS@sim$samples[[n]]$Rmaxmu)
  }
  
  pupilWS <- median(pupilweightpopS)
  pupilZS <- median(pupilZpopS)
  pupilKS <- median(pupilKpopS)/sqrt(12)
  pupilPS <- median(pupilPpopS)
  pupilQS <- median(pupilQpopS)
  pupilRmaxS <- median(pupilRpopS)
  
  nchains <- dim(pupilsamplesLum2)[2]
  pupilweightpopLum2 <- NULL
  pupilZpopLum2 <- NULL
  pupilKpopLum2 <- NULL
  pupilPpopLum2 <- NULL
  pupilQpopLum2 <- NULL
  pupilRpopLum2 <- NULL
  
  for (n in 1:nchains){
    pupilweightpopLum2 <- c(pupilweightpopLum2,pupilsamplesLum2@sim$samples[[n]]$wtmu)
    pupilZpopLum2 <- c(pupilZpopLum2,pupilsamplesLum2@sim$samples[[n]]$Zmu)
    pupilKpopLum2 <- c(pupilKpopLum2,pupilsamplesLum2@sim$samples[[n]]$kmu)
    pupilPpopLum2 <- c(pupilPpopLum2,pupilsamplesLum2@sim$samples[[n]]$pmu)
    pupilQpopLum2 <- c(pupilQpopLum2,pupilsamplesLum2@sim$samples[[n]]$qmu)
    pupilRpopLum2 <- c(pupilRpopLum2,pupilsamplesLum2@sim$samples[[n]]$Rmaxmu)
  }
  
  pupilWLum2 <- median(pupilweightpopLum2)
  pupilZLum2 <- median(pupilZpopLum2)
  pupilKLum2 <- median(pupilKpopLum2)/sqrt(12)
  pupilPLum2 <- median(pupilPpopLum2)
  pupilQLum2 <- median(pupilQpopLum2)
  pupilRmaxLum2 <- median(pupilRpopLum2)
  
  nchains <- dim(pupilsamplesMel2)[2]
  pupilweightpopMel2 <- NULL
  pupilZpopMel2 <- NULL
  pupilKpopMel2 <- NULL
  pupilPpopMel2 <- NULL
  pupilQpopMel2 <- NULL
  pupilRpopMel2 <- NULL
  
  for (n in 1:nchains){
    pupilweightpopMel2 <- c(pupilweightpopMel2,pupilsamplesMel2@sim$samples[[n]]$wtmu)
    pupilZpopMel2 <- c(pupilZpopMel2,pupilsamplesMel2@sim$samples[[n]]$Zmu)
    pupilKpopMel2 <- c(pupilKpopMel2,pupilsamplesMel2@sim$samples[[n]]$kmu)
    pupilPpopMel2 <- c(pupilPpopMel2,pupilsamplesMel2@sim$samples[[n]]$pmu)
    pupilQpopMel2 <- c(pupilQpopMel2,pupilsamplesMel2@sim$samples[[n]]$qmu)
    pupilRpopMel2 <- c(pupilRpopMel2,pupilsamplesMel2@sim$samples[[n]]$Rmaxmu)
  }
  
  pupilWMel2 <- median(pupilweightpopMel2)
  pupilZMel2 <- median(pupilZpopMel2)
  pupilKMel2 <- median(pupilKpopMel2)/sqrt(12)
  pupilPMel2 <- median(pupilPpopMel2)
  pupilQMel2 <- median(pupilQpopMel2)
  pupilRmaxMel2 <- median(pupilRpopMel2)
  
  nchains <- dim(pupilsamplesLM2)[2]
  pupilweightpopLM2 <- NULL
  pupilZpopLM2 <- NULL
  pupilKpopLM2 <- NULL
  pupilPpopLM2 <- NULL
  pupilQpopLM2 <- NULL
  pupilRpopLM2 <- NULL
  
  for (n in 1:nchains){
    pupilweightpopLM2 <- c(pupilweightpopLM2,pupilsamplesLM2@sim$samples[[n]]$wtmu)
    pupilZpopLM2 <- c(pupilZpopLM2,pupilsamplesLM2@sim$samples[[n]]$Zmu)
    pupilKpopLM2 <- c(pupilKpopLM2,pupilsamplesLM2@sim$samples[[n]]$kmu)
    pupilPpopLM2 <- c(pupilPpopLM2,pupilsamplesLM2@sim$samples[[n]]$pmu)
    pupilQpopLM2 <- c(pupilQpopLM2,pupilsamplesLM2@sim$samples[[n]]$qmu)
    pupilRpopLM2 <- c(pupilRpopLM2,pupilsamplesLM2@sim$samples[[n]]$Rmaxmu)
  }
  
  pupilWLM2 <- median(pupilweightpopLM2)
  pupilZLM2 <- median(pupilZpopLM2)
  pupilKLM2 <- median(pupilKpopLM2)/sqrt(12)
  pupilPLM2 <- median(pupilPpopLM2)
  pupilQLM2 <- median(pupilQpopLM2)
  pupilRmaxLM2 <- median(pupilRpopLM2)
  
  nchains <- dim(pupilsamplesS2)[2]
  pupilweightpopS2 <- NULL
  pupilZpopS2 <- NULL
  pupilKpopS2 <- NULL
  pupilPpopS2 <- NULL
  pupilQpopS2 <- NULL
  pupilRpopS2 <- NULL
  
  for (n in 1:nchains){
    pupilweightpopS2 <- c(pupilweightpopS2,pupilsamplesS2@sim$samples[[n]]$wtmu)
    pupilZpopS2 <- c(pupilZpopS2,pupilsamplesS2@sim$samples[[n]]$Zmu)
    pupilKpopS2 <- c(pupilKpopS2,pupilsamplesS2@sim$samples[[n]]$kmu)
    pupilPpopS2 <- c(pupilPpopS2,pupilsamplesS2@sim$samples[[n]]$pmu)
    pupilQpopS2 <- c(pupilQpopS2,pupilsamplesS2@sim$samples[[n]]$qmu)
    pupilRpopS2 <- c(pupilRpopS2,pupilsamplesS2@sim$samples[[n]]$Rmaxmu)
  }
  
  pupilWS2 <- median(pupilweightpopS2)
  pupilZS2 <- median(pupilZpopS2)
  pupilKS2 <- median(pupilKpopS2)/sqrt(12)
  pupilPS2 <- median(pupilPpopS2)
  pupilQS2 <- median(pupilQpopS2)
  pupilRmaxS2 <- median(pupilRpopS2)
  

getmodresps <- function(params){
contrastsfinedB <- 2:40
contrastsfine <- 10^(contrastsfinedB/20)

modresps <- matrix(0,nrow=4,ncol=length(contrastsfine))
modresps[1,] <- params[1]*(contrastsfine^params[2])/(params[3] + contrastsfine^params[6]) + params[5]

binresp <- 2*((contrastsfine^params[2])/(params[3] + contrastsfine^params[6] + params[4]*contrastsfine^params[6]))
modresps[2,] <- params[1]*binresp + params[5]

dichresp <- ((contrastsfine^params[2])/(params[3] + contrastsfine^params[6] + params[4]*48^params[6])) + ((48^params[2])/(params[3] + 48^params[6] + params[4]*contrastsfine^params[6]))
modresps[3,] <- params[1]*dichresp + params[5]

dichresp2 <- ((contrastsfine^params[2])/(params[3] + contrastsfine^params[6] + params[4]*48^params[6]))
modresps[4,] <- params[1]*dichresp2 + params[5]

return(modresps)}

if (processdata > 0){

pdf(paste(figdir,"modelfigurechap4.pdf",sep=''), bg="transparent", height = 10, width = 25)

par(mfrow=c(2,5))

load(file=paste0(datadir,'AveragedataLum.RData'))

contrastsfinedB <- 2:40

params <- c(pupilRmaxLum,pupilPLum,pupilZLum,pupilWLum,pupilKLum,pupilQLum)
modresps <- getmodresps(params)

plotlims <- c(15,40,0,1)
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,1,0.2)
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.2)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Relative amplitude at 0.5Hz", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)
title(main='Luminance 1F',cex.main=2)

for (cond in 1:3){
  lines(contrastsfinedB,modresps[cond,], col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansP[cond,])/abs(cleanmeansP[2,5]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
  lines(contrastsfinedB,modresps[4,], col=colpal[6], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansP[6,])/abs(cleanmeansP[2,5]), pch = 25, col='black', bg=colpal[6], cex=1.6, lwd=3)   # draw the data points themselves

legend(22,1,c('Monocular','Binocular','Dichoptic','Dichoptic cross'),pch=c(21:23,25),pt.bg=colpal[c(1:3,6)],pt.lwd=3,cex=1.5,pt.cex=1.6,box.lwd=2)
text(17,0.95,'(a)',adj=0.5,cex=2.5)


load(file=paste0(datadir,'AveragedataMel.RData'))

params <- c(pupilRmaxMel,pupilPMel,pupilZMel,pupilWMel,pupilKMel,pupilQMel)
modresps <- getmodresps(params)

plotlims <- c(15,40,0,1)
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,1,0.2)
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.2)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Relative amplitude at 0.5Hz", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)
title(main='Melanopsin 1F',cex.main=2)

for (cond in 1:3){
  lines(contrastsfinedB,modresps[cond,], col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansP[cond,])/abs(cleanmeansP[2,5]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
  lines(contrastsfinedB,modresps[4,], col=colpal[6], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansP[6,])/abs(cleanmeansP[2,5]), pch = 25, col='black', bg=colpal[6], cex=1.6, lwd=3)   # draw the data points themselves

text(17,0.95,'(b)',adj=0.5,cex=2.5)



load(file=paste0(datadir,'AveragedataLM.RData'))

params <- c(pupilRmaxLM,pupilPLM,pupilZLM,pupilWLM,pupilKLM,pupilQLM)
modresps <- getmodresps(params)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.2)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Relative amplitude at 0.5Hz", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)
title(main='L-M cones 1F',cex.main=2)

for (cond in 1:3){
  lines(contrastsfinedB,modresps[cond,], col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansP[cond,])/abs(cleanmeansP[2,5]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
  lines(contrastsfinedB,modresps[4,], col=colpal[6], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansP[6,])/abs(cleanmeansP[2,5]), pch = 25, col='black', bg=colpal[6], cex=1.6, lwd=3)   # draw the data points themselves

text(17,0.95,'(c)',adj=0.5,cex=2.5)


load(file=paste0(datadir,'AveragedataS.RData'))

params <- c(pupilRmaxS,pupilPS,pupilZS,pupilWS,pupilKS,pupilQS)
modresps <- getmodresps(params)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.2)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Relative amplitude at 0.5Hz", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)
title(main='S cones 1F',cex.main=2)

for (cond in 1:3){
  lines(contrastsfinedB,modresps[cond,], col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansP[cond,])/abs(cleanmeansP[2,5]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
  lines(contrastsfinedB,modresps[4,], col=colpal[6], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansP[6,])/abs(cleanmeansP[2,5]), pch = 25, col='black', bg=colpal[6], cex=1.6, lwd=3)   # draw the data points themselves

text(17,0.95,'(d)',adj=0.5,cex=2.5)


# pdf(paste(figdir,"posteriors1F.pdf",sep=''), bg="transparent", height = 5.5, width = 5.5)

plotlims <- c(-24,12,0,0.6) 
ticklocsx <- seq(-24,12,12)    
ticklocsy <- seq(0,0.6,0.1)    
ticklabelsx <- c('1/16','1/4','1','4')        
ticklabelsy <- ticklocsy    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.2)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)   

title(xlab="w", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Probability", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)
title(main='Suppression 1F',cex.main=2)

a <- density(20*log10(pupilweightpopLum),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=addalpha(colpalmod[1],0.5),border=NA) 

a <- density(20*log10(pupilweightpopMel),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=addalpha(colpalmod[2],0.5),border=NA) 

a<- density(20*log10(pupilweightpopLM),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=addalpha(colpalmod[3],0.5),border=NA) 

a <- density(20*log10(pupilweightpopS),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=addalpha(colpalmod[4],0.5),border=NA) 

prior <- dnorm(10^((-48:12)/20),1,0.5)
prior <- 0.5*prior/max(prior)
lines(-48:12,prior)

lines(20*log10(c(mean(pupilWLum),mean(pupilWLum))),c(0,0.6),lwd=3,col=colpalmod[1])
lines(20*log10(c(mean(pupilWMel),mean(pupilWMel))),c(0,0.6),lwd=3,col=colpalmod[2])
lines(20*log10(c(mean(pupilWLM),mean(pupilWLM))),c(0,0.6),lwd=3,col=colpalmod[3])
lines(20*log10(c(mean(pupilWS),mean(pupilWS))),c(0,0.6),lwd=3,col=colpalmod[4])

legend(-24,0.6,c('Prior','Lum 1F', 'Mel 1F', 'LM 1F', 'S 1F'),col=c('black',colpalmod[1:4]),lwd=c(1,3,3,3,3),lty=1, cex=1.5, box.lwd=2, bg='white')

text(10,0.58,'(e)',adj=0.5,cex=2.5)

# dev.off()
# 
# pdf(paste(figdir,"posteriors2F.pdf",sep=''), bg="transparent", height = 5.5, width = 5.5)

load(file=paste0(datadir,'AveragedataLum.RData'))

contrastsfinedB <- 2:40

params <- c(pupilRmaxLum2,pupilPLum2,pupilZLum2,pupilWLum2,pupilKLum2,pupilQLum2)
modresps <- getmodresps(params)

plotlims <- c(15,40,0,1)
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,1,0.2)
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.2)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Relative amplitude at 1Hz", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)
title(main='Luminance 2F',cex.main=2)

for (cond in 1:3){
  lines(contrastsfinedB,modresps[cond,], col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansP2[cond,])/abs(cleanmeansP2[2,5]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
  lines(contrastsfinedB,modresps[4,], col=colpal[6], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansP2[6,])/abs(cleanmeansP2[2,5]), pch = 25, col='black', bg=colpal[6], cex=1.6, lwd=3)   # draw the data points themselves

text(17,0.95,'(f)',adj=0.5,cex=2.5)


load(file=paste0(datadir,'AveragedataMel.RData'))

params <- c(pupilRmaxMel2,pupilPMel2,pupilZMel2,pupilWMel2,pupilKMel2,pupilQMel2)
modresps <- getmodresps(params)

plotlims <- c(15,40,0,1)
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,1,0.2)
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.2)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Relative amplitude at 1Hz", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)
title(main='Melanopsin 2F',cex.main=2)

for (cond in 1:3){
  lines(contrastsfinedB,modresps[cond,], col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansP2[cond,])/abs(cleanmeansP2[2,5]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
  lines(contrastsfinedB,modresps[4,], col=colpal[6], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansP2[6,])/abs(cleanmeansP2[2,5]), pch = 25, col='black', bg=colpal[6], cex=1.6, lwd=3)   # draw the data points themselves

text(17,0.95,'(g)',adj=0.5,cex=2.5)



load(file=paste0(datadir,'AveragedataLM.RData'))

params <- c(pupilRmaxLM2,pupilPLM2,pupilZLM2,pupilWLM2,pupilKLM2,pupilQLM2)
modresps <- getmodresps(params)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.2)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Relative amplitude at 1Hz", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)
title(main='L-M cones 2F',cex.main=2)

for (cond in 1:3){
  lines(contrastsfinedB,modresps[cond,], col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansP2[cond,])/abs(cleanmeansP2[2,5]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
  lines(contrastsfinedB,modresps[4,], col=colpal[6], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansP2[6,])/abs(cleanmeansP2[2,5]), pch = 25, col='black', bg=colpal[6], cex=1.6, lwd=3)   # draw the data points themselves

text(17,0.95,'(h)',adj=0.5,cex=2.5)


load(file=paste0(datadir,'AveragedataS.RData'))

params <- c(pupilRmaxS2,pupilPS2,pupilZS2,pupilWS2,pupilKS2,pupilQS2)
modresps <- getmodresps(params)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.2)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)   
title(ylab="Relative amplitude at 1Hz", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)
title(main='S cones 2F',cex.main=2)

for (cond in 1:3){
  lines(contrastsfinedB,modresps[cond,], col=colpal[cond], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansP2[cond,])/abs(cleanmeansP2[2,5]), pch = 20+cond, col='black', bg=colpal[cond], cex=1.6, lwd=3)   # draw the data points themselves
}  
  lines(contrastsfinedB,modresps[4,], col=colpal[6], lwd=3, cex=0.5)
  points(contrastsdB,abs(cleanmeansP2[6,])/abs(cleanmeansP2[2,5]), pch = 25, col='black', bg=colpal[6], cex=1.6, lwd=3)   # draw the data points themselves

text(17,0.95,'(i)',adj=0.5,cex=2.5)


plotlims <- c(-24,12,0,0.6) 
ticklocsx <- seq(-24,12,12)    
ticklocsy <- seq(0,0.6,0.1)    
ticklabelsx <- c('1/16','1/4','1','4')        
ticklabelsy <- ticklocsy    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.2)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)   
 
title(xlab="w", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Probability", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)
title(main='Suppression 2F',cex.main=2)

a <- density(20*log10(pupilweightpopLum2),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=addalpha(colpalmod[1],0.5),border=NA) 

a <- density(20*log10(pupilweightpopMel2),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=addalpha(colpalmod[2],0.5),border=NA) 

a <- density(20*log10(pupilweightpopLM2),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=addalpha(colpalmod[3],0.5),border=NA) 

a <- density(20*log10(pupilweightpopS2),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=addalpha(colpalmod[4],0.5),border=NA) 

prior <- dnorm(10^((-48:12)/20),1,0.5)
prior <- 0.5*prior/max(prior)
lines(-48:12,prior)

lines(20*log10(c(mean(pupilWLum2),mean(pupilWLum2))),c(0,0.6),lwd=3,col=colpalmod[1])
lines(20*log10(c(mean(pupilWMel2),mean(pupilWMel2))),c(0,0.6),lwd=3,col=colpalmod[2])
lines(20*log10(c(mean(pupilWLM2),mean(pupilWLM2))),c(0,0.6),lwd=3,col=colpalmod[3])
lines(20*log10(c(mean(pupilWS2),mean(pupilWS2))),c(0,0.6),lwd=3,col=colpalmod[4])

legend(-24,0.6,c('Prior','Lum 2F', 'Mel 2F', 'LM 2F', 'S 2F'),col=c('black',colpalmod[1:4]),lwd=c(1,3,3,3,3),lty=1, cex=1.5, box.lwd=2, bg='white')

text(10,0.58,'(j)',adj=0.5,cex=2.5)

dev.off()

}

```

We fitted a computational model to the data from Experiments 1, 2, 3 and 4 using a hierarchical Bayesian approach. The model behaviour is displayed in Figure \@ref(fig:modfig)a-d for the first harmonic frequency and in Figure \@ref(fig:modfig)f-i for the second harmonic frequency. The empirical data is superimposed for comparison. In general, the model captures the key characteristics of the empirical data, with group-level parameter estimates provided in Tables \@ref(tab:paramtable1F) and \@ref(tab:paramtable2F) for the first and second harmonic frequencies respectively. We were particularly interested in comparing the weight of interocular suppression across data sets. We therefore plot the posterior distributions for this parameter for all four data sets (see Figure \@ref(fig:modfig)e for the distributions at the first harmonic and Figure \@ref(fig:modfig)j for the distributions at the second harmonic).

```{r modfig, fig.cap="Summary of computational modelling. Panels (a-d) and (f-i) show empirical data from key conditions at the first and the second harmonic frequencies respectively. The data are replotted from earlier figures for the luminance experiment at the first (a) and the second (f) harmonic frequencies, the melanopsin experiment at the first (b) and the second (g) harmonic frequencies, the L-M pathway experiment at the first (c) and the second (h) harmonic frequencies, and the S-(L+M) pathway experiment at the first (d) and the second (i) harmonic frequencies. The curves show model behaviour generated using the median group-level parameter values. Panels (e) and (j) show the posterior probability distributions of the interocular suppression parameter for each of the four model fits at the first and the second harmonic frequencies respectively. In panel (e), the luminance distribution (grey) is centred about a substantially lower suppressive weight than for the other data types (note the logarithmic x-axis), while the L-M distribution (red) is centred about a higher suppressive weight than for the other data types. On the other hand, in panel (j), the L-M distribution is centred about a substantially lower suppressive weight than for the other data types, while it is the S-(L+M) distribution (blue) that is centred about a higher suppressive weight than for the other data types. The black curves show the (scaled) prior distribution for the weight parameter.", fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'modelfigurechap4.pdf'))

```

At the first harmonic, the key finding is that the luminance results (grey distribution) display a much smaller weight of interocular suppression than the other data sets. The melanopsin and S-(L+M) results (gold and blue distributions) display a similar weight of interocular suppression. The L-M results (red distribution) display the greatest weight of interocular suppression of all data sets. There is minimal overlap between the luminance distribution and the other three distributions. For the luminance, the distribution is meaningfully below a weight of 1, while it is well above a weight of 1 for the L-M results. The distributions of melanopsin and S-(L+M) are around a weight of 1. These results offer an explanation of the empirical data: the weaker suppression for the luminance experiment is consistent with the weaker suppression effects and the weaker dichoptic masking, while the stronger suppression for the L-M experiment is consistent with the stronger suppression observed at the first harmonic and the stronger dichoptic masking.

At the second harmonic, the key finding is that the S-(L+M) results display a greater weight of interocular suppression compared to the other data sets. On the other hand, the L-M results display the smallest weight of interocular suppression. The luminance and melanopsin results display weights of interocular suppression that are quite close to each other. For the L-M results, the distribution is meaningfully below a weight of 1, while it is well above a weight of 1 for the S-(L+M) results. The distributions of luminance and melanospin are around a weight of 1, with the former being slightly below and the latter being slightly above. These results offer an explanation of the empirical data: the weaker suppression for the L-M experiment is consistent with the weaker suppression effects and the weaker dichoptic masking observed at the second harmonic, while the stronger suppression for the S-(L+M) experiment is consistent with the stronger suppression observed at the second harmonic and the stronger dichoptic masking.

```{r paramtable1F, echo=FALSE}

condnames <- c('Luminance 1F', 'Melanopsin 1F', 'L-M 1F', 'S 1F')
zlist <- c(pupilZLum, pupilZMel, pupilZLM, pupilZS)
klist <- c(pupilKLum, pupilKMel, pupilKLM, pupilKS)
wlist <- c(pupilWLum, pupilWMel, pupilWLM, pupilWS)
plist <- c(pupilPLum, pupilPMel, pupilPLM, pupilPS)
qlist <- c(pupilQLum, pupilQMel, pupilQLM, pupilQS)
Rlist <- c(round(c(pupilRmaxLum, pupilRmaxMel, pupilRmaxLM, pupilRmaxS),5))
tabledata <- data.frame(condnames,round(zlist,digits=2),round(klist,digits=2),round(wlist,digits=2),round(plist,digits=2),round(qlist,digits=2),Rlist)

colnames(tabledata) <- c('Experiment','Z','k','w','p','q','Rmax')
kable(tabledata, align='lcccccc',caption = 'Summary of median parameter values at the first harmonic frequency.') 

```

```{r paramtable2F, echo=FALSE}

condnames <- c('Luminance 2F', 'Melanopsin 2F', 'L-M 2F', 'S 2F')
zlist <- c(pupilZLum2, pupilZMel2, pupilZLM2, pupilZS2)
klist <- c(pupilKLum2, pupilKMel2, pupilKLM2, pupilKS2)
wlist <- c(pupilWLum2, pupilWMel2, pupilWLM2, pupilWS2)
plist <- c(pupilPLum2, pupilPMel2, pupilPLM2, pupilPS2)
qlist <- c(pupilQLum2, pupilQMel2, pupilQLM2, pupilQS2)
Rlist <- c(round(c(pupilRmaxLum2, pupilRmaxMel2, pupilRmaxLM2, pupilRmaxS2),5))
tabledata <- data.frame(condnames,round(zlist,digits=2),round(klist,digits=2),round(wlist,digits=2),round(plist,digits=2),round(qlist,digits=2),Rlist)

colnames(tabledata) <- c('Experiment','Z','k','w','p','q','Rmax')
kable(tabledata, align='lcccccc',caption = 'Summary of median parameter values at the second harmonic frequency.') 

```

## Phase analysis

```{r makephaseplots, include=FALSE, results='hide'}


# generate plots showing the phase angles
if (processdata > 0){

load(file=paste0(datadir,'AveragedataLum.RData'))
xlum <- Re(cleanmeansP)
ylum <- Im(cleanmeansP)
xlum2 <- Re(cleanmeansP2)
ylum2 <- Im(cleanmeansP2)
load(file=paste0(datadir,'AveragedataMel.RData'))
xmel <- Re(cleanmeansP)
ymel <- Im(cleanmeansP)
xmel2 <- Re(cleanmeansP2)
ymel2 <- Im(cleanmeansP2)
load(file=paste0(datadir,'AveragedataLM.RData'))
xlm <- Re(cleanmeansP)
ylm <- Im(cleanmeansP)
xlm2 <- Re(cleanmeansP2)
ylm2 <- Im(cleanmeansP2)
load(file=paste0(datadir,'AveragedataS.RData'))
xs <- Re(cleanmeansP)
ys <- Im(cleanmeansP)
xs2 <- Re(cleanmeansP2)
ys2 <- Im(cleanmeansP2)

pdf(paste(figdir,"phaseplots.pdf",sep=''), bg="transparent", height = 10, width = 10)

par(mfrow=c(2,2),mar=c(1,1,1,1))

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-0.02,0.02), ylim=c(-0.02,0.02))   

rangles <- seq(0,360)*(pi/180)
r <- seq(0.005,0.02,0.005)
for (n in 1:length(r)){
  lines(r[n]*cos(rangles),r[n]*sin(rangles),col='gray')
}
lines(c(0,0),c(-0.02,0.02),lwd=2)
lines(c(-0.02,0.02),c(0,0),lwd=2)

text(0.015,0.001,'Amplitude',cex=1.25,adj=0.5)
text(0.021,0,'Phase',cex=1.25,adj=0.5,srt=-90)

lines(xlum[1,]/10,ylum[1,]/10,col='black',lwd=3)
points(xlum[1,]/10,ylum[1,]/10,pch=21,col='black',bg='white',cex=2,lwd=3)

lines(xmel[1,],ymel[1,],col='grey',lwd=3)
points(xmel[1,],ymel[1,],pch=21,col='grey',bg='cornflowerblue',cex=2,lwd=3)

lines(xlm[1,],ylm[1,],col='darkgreen',lwd=3)
points(xlm[1,],ylm[1,],pch=21,col='darkgreen',bg='red',cex=2,lwd=3)

lines(xs[1,],ys[1,],col='blue',lwd=3)
points(xs[1,],ys[1,],pch=21,col='blue',bg='gold',cex=2,lwd=3)

legend(-0.0175,0.0155,c('Luminance','Melanopsin','L-M','S'),lty=1,col=c('black','grey','darkgreen','blue'),lwd=3,pch=21,pt.cex=2,pt.bg=c('white','cornflowerblue','red','gold'),cex=1.4,box.lwd=3,bg='white')

text(-0.019,0.019,'(a)',cex=3)
text(0.016,0.019,'Mon 1F',cex=2.5)


plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-0.02,0.02), ylim=c(-0.02,0.02))   

rangles <- seq(0,360)*(pi/180)
r <- seq(0.005,0.02,0.005)
for (n in 1:length(r)){
  lines(r[n]*cos(rangles),r[n]*sin(rangles),col='gray')
}
lines(c(0,0),c(-0.02,0.02),lwd=2)
lines(c(-0.02,0.02),c(0,0),lwd=2)

text(0.015,0.001,'Amplitude',cex=1.25,adj=0.5)
text(0.021,0,'Phase',cex=1.25,adj=0.5,srt=-90)

lines(xlum[2,]/10,ylum[2,]/10,col='black',lwd=3)
points(xlum[2,]/10,ylum[2,]/10,pch=22,col='black',bg='white',cex=2,lwd=3)

lines(xmel[2,],ymel[2,],col='grey',lwd=3)
points(xmel[2,],ymel[2,],pch=22,col='grey',bg='cornflowerblue',cex=2,lwd=3)

lines(xlm[2,],ylm[2,],col='darkgreen',lwd=3)
points(xlm[2,],ylm[2,],pch=22,col='darkgreen',bg='red',cex=2,lwd=3)

lines(xs[2,],ys[2,],col='blue',lwd=3)
points(xs[2,],ys[2,],pch=22,col='blue',bg='gold',cex=2,lwd=3)

text(-0.019,0.019,'(b)',cex=3)
text(0.016,0.019,'Bin 1F',cex=2.5)


plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-0.02,0.02), ylim=c(-0.02,0.02))   

rangles <- seq(0,360)*(pi/180)
r <- seq(0.005,0.02,0.005)
for (n in 1:length(r)){
  lines(r[n]*cos(rangles),r[n]*sin(rangles),col='gray')
}
lines(c(0,0),c(-0.02,0.02),lwd=2)
lines(c(-0.02,0.02),c(0,0),lwd=2)

text(0.015,0.001,'Amplitude',cex=1.25,adj=0.5)
text(0.021,0,'Phase',cex=1.25,adj=0.5,srt=-90)

lines(xlum2[1,],ylum2[1,],col='black',lwd=3)
points(xlum2[1,],ylum2[1,],pch=21,col='black',bg='white',cex=2,lwd=3)

lines(xmel2[1,],ymel2[1,],col='grey',lwd=3)
points(xmel2[1,],ymel2[1,],pch=21,col='grey',bg='cornflowerblue',cex=2,lwd=3)

lines(xlm2[1,],ylm2[1,],col='darkgreen',lwd=3)
points(xlm2[1,],ylm2[1,],pch=21,col='darkgreen',bg='red',cex=2,lwd=3)

lines(xs2[1,],ys2[1,],col='blue',lwd=3)
points(xs2[1,],ys2[1,],pch=21,col='blue',bg='gold',cex=2,lwd=3)

text(-0.019,0.019,'(c)',cex=3)
text(0.016,0.019,'Mon 2F',cex=2.5)



plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-0.02,0.02), ylim=c(-0.02,0.02))   

rangles <- seq(0,360)*(pi/180)
r <- seq(0.005,0.02,0.005)
for (n in 1:length(r)){
  lines(r[n]*cos(rangles),r[n]*sin(rangles),col='gray')
}
lines(c(0,0),c(-0.02,0.02),lwd=2)
lines(c(-0.02,0.02),c(0,0),lwd=2)

text(0.015,0.001,'Amplitude',cex=1.25,adj=0.5)
text(0.021,0,'Phase',cex=1.25,adj=0.5,srt=-90)

lines(xlum2[2,],ylum2[2,],col='black',lwd=3)
points(xlum2[2,],ylum2[2,],pch=22,col='black',bg='white',cex=2,lwd=3)

lines(xmel2[2,],ymel2[2,],col='grey',lwd=3)
points(xmel2[2,],ymel2[2,],pch=22,col='grey',bg='cornflowerblue',cex=2,lwd=3)

lines(xlm2[2,],ylm2[2,],col='darkgreen',lwd=3)
points(xlm2[2,],ylm2[2,],pch=22,col='darkgreen',bg='red',cex=2,lwd=3)

lines(xs2[2,],ys2[2,],col='blue',lwd=3)
points(xs2[2,],ys2[2,],pch=22,col='blue',bg='gold',cex=2,lwd=3)

text(-0.019,0.019,'(d)',cex=3)
text(0.016,0.019,'Bin 2F',cex=2.5)

dev.off()

}
  
```

```{r phaseplots, fig.cap="Pupil phase plots at the first and second harmonic frequencies for the luminance, melanopsin, L-M pathway and the S-(L+M) pathway experiments. Panel (a) shows the pupil response during monocular stimulation at the first harmonic frequency. Panel (b) shows the pupil response during binocular stimulation at the first harmonic frequency. Panel (c) shows the pupil response during monocular stimulation at the second harmonic frequency. Panel (d) shows the pupil response during binocular stimulation at the second harmonic frequency. In panels (a) and (b), the luminance amplitudes have been scaled down by a factor of 10 to be compared with the other experiments' results.", fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'phaseplots.pdf'))

```

In a previous study, @Spitschan2014 analysed the phase of the pupil response and compared it between L+M-cone stimulation, S-cone stimulation, melanopsin stimulation and brightness stimulation. In their study, they found that, at a flicker frequency of 0.5 Hz, L+M and melanopsin responses were in phase, while brightness and S-cone responses were in anti-phase. Additionally, they found that, at the second harmonic frequency, S-cone and melanospin responses seem to be in phase with each other and in anti-phase to L+M-cone responses. We reproduced this analysis with our data and the results are summarised in Figure \@ref(fig:phaseplots). At the first harmonic frequency, the amplitudes from the luminance experiment have been scaled down by a factor of 10 to make it possible to compare them directly with the results from the other experiments.

Figure \@ref(fig:phaseplots)a shows the results to monocular responses at the first harmonic frequency. The L-M pathway stimulation produces an anti-phase pupil response relative to luminance stimulation. The S-(L+M) pathway and luminance results are desynchronised in quadrature phase. This same pattern of results is also observable in Figure \@ref(fig:phaseplots)b, which summarises the results to binocular responses at the first harmonic frequency.

Figure \@ref(fig:phaseplots)c shows the results to monocular responses at the second harmonic frequency. Here, results are noisier compare to the first harmonic results, but a pattern is still observable. In general, it seems that melanopsin and S-(L+M) stimulations produce in-phase responses to each other, but produce anti-phase responses to luminance stimulation. On the other hand, L-M pathway responses seem to be desynchronised in quadrature phase from the the results of the other experiments. The same pattern of results is also observable in Figure \@ref(fig:phaseplots)d, which summarises the results to binocular responses at the second harmonic frequency.

# Discussion

We used pupillometry and silent substitution to measure monocular and binocular responses of the pupils to flickering stimuli when stimulating specific photoreceptor pathways. In our luminance experiment, we found that peripheral stimulation of the retina can elicit a pupillary response and we were also able to record a response at the second harmonic, which was not seen when we stimulated the fovea [@Segala2023]. In all four experiments, we were able to record contrast response functions at both the first and the second harmonics. All experiments showed that binocular combination in the autonomic nervous system happens in a non-linear manner, with evidence of different magnitudes of interocular suppression depending on the photoreceptor pathway. This pattern of results was confirmed by a computational model, which allowed us to compare the weight of interocular suppression for each pathway. We found that, at the first harmonic frequency, the L-M pathway had a bigger suppression weight than the other pathways, while, at the second harmonic frequency, the S-(L+M) pathway had a bigger suppression weight. Finally, we looked at the pupil phases and observed different behaviours for the different pathways at the first and second harmonic frequencies. While the patterns differed between the first and second harmonics, within the same harmonic, whether the stimuli were presented monocularly or binocularly, the patterns were similar. 

Our four experiments produced results that we were expecting based on our previous pupillometry findings [@Segala2023]: the signals between the 2 pupils are combined non-linearly regardless of which photoreceptor pathway is being stimulated and whether the fovea or the periphery of the retina is being stimulated. We also observed responses at both the first and the second harmonic frequencies, which were expected based on previous literature [@Spitschan2014; @Stark1957; @Verdon1988]. There was, however, one aspect of our results that we were surprised to observe: the amplitude of this second harmonic response in the different photoreceptor pathways. It is true that we had already observed second harmonic responses when stimulating the periphery of the retina with achromatic luminance modulations flickering at 2 Hz (see Figure \@ref(fig:appendixfig1)b), but the peak was very small when compared to the first harmonic peak, which is similar to what we observed in the luminance experiment here. On the other hand, in the melanopsin and L-M pathway experiments, the first and second harmonics are similar in amplitudes, and in the S-(L+M) pathway experiment, the peak of the second harmonic is even bigger than the peak of the first harmonic. One reason for why this might be happening may be because the driving signal is stronger when using a lower flicker frequency [indeed, pupillometry is more responsive to slow flicker frequencies of less than 1 Hz, @Spitschan2014] and when stimulating the periphery of the retina (we have a very clear waveform for the luminance experiment in Figure \@ref(fig:pupildataLum)b). However, this explanation is not entirely satisfactory: we observed a second harmonic when stimulating the periphery using a higher flicker frequency and the pupil waveforms from the other three experiments are not as clear as the one from the luminance experiment. The presence of a second harmonic might indicate the existence of non-linearities that are not observable in the fovea: indeed, steady-state visual responses can contain activity beyond the first harmonic and these harmonics reflect non-linearities (e.g. squaring, exponentiation, rectification) in the visual response [@Norcia2015]. Additionally, it can be the case that, when these non-linearities are strong, then the higher harmonics can have equal or even higher peaks than the first harmonic. Here, we did observe strong non-linearities in our photoreceptor pathways, as reflected by the interocular suppression weights that were output by our computational model. For the S-(L+M) pathway specifically, it seems that the higher peak of the second harmonic is a behaviour intrinsic to S cones, as this was observed previously [@Spitschan2014].

The pupil phases shown in Figure \@ref(fig:phaseplots) give us more information about the pathways controlling the pupil response. The first thing that we  notice is that the luminance and L-M pathway responses are in anti-phase. It is important to note that, for our L-M pathway stimulation, the stimulus flickered between magenta (first half of the cycle) and cyan (second half of the cycle), which means that the pupil was dilating during the magenta stimulation and then constricting during the cyan presentation. This seems to suggest that increments in magenta would correspond to decrements in brightness and increments in cyan would correspond to increments in brightness. It is possible that, if we had reversed the presentation cycle for the L-M pathway, the pupil response would have been in phase with the luminance responses. It has been recently shown that L-cone and melanopsin stimulation induce an opponent pupillary response to M- and S-cone stimulation [@Murray2018; @Woelders2018]. Our melanopsin and S-(L+M) results show a similar behaviour both for monocular and binocular responses. The L-M pathways results are desynchronised approximately in quadrature phase from the melanopsin and S-(L+M) results. These results also seem to align with what was previously found: combining L and M responses should display results that are between the opponency shown by the isolated cone stimulation. Additionally, this could explain the very strong suppression that binocular (L-M) stimulation displays compared to the monocular stimulation: if L and M produce pupil responses that are in anti-phase with each other, then combining the two together should elicit smaller responses. Finally, since the results from our experiments are not in phase, it would suggest that the photoreceptors control the pupil diameter through different pathways.

# Conclusions

We have demonstrated that binocular combination of temporal flickering light in the autonomic nervous system depends on the photoreceptor pathway. We were able to elicit pupil responses by stimulating only the periphery of the retina and we were able to record contrast response functions for all photoreceptor pathways. While all pathways showed non-linear combination, they showed a variation in how the signals are combined, particularly in the weight of interocular suppression.

# Acknowledgements

Supported by Biotechnology and Biological Sciences Research Council grant BB/V007580/1 awarded to DHB and ARW.

# References
