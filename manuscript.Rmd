---
title: 'Binocular combination in the autonomic nervous system'
author: |
 | Federico G. Segala$^1$, Joel T. Martin$^1$, Annie Y. Morsi$^1$, Alex R. Wade$^{1,2}$ & Daniel H. Baker$^{1,2}$
output:
  bookdown::pdf_document2:
    fig_caption: yes
    toc: no
    keep_tex: true
  html_document: default
bibliography: references.bib
link-citations: yes
linkcolor: black
csl: elife.csl
header-includes:
- \usepackage{caption}
---

```{r setup, include=FALSE}

processdata <- 3  # this flag determines the amount of processing, with 4 levels:
# 0 - do no processing, generate the pdf using existing versions of all figures
# 1 - generate figures using the processed group data
# 2 - average data across participants, do bootstrapping
# 3 - download all raw data and analyse (requires 56GB of storage)

domodelling <- 0    # if set to 1, run the Stan models (takes ~24 hours)

localdir <- 'local/'    # all files are stored in the project directory /local/ which git is told to ignore
if (!file.exists(localdir)){dir.create(localdir)}   # create a local directory to store data and outputs
rawdir <- 'local/rawdata/'
if (!file.exists(rawdir)){dir.create(rawdir)}   # create a local directory to store raw data
figdir <- 'Figures/'
if (!file.exists(figdir)){dir.create(figdir)}   # create a local directory to store figures
datadir <- 'local/processeddata/'
if (!file.exists(datadir)){dir.create(datadir)}   # create a local directory to store processed data

# cut off for data inclusion (Mahalanobis distance for complex data)
SDthresh <<- 3
nbootstraps <<- 1000

# check which packages are installed, install the missing ones, and activate
packagelist <- c('knitr','remotes','tictoc','R.matlab','bookdown','grImport','png','tiff','pals','ez','gtools','signal','boot','quickpsy','rstan','bayestestR','rstatix','coda','parallel','utils','osfr','ggplot2','grid','gridExtra','cowplot','ggsignif','osfr') # list of CRAN packages

missingpackages <- packagelist[!packagelist %in% installed.packages()[,1]]
if (length(missingpackages)>0){install.packages(missingpackages,repos = "http://cran.us.r-project.org")}
if (!'FourierStats' %in% installed.packages()[,1]){remotes::install_github("bakerdh/FourierStats")}
packagelist <- c(packagelist,'FourierStats')
toinstall <- packagelist[which(!packagelist %in% (.packages()))]
invisible(lapply(toinstall,library,character.only=TRUE))

devtools::install_github("kupietz/kableExtra")
library(kableExtra)

knitr::opts_chunk$set(echo = TRUE)

# settings for sampler 
numSavedSteps <- 10000    # total number of MCMC steps
adaptSteps <- 1000  # Number of steps to "tune" the samplers
burnInSteps <- 2000 
thinSteps <- 10
nChains <- 16
ncores <- 8  # because of multi-threading, this is usually double the true number of physical cores, so we halve the number as Stan can only use physical cores
options(mc.cores=ncores)

# helper function to make colours transparent
addalpha <- function(col, alpha=1){apply(sapply(col, col2rgb)/255, 2, function(x) rgb(x[1], x[2], x[3], alpha=alpha))}

anovacirc2way <- function(data, groupA=NULL, groupB=NULL, participant=NULL){
  
  grouplabelsA <- groupA
  grouplabelsB <- groupB
  participantlabels <- participant
  datavals <- data

  grouplabelsA <- as.factor(grouplabelsA)
  factorlistA <- levels(grouplabelsA)
  grouplabelsB <- as.factor(grouplabelsB)
  factorlistB <- levels(grouplabelsB)
  participantlabels <- as.factor(participantlabels)
  participantlist <- levels(participantlabels)
  
  grandmean <- mean(datavals)
  grandvar <- sum(abs(datavals - grandmean)^2)/(length(datavals)-1)
  
    SST <- grandvar*(length(datavals) - 1)
    
    SSW <- 0
    for (n in 1:nlevels(participantlabels)){SSW <- SSW + sum(abs(datavals[which(participantlabels==participantlist[n])] - mean(datavals[which(participantlabels==participantlist[n])]))^2)}
    dfW <- 2*(nlevels(participantlabels)*(nlevels(grouplabelsA)*nlevels(grouplabelsB)-1))
    
    SSBet <- SST - SSW  # between subjects SS - not actually used
    SSM <- 0
    for (a in 1:nlevels(grouplabelsA)){
      for (b in 1:nlevels(grouplabelsB)){
        i <- as.numeric(((grouplabelsA==grouplabelsA[a])))
        j <- as.numeric(((grouplabelsB==grouplabelsB[b])))
        indices <- which((i*j)>0)
        SSM <- SSM + (nlevels(participantlabels)*sum(abs(datavals[indices] - grandmean)^2))
      }
    }
    dfM <- 2*((nlevels(grouplabelsA)*nlevels(grouplabelsB))-1)
    
    SSR <- 0
    for (a in 1:nlevels(grouplabelsA)){
      for (b in 1:nlevels(grouplabelsB)){
        i <- as.numeric(((grouplabelsA==grouplabelsA[a])))
        j <- as.numeric(((grouplabelsB==grouplabelsB[b])))
        indices <- which((i*j)>0)
        condvar <- sum(abs(datavals[indices] - mean(datavals[indices]))^2)/(length(indices)-1)
        SSR <- SSR + (nlevels(participantlabels)-1)*condvar
      }
    }    
    dfR <- 2*(nlevels(participantlabels)-1)*(nlevels(grouplabelsA)*nlevels(grouplabelsB))
    
    groupmeansA <- NULL
    for (n in 1:nlevels(grouplabelsA)){groupmeansA[n] <- mean(datavals[which(grouplabelsA==factorlistA[n])])}
    SSA <- 0
    for (n in 1:nlevels(grouplabelsA)){SSA <- SSA + length(which(grouplabelsA==factorlistA[n]))*abs(groupmeansA[n]-grandmean)^2}
    dfA <- 2*(nlevels(grouplabelsA)-1)
    
    groupmeansB <- NULL
    for (n in 1:nlevels(grouplabelsB)){groupmeansB[n] <- mean(datavals[which(grouplabelsB==factorlistB[n])])}
    SSB <- 0
    for (n in 1:nlevels(grouplabelsB)){SSB <- SSB + length(which(grouplabelsB==factorlistB[n]))*abs(groupmeansB[n]-grandmean)^2}
    dfB <- 2*(nlevels(grouplabelsB)-1)
    
    SSAB <- SSW - (SSA + SSB)
    dfAB <- 2 * (nlevels(grouplabelsA)-1) * (nlevels(grouplabelsB)-1)
    
    MSA <- SSA/dfA
    MSB <- SSB/dfB
    MSAB <- SSAB/dfAB
    MSR <- SSR/dfR
    
    FratioA <- MSA/MSR
    pvalA <- pf(FratioA,df1=dfA,df2=dfR,lower.tail=FALSE)
    FratioB <- MSB/MSR
    pvalB <- pf(FratioB,df1=dfB,df2=dfR,lower.tail=FALSE)
    FratioAB <- MSAB/MSR
    pvalAB <- pf(FratioAB,df1=dfAB,df2=dfR,lower.tail=FALSE)
    
    method <- 'Factorial repeated measures ANOVA^2-circ'
    output <- data.frame(FratioA,pvalA,FratioB,pvalB,FratioAB,pvalAB,dfA,dfB,dfAB,dfR,method)
  
  return(output)
}

cleanup2D <- function(data){
  # helper function to clean up complex data by removing any data points more than 
  # SDthresh standard deviations from the mean (in Mahalanobis distance units)
  cartdata <- data.frame(Re(data),Im(data))
  output <- 0
  if (sum(cartdata)!=0){
    D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
    i <- which(D<SDthresh) 
    output <- mean(temp[i])}
return(output)}

bootstrap2D <- function(data){
  mbs <- data.frame(meanamp=0,lowerCI=0,upperCI=0)
    cartdata <- data.frame(Re(data),Im(data))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
    mbs <- amperrors(data[i],method='boot',quantiles=68,nresamples=nbootstraps)}
return(mbs)}

contrastsdB <- 20*log10(c(6,12,24,48,96))
colpal <- c('#FE5000','#8783CF','#228B22','#808080','#6d008b','#8B8000')
colpalmod <- c('#808080','#8B8000','#FE5000','#8783CF')

# these are approximate values for isolumiant red, green, blue and yellow
stimcolours <- c(rgb(0.02,0.02,0.02),rgb(0.98,0.98,0.98),rgb(0,0.61,0.5),rgb(1,0.39,0.5),rgb(0.35,0.63,0),rgb(0.65,0.37,1),'grey','cornflowerblue')

if (processdata>2){
  # check if raw data are present locally, and download if not
  nodelist <- c('6u7db','xkgd9','pexyk','k9mdq')  # list of OSF nodes containing raw data
  for (expt in 1:4){
    osfproject <- osf_retrieve_node(nodelist[expt])
    osffiles <- osf_ls_files(osfproject,n_max=300)
    for (f in 1:nrow(osffiles)){
      fname <- osffiles$name[f]
      foldername <- strsplit(fname,'.',fixed=TRUE)[[1]][1]
      if (!dir.exists(paste0(rawdir,foldername))){
        osf_download(osffiles[f,],localdir,progress=TRUE)
        dir.create(paste0(rawdir,foldername))
        unzip(paste0(localdir,fname),exdir=paste0(rawdir,foldername))
        file.remove(paste0(localdir,fname))
      }
    }
  }
}


# if (processdata==2){
# # if we're going to need the pre-processed files, extract from zip file
#   if (!file.exists(paste0(datadir,'P101summary.RData'))){
#    if (file.exists('resources/allprocessed.zip')){file.copy('resources/allprocessed.zip',localdir)}
#    if (!file.exists('resources/allprocessed.zip')){ 
#           osfnode <- '2qu6y'
#           osfproject <- osf_retrieve_node(osfnode)
#           osffiles <- osf_ls_files(osfproject,n_max=300)
#           fid <- which(osffiles$name=='allprocessed.zip')
#           osf_download(osffiles[fid,],localdir,progress=TRUE)
#    }
#           unzip(paste0(localdir,'allprocessed.zip'),exdir=localdir)
#           d <- dir(paste0(localdir,'allprocessed'),full.names=TRUE)
#           file.copy(d,datadir)
#   }
# }


```

$^1$Department of Psychology, University of York, Heslington, York, United Kingdom.

$^2$York Biomedical Research Institute, University of York, Heslington, York, United Kingdom.

Address for correspondence: Federico G. Segala, [federico.segala\@york.ac.uk](federico.segala@york.ac.uk)

```{r individualanalyses, include=FALSE, results='hide'}

# analyse individual participant data for all conditions

if (processdata > 2){

  allsubjects <- dir(rawdir)
  for (p in 1:length(allsubjects)){
    participant <- allsubjects[p]

    pupiltargets <- array(0,dim=c(3,2,60))
    pupilmasks <- pupiltargets
    pupiltargets2 <- pupiltargets
    pupilmasks2 <- pupiltargets
    pupilwaveforms <- array(0,dim=c(3,2,60,120*14))
    pupilspectra <- array(0,dim=c(3,2,60,300))
    timeseq <- seq(1/120,10,length.out=120*10)
    timeseq2 <- seq(1/120,14,length.out=120*14)
    targetindex <- (0.5*10)+1
    maskindex <- (0.4*10)+1
    targetindex2 <- (0.5*2*10)+1
    maskindex2 <- (2*0.4*10)+1

    repcounterP <- (1:60)*0
    annfiles <- dir(paste0(rawdir,participant),pattern='*annotations.csv',full.names=TRUE)
    pupilfiles <- dir(paste0(rawdir,participant),pattern='*pupil_positions.csv',full.names=TRUE)
    
    for (block in 1:length(annfiles)){

        adata <- read.csv(annfiles[block])
        
        trialtimes <- NULL
        trialtypes <- NULL
        for (t in 1:(nrow(adata)/2)){
          trialtimes[t] <- mean(adata$timestamp[(t*2 - 1):(t*2)])
          trialtypes[t] <- adata$condition_code[t*2]
        }
        
        trialtypes[which(trialtypes>15)] <- trialtypes[which(trialtypes>15)] + 5
        inclist <- NULL
        for (t in 11:15){
          i <- which(trialtypes==t)
          inclist[t-10] <- i[2]
        }
        inclist <- inclist[which(!is.na(inclist))]
        trialtypes[inclist] <- trialtypes[inclist] + 5
        
        pdata <- read.csv(pupilfiles[block])
        pdata2 <- pdata[,c(1,3,4,14)]
        pdata2 <- pdata2[which(pdata2[,3]>0.2),]
        
        for (trialno in 1:length(trialtypes)){
          repcounterP[trialtypes[trialno]] <- repcounterP[trialtypes[trialno]] + 1
          for (eye in 1:2){
            eyedata <- pdata2[which(pdata2[,2]==(2-eye)),]      
            a <- which(eyedata[,1]>trialtimes[trialno]+2)
            b <- which(eyedata[,1]<(trialtimes[trialno]+12))
            i <- intersect(a,b)
            trial <- eyedata[i,]
            trial <- trial[which(!is.na(trial[,4])),]
            trial[,1] <- trial[,1] - trial[1,1]
            if (nrow(trial)>3){
              resampled <- interp1(trial[,1],trial[,4],timeseq,method='linear',extrap=TRUE)
              fspec <- (fft(resampled)/length(resampled))
              pupiltargets[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[targetindex]
              pupilmasks[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[maskindex]
              pupiltargets2[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[targetindex2]
              pupilmasks2[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno]] <- fspec[maskindex2]
              pupilspectra[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno],1:300] <- fspec[1:300]
            }
            
            a <- which(eyedata[,1]>(trialtimes[trialno]-1))
            b <- which(eyedata[,1]<(trialtimes[trialno]+13))
            i <- intersect(a,b)
            trial <- eyedata[i,]
            trial[,1] <- trial[,1] - trial[1,1]
            if (nrow(trial)>3){
              trial <- trial[which(!is.na(trial[,4])),]
              resampled <- interp1(trial[,1],trial[,4],timeseq2,method='linear',extrap=TRUE)
              pupilwaveforms[repcounterP[trialtypes[trialno]],eye,trialtypes[trialno],] <- resampled - mean(resampled[1:120])
            }
          }
        }
    }
  
    cleanmeansP <- matrix(0,nrow=6,ncol=5)
    cleanmasksP <- matrix(0,nrow=6,ncol=5)
    cleanmeansP2 <- matrix(0,nrow=6,ncol=5)
    cleanmasksP2 <- matrix(0,nrow=6,ncol=5)

    for (cond in 1:6){
        startindex <- (10*(cond-1))
        for (level in 1:5){
          temp <- c(pupiltargets[,,startindex+level],pupiltargets[,,startindex+level+5])
          cartdata <- data.frame(Re(temp),Im(temp))
          if (sum(cartdata)!=0){
            D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
            i <- which(D<SDthresh)
            cleanmeansP[cond,level] <- mean(temp[i])}
          
          temp <- c(pupiltargets2[,,startindex+level],pupiltargets2[,,startindex+level+5])
          cartdata <- data.frame(Re(temp),Im(temp))
          if (sum(cartdata)!=0){
            D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
            i <- which(D<SDthresh)
            cleanmeansP2[cond,level] <- mean(temp[i])}
          
          temp <- c(pupilmasks[,,startindex+level],pupilmasks[,,startindex+level+5])
          cartdata <- data.frame(Re(temp),Im(temp))
          if (sum(cartdata)!=0){
            D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
            i <- which(D<SDthresh)
            cleanmasksP[cond,level] <- mean(temp[i])}
          
          temp <- c(pupilmasks2[,,startindex+level],pupilmasks2[,,startindex+level+5])
          cartdata <- data.frame(Re(temp),Im(temp))
          if (sum(cartdata)!=0){
            D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
            i <- which(D<SDthresh)
            cleanmasksP2[cond,level] <- mean(temp[i])}
        }
    }
  
    meanwavesP <- apply(pupilwaveforms[,,c(15,20),],4,mean,na.rm=TRUE)
    meanspectraP <- apply(pupilspectra[,,c(15,20),],4,mean,na.rm=TRUE)
    save(file=paste(datadir,participant,'_summary.RData',sep=''),list=c('cleanmeansP','cleanmasksP','cleanmeansP2','cleanmasksP2','meanspectraP','meanwavesP'))
  }
  
}

```

```{r groupanalyses, include=FALSE, results='hide'}

# files from P301-P324 are for S-cone stimulation
# files from P501-P524 are for melanopsin stimulation
# files from P601-P624 are for luminance stimulation
# files from P701-P724 are for (L-M) cone stimulation

# load in individual participant data and average, save group data
if (processdata > 1){
  
  prefixlist <- c('P6','P7','P3','P5')
  exptnames <- c('AveragedataLum.RData','AveragedataLM.RData','AveragedataS.RData','AveragedataMel.RData')
  
  includedvalues <- array(0,dim=c(4,24,6,5))
  includedvalues2 <- array(0,dim=c(4,24,6,5))
  
  for (expt in 1:4){
  d <- dir(datadir,pattern=prefixlist[expt], full.names = TRUE)
  
  tempmasksP <- array(0,dim=c(length(d),6,5))
  tempmeansP <- tempmasksP
  tempmeansP2 <- tempmasksP
  tempmasksP2 <- tempmasksP
  tempspectraP <- array(0,dim=c(length(d),300))
  tempwavesP <- array(0,dim=c(length(d),1680))
  
  for (s in 1:length(d)){
    
    load(d[s])
    
    tempmasksP[s,,] <- cleanmasksP
    tempmeansP[s,,] <- cleanmeansP
    tempmasksP2[s,,] <- cleanmasksP2
    tempmeansP2[s,,] <- cleanmeansP2
    tempspectraP[s,] <- meanspectraP
    tempwavesP[s,] <- meanwavesP
  }
  
  # tempspectraP <- tempspectraP[-c(2,4,13,20,26),]
  
  cleanmeansP <- matrix(0,nrow=6,ncol=5)
  cleanmeansPCI <- array(0,c(2,6,5))
  cleanmasksP <- matrix(0,nrow=6,ncol=5)
  cleanmasksPCI <- array(0,c(2,6,5))
  cleanmeansP2 <- matrix(0,nrow=6,ncol=5)
  cleanmeansP2CI <- array(0,c(2,6,5))
  cleanmasksP2 <- matrix(0,nrow=6,ncol=5)
  cleanmasksP2CI <- array(0,c(2,6,5))
  
  for (cond in 1:6){
    for (level in 1:5){
      
      temp <- tempmeansP[,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh)
        includedvalues[expt,i,cond,level] <- 1
        mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
        cleanmeansP[cond,level] <- mean(temp[i])
        cleanmeansPCI[1,cond,level] <- mbs$lowerCI
        cleanmeansPCI[2,cond,level] <- mbs$upperCI
      }
      
      temp <- tempmasksP[,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh)
        mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
        cleanmasksP[cond,level] <- mean(temp[i])
        cleanmasksPCI[1,cond,level] <- mbs$lowerCI
        cleanmasksPCI[2,cond,level] <- mbs$upperCI
      }
      
      temp <- tempmeansP2[,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh)
        mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
        cleanmeansP2[cond,level] <- mean(temp[i])
        cleanmeansP2CI[1,cond,level] <- mbs$lowerCI
        cleanmeansP2CI[2,cond,level] <- mbs$upperCI
      }
      
      temp <- tempmasksP2[,cond,level]
      cartdata <- data.frame(Re(temp),Im(temp))
      if (sum(cartdata)!=0){
        D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
        i <- which(D<SDthresh)
        includedvalues2[expt,i,cond,level] <- 1
        mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
        cleanmasksP2[cond,level] <- mean(temp[i])
        cleanmasksP2CI[1,cond,level] <- mbs$lowerCI
        cleanmasksP2CI[2,cond,level] <- mbs$upperCI
      }
    }
  }
  
  meanspectraP <- (1:300)*0
  meanspectraPCI <- array(0,c(2,300))
  
  for (f in 2:300){
    temp <- tempspectraP[,f]
    cartdata <- data.frame(Re(temp),Im(temp))
    if (sum(cartdata)!=0){
      D <- sqrt(stats::mahalanobis(cartdata, colMeans(cartdata), cov(cartdata)))
      i <- which(D<SDthresh) 
      mbs <- amperrors(temp[i],method='boot',quantiles=68,nresamples=nbootstraps)
      meanspectraP[f] <- mbs$meanamp
      meanspectraPCI[1,f] <- mbs$lowerCI
      meanspectraPCI[2,f] <- mbs$upperCI
    }
  }
  
  meanwavesP <- NULL
  meanwavesPCI <- array(0,dim=c(2,dim(tempwavesP)[2]))
  
  nsubjs <- dim(tempwavesP)[1]
  for (t in 1:dim(tempwavesP)[2]){
    temp <- tempwavesP[,t]
    i <- which(abs(temp-mean(temp))<(SDthresh*sd(temp)))
    meanwavesP[t] <- mean(temp[i])
    bspop <- NULL
    for (s in 1:nbootstraps){bspop[s] <- mean(sample(temp[i],length(i),replace=TRUE))}
    meanwavesPCI[,t] <- quantile(bspop,c(0.16,0.84),na.rm=TRUE)
  }
  
  save(file=paste0(datadir,exptnames[expt]),list=c('meanwavesP','meanwavesPCI','cleanmeansP','cleanmeansPCI','cleanmasksP','cleanmasksPCI','cleanmeansP2','cleanmeansP2CI','cleanmasksP2','cleanmasksP2CI','meanspectraP','meanspectraPCI','tempmeansP','tempmeansP2','tempmasksP','tempmasksP2'))
  }
  
  save(file=paste0(datadir,'included.RData'),list=c('includedvalues','includedvalues2'))
  
  }
```

```{r makestanmodels, include=FALSE, results='hide'}

# create text objects for Stan models

if (domodelling > 0){

CRFmodelstring = "
  data {
    int<lower=1> Nsubj ;
    int<lower=1> Ntotal ;
    real y[Ntotal] ;
    real x[Ntotal] ;
    real<lower=0> w[Ntotal] ;
    int<lower=1> c[Ntotal] ;
    int<lower=1> s[Ntotal] ;
  }
  parameters {
    real<lower=1> Z[Nsubj] ;
    real<lower=0> Rmax[Nsubj] ;
    real<lower=0> wt[Nsubj] ;
    real<lower=0> k[Nsubj] ;
    real<lower=0> p[Nsubj] ;    
    real<lower=0> q[Nsubj] ;    
    real<lower=0> sigma ;
    real<lower=1> Zmu ; 
    real<lower=0> Rmaxmu ; 
    real<lower=0> wtmu ; 
    real<lower=0> kmu ; 
    real<lower=0> pmu ;     
    real<lower=0> qmu ;     
    real<lower=0> Zsigma ;
    real<lower=0> Rmaxsigma ;
    real<lower=0> wtsigma ;
    real<lower=0> ksigma ;
    real<lower=0> psigma ;
    real<lower=0> qsigma ;
    real<lower=0> nu ;
  }
  model {
    Zmu ~ normal( 40 , 20 ) ;
    Rmaxmu ~ normal( 0.5 , 0.3 ) ;
    wtmu ~ normal( 1 , 0.5 ) ;
    kmu ~ normal( 0.2 , 0.05 ) ;
    pmu ~ normal( 0.4 , 0.2 ) ;
    qmu ~ normal( 2 , 0.5 ) ;
    sigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    Zsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    Rmaxsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    wtsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    ksigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    psigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    qsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;
    nu ~ exponential(1/30.0) ;
    Z ~ normal( Zmu , Zsigma ) ; // vectorized
    Rmax ~ normal( Rmaxmu , Rmaxsigma ) ; // vectorized
    wt ~ normal( wtmu , wtsigma ) ; // vectorized
    k ~ normal( kmu , ksigma ) ; // vectorized
    p ~ normal( pmu, psigma ) ;
    q ~ normal( qmu, qsigma ) ;
    for ( i in 1:Ntotal ) {
    
    if (c[i]==1)  // monocular condition
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*(pow(x[i],p[s[i]]+q[s[i]]))/(Z[s[i]] + (pow(x[i],q[s[i]])))) ,
                w[i]*sigma ) ;
                
     else if (c[i]==2)  // binocular condition 
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*((pow(x[i],p[s[i]]+q[s[i]]))/(Z[s[i]] + (pow(x[i],q[s[i]])) + wt[s[i]]*(pow(x[i],q[s[i]]))) + (pow(x[i],p[s[i]]+q[s[i]]))/(Z[s[i]] + (pow(x[i],q[s[i]])) + wt[s[i]]*(pow(x[i],q[s[i]]))))),
                w[i]*sigma ) ;   
                
     else if (c[i]==3)  // dichoptic condition
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*((pow(x[i],p[s[i]]+q[s[i]]))/(Z[s[i]] + (pow(x[i],q[s[i]])) + wt[s[i]]*(pow(48,q[s[i]]))) + (pow(48,p[s[i]]+q[s[i]]))/(Z[s[i]] + (pow(48,q[s[i]])) + wt[s[i]]*(pow(x[i],q[s[i]]))))),
                w[i]*sigma ) ;  
                
                
     else if (c[i]==4)  // binocular cross condition 
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*(pow(x[i],p[s[i]]+q[s[i]]))/(Z[s[i]] + (pow(x[i],q[s[i]])) + wt[s[i]]*(pow(x[i],q[s[i]])))) ,
                w[i]*sigma ) ;                  
                
                
     else if (c[i]==5)  // dichoptic cross condition
       y[i] ~ student_t( 
                nu ,
                k[s[i]] + (Rmax[s[i]]*(pow(x[i],p[s[i]]+q[s[i]]))/(Z[s[i]] + (pow(x[i],q[s[i]])) + wt[s[i]]*(pow(48,q[s[i]])))) ,
                w[i]*sigma ) ;       
    }
  }

  " # close quote for CRFmodelstring

# Translate Stan models to C++ and compile to DSO:
CRFmodel <- stan_model(model_code=CRFmodelstring)  
}


```

```{r runstanmodels, include=FALSE, results='hide'}

# do computational modelling for all experiments

# files from P301-P324 are for S-cone stimulation
# files from P501-P524 are for melanopsin stimulation
# files from P601-P624 are for luminance stimulation
# files from P701-P724 are for (L-M) cone stimulation

if (domodelling > 0){
  
  prefixlist <- c('P6','P7','P3','P5')
  exptnames <- c('modeloutputLum.RData','modeloutputLM.RData','modeloutputS.RData','modeloutputMel.RData')
  load(paste0(datadir,'included.RData'))
  
  for (expt in 1:length(prefixlist)){
    
    d <- dir(datadir,pattern=prefixlist[expt])
    
    allmasksP <- array(0,dim=c(length(d),6,5))
    allmeansP <- allmasksP
    allmasksP2 <- array(0,dim=c(length(d),6,5))
    allmeansP2 <- allmasksP
    
    for (s in 1:length(d)){
      
      load(paste0(datadir,d[s]))
      
      allmasksP[s,,] <- cleanmasksP  #/cleanmasksP[2,5]
      allmeansP[s,,] <- cleanmeansP  #/cleanmeansP[2,5]
      allmasksP2[s,,] <- cleanmasksP2  #/cleanmasksP2[2,5]
      allmeansP2[s,,] <- cleanmeansP2  #/cleanmeansP2[2,5]
      
    }
    
    # 1st harmonic
    condlist <- c(1,2,3,5,6)
    contlist <- c(6,12,24,48,96)
    y <- NULL
    x <- NULL
    c <- NULL
    s <- NULL
    w <- NULL
    i <- 0
    for (subj in 1:dim(allmeansP)[1]){
      for (cond in 1:length(condlist)){
        for (cont in 1:length(contlist)){
          dp <- abs(allmeansP[subj,condlist[cond],cont])
          if (includedvalues[expt,subj,condlist[cond],cont]==1){
            if (is.na(dp)==0){
              if (is.infinite(dp)==0){
                i <- i + 1
                x[i] <- contlist[cont]
                y[i] <- dp
                c[i] <- cond
                s[i] <- subj
                w[i] <- 1
              }
            }
          }
        }
      }
    }
    
    pupildatalist = list(x = x, y = y, s = s, w = w, c = c, Nsubj = max(s), Ntotal = length(y))
    
    # Get MC sample of posterior:
    pupilsamples <- sampling(object=CRFmodel, 
                             data = pupildatalist, 
                             chains = nChains,
                             iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                             warmup = burnInSteps, 
                             thin = thinSteps,
                             cores = getOption("mc.cores", 1L))
    
    # 2nd harmonic
    condlist <- c(1,2,3,5,6)
    contlist <- c(6,12,24,48,96)
    y <- NULL
    x <- NULL
    c <- NULL
    s <- NULL
    w <- NULL
    i <- 0
    for (subj in 1:dim(allmeansP2)[1]){
      for (cond in 1:length(condlist)){
        for (cont in 1:length(contlist)){
          dp <- abs(allmeansP2[subj,condlist[cond],cont])
          if (includedvalues2[expt,subj,condlist[cond],cont]==1){
            if (is.na(dp)==0){
            if (is.infinite(dp)==0){
              i <- i + 1
              x[i] <- contlist[cont]
              y[i] <- dp
              c[i] <- cond
              s[i] <- subj
              w[i] <- 1
            }
          }
          }
          }
      }
    }
    
    pupildatalist = list(x = x, y = y, s = s, w = w, c = c, Nsubj = max(s), Ntotal = length(y))
    
    # Get MC sample of posterior:
    pupilsamples2 <- sampling(object=CRFmodel, 
                              data = pupildatalist, 
                              chains = nChains,
                              iter = (ceiling(numSavedSteps/nChains)*thinSteps+burnInSteps), 
                              warmup = burnInSteps, 
                              thin = thinSteps,
                              cores = getOption("mc.cores", 1L))
    
    save(file=paste0(datadir,exptnames[expt]),list=c('pupilsamples','pupilsamples2'))
  }
  
}

```

```{r getmodelpredictions, include=FALSE, results='hide'}

# create figure containing modelling results

  load(paste0(datadir,'modeloutputLum.RData'))

  nchains <- dim(pupilsamples)[2]
  pupilweightpopLum <- NULL
  pupilZpopLum <- NULL
  pupilKpopLum <- NULL
  pupilPpopLum <- NULL
  pupilQpopLum <- NULL
  pupilRpopLum <- NULL
  
  for (n in 1:nchains){
    pupilweightpopLum <- c(pupilweightpopLum,pupilsamples@sim$samples[[n]]$wtmu)
    pupilZpopLum <- c(pupilZpopLum,pupilsamples@sim$samples[[n]]$Zmu)
    pupilKpopLum <- c(pupilKpopLum,pupilsamples@sim$samples[[n]]$kmu)
    pupilPpopLum <- c(pupilPpopLum,pupilsamples@sim$samples[[n]]$pmu)
    pupilQpopLum <- c(pupilQpopLum,pupilsamples@sim$samples[[n]]$qmu)
    pupilRpopLum <- c(pupilRpopLum,pupilsamples@sim$samples[[n]]$Rmaxmu)
  }
  
  pupilWLum <- 10^(map_estimate(log10(pupilweightpopLum)))
  pupilZLum <- 10^(map_estimate(log10(pupilZpopLum)))
  pupilKLum <- 10^(map_estimate(log10(pupilKpopLum)))/sqrt(24)
  pupilPLum <- 10^(map_estimate(log10(pupilPpopLum+pupilQpopLum)))
  pupilQLum <- 10^(map_estimate(log10(pupilQpopLum)))
  pupilRmaxLum <- 10^(map_estimate(log10(pupilRpopLum)))
  
  load(paste0(datadir,'modeloutputMel.RData'))
    
  nchains <- dim(pupilsamples)[2]
  pupilweightpopMel <- NULL
  pupilZpopMel <- NULL
  pupilKpopMel <- NULL
  pupilPpopMel <- NULL
  pupilQpopMel <- NULL
  pupilRpopMel <- NULL
  
  for (n in 1:nchains){
    pupilweightpopMel <- c(pupilweightpopMel,pupilsamples@sim$samples[[n]]$wtmu)
    pupilZpopMel <- c(pupilZpopMel,pupilsamples@sim$samples[[n]]$Zmu)
    pupilKpopMel <- c(pupilKpopMel,pupilsamples@sim$samples[[n]]$kmu)
    pupilPpopMel <- c(pupilPpopMel,pupilsamples@sim$samples[[n]]$pmu)
    pupilQpopMel <- c(pupilQpopMel,pupilsamples@sim$samples[[n]]$qmu)
    pupilRpopMel <- c(pupilRpopMel,pupilsamples@sim$samples[[n]]$Rmaxmu)
  }
  
  pupilWMel <- 10^(map_estimate(log10(pupilweightpopMel)))
  pupilZMel <- 10^(map_estimate(log10(pupilZpopMel)))
  pupilKMel <- 10^(map_estimate(log10(pupilKpopMel)))/sqrt(24)
  pupilPMel <- 10^(map_estimate(log10(pupilPpopMel+pupilQpopMel)))
  pupilQMel <- 10^(map_estimate(log10(pupilQpopMel)))
  pupilRmaxMel <- 10^(map_estimate(log10(pupilRpopMel)))
  
   load(paste0(datadir,'modeloutputLM.RData'))
   
  nchains <- dim(pupilsamples)[2]
  pupilweightpopLM <- NULL
  pupilZpopLM <- NULL
  pupilKpopLM <- NULL
  pupilPpopLM <- NULL
  pupilQpopLM <- NULL
  pupilRpopLM <- NULL
  
  for (n in 1:nchains){
    pupilweightpopLM <- c(pupilweightpopLM,pupilsamples@sim$samples[[n]]$wtmu)
    pupilZpopLM <- c(pupilZpopLM,pupilsamples@sim$samples[[n]]$Zmu)
    pupilKpopLM <- c(pupilKpopLM,pupilsamples@sim$samples[[n]]$kmu)
    pupilPpopLM <- c(pupilPpopLM,pupilsamples@sim$samples[[n]]$pmu)
    pupilQpopLM <- c(pupilQpopLM,pupilsamples@sim$samples[[n]]$qmu)
    pupilRpopLM <- c(pupilRpopLM,pupilsamples@sim$samples[[n]]$Rmaxmu)
  }
  
  pupilWLM <- 10^(map_estimate(log10(pupilweightpopLM)))
  pupilZLM <- 10^(map_estimate(log10(pupilZpopLM)))
  pupilKLM <- 10^(map_estimate(log10(pupilKpopLM)))/sqrt(24)
  pupilPLM <- 10^(map_estimate(log10(pupilPpopLM+pupilQpopLM)))
  pupilQLM <- 10^(map_estimate(log10(pupilQpopLM)))
  pupilRmaxLM <- 10^(map_estimate(log10(pupilRpopLM)))
  
    load(paste0(datadir,'modeloutputS.RData'))
    
  nchains <- dim(pupilsamples)[2]
  pupilweightpopS <- NULL
  pupilZpopS <- NULL
  pupilKpopS <- NULL
  pupilPpopS <- NULL
  pupilQpopS <- NULL
  pupilRpopS <- NULL
  
  for (n in 1:nchains){
    pupilweightpopS <- c(pupilweightpopS,pupilsamples@sim$samples[[n]]$wtmu)
    pupilZpopS <- c(pupilZpopS,pupilsamples@sim$samples[[n]]$Zmu)
    pupilKpopS <- c(pupilKpopS,pupilsamples@sim$samples[[n]]$kmu)
    pupilPpopS <- c(pupilPpopS,pupilsamples@sim$samples[[n]]$pmu)
    pupilQpopS <- c(pupilQpopS,pupilsamples@sim$samples[[n]]$qmu)
    pupilRpopS <- c(pupilRpopS,pupilsamples@sim$samples[[n]]$Rmaxmu)
  }
  
  pupilWS <- 10^(map_estimate(log10(pupilweightpopS)))
  pupilZS <- 10^(map_estimate(log10(pupilZpopS)))
  pupilKS <- 10^(map_estimate(log10(pupilKpopS)))/sqrt(24)
  pupilPS <- 10^(map_estimate(log10(pupilPpopS+pupilQpopS)))
  pupilQS <- 10^(map_estimate(log10(pupilQpopS)))
  pupilRmaxS <- 10^(map_estimate(log10(pupilRpopS)))
  
      load(paste0(datadir,'modeloutputLum.RData'))

  nchains <- dim(pupilsamples2)[2]
  pupilweightpopLum2 <- NULL
  pupilZpopLum2 <- NULL
  pupilKpopLum2 <- NULL
  pupilPpopLum2 <- NULL
  pupilQpopLum2 <- NULL
  pupilRpopLum2 <- NULL
  
  for (n in 1:nchains){
    pupilweightpopLum2 <- c(pupilweightpopLum2,pupilsamples2@sim$samples[[n]]$wtmu)
    pupilZpopLum2 <- c(pupilZpopLum2,pupilsamples2@sim$samples[[n]]$Zmu)
    pupilKpopLum2 <- c(pupilKpopLum2,pupilsamples2@sim$samples[[n]]$kmu)
    pupilPpopLum2 <- c(pupilPpopLum2,pupilsamples2@sim$samples[[n]]$pmu)
    pupilQpopLum2 <- c(pupilQpopLum2,pupilsamples2@sim$samples[[n]]$qmu)
    pupilRpopLum2 <- c(pupilRpopLum2,pupilsamples2@sim$samples[[n]]$Rmaxmu)
  }
  
  pupilWLum2 <- 10^(map_estimate(log10(pupilweightpopLum2)))
  pupilZLum2 <- 10^(map_estimate(log10(pupilZpopLum2)))
  pupilKLum2 <- 10^(map_estimate(log10(pupilKpopLum2)))/sqrt(24)
  pupilPLum2 <- 10^(map_estimate(log10(pupilPpopLum2+pupilQpopLum2)))
  pupilQLum2 <- 10^(map_estimate(log10(pupilQpopLum2)))
  pupilRmaxLum2 <- 10^(map_estimate(log10(pupilRpopLum2)))
  
    load(paste0(datadir,'modeloutputMel.RData'))

  nchains <- dim(pupilsamples2)[2]
  pupilweightpopMel2 <- NULL
  pupilZpopMel2 <- NULL
  pupilKpopMel2 <- NULL
  pupilPpopMel2 <- NULL
  pupilQpopMel2 <- NULL
  pupilRpopMel2 <- NULL
  
  for (n in 1:nchains){
    pupilweightpopMel2 <- c(pupilweightpopMel2,pupilsamples2@sim$samples[[n]]$wtmu)
    pupilZpopMel2 <- c(pupilZpopMel2,pupilsamples2@sim$samples[[n]]$Zmu)
    pupilKpopMel2 <- c(pupilKpopMel2,pupilsamples2@sim$samples[[n]]$kmu)
    pupilPpopMel2 <- c(pupilPpopMel2,pupilsamples2@sim$samples[[n]]$pmu)
    pupilQpopMel2 <- c(pupilQpopMel2,pupilsamples2@sim$samples[[n]]$qmu)
    pupilRpopMel2 <- c(pupilRpopMel2,pupilsamples2@sim$samples[[n]]$Rmaxmu)
  }
  
  pupilWMel2 <- 10^(map_estimate(log10(pupilweightpopMel2)))
  pupilZMel2 <- 10^(map_estimate(log10(pupilZpopMel2)))
  pupilKMel2 <- 10^(map_estimate(log10(pupilKpopMel2)))/sqrt(24)
  pupilPMel2 <- 10^(map_estimate(log10(pupilPpopMel2+pupilQpopMel2)))
  pupilQMel2 <- 10^(map_estimate(log10(pupilQpopMel2)))
  pupilRmaxMel2 <- 10^(map_estimate(log10(pupilRpopMel2)))
  
     load(paste0(datadir,'modeloutputLM.RData'))

  nchains <- dim(pupilsamples2)[2]
  pupilweightpopLM2 <- NULL
  pupilZpopLM2 <- NULL
  pupilKpopLM2 <- NULL
  pupilPpopLM2 <- NULL
  pupilQpopLM2 <- NULL
  pupilRpopLM2 <- NULL
  
  for (n in 1:nchains){
    pupilweightpopLM2 <- c(pupilweightpopLM2,pupilsamples2@sim$samples[[n]]$wtmu)
    pupilZpopLM2 <- c(pupilZpopLM2,pupilsamples2@sim$samples[[n]]$Zmu)
    pupilKpopLM2 <- c(pupilKpopLM2,pupilsamples2@sim$samples[[n]]$kmu)
    pupilPpopLM2 <- c(pupilPpopLM2,pupilsamples2@sim$samples[[n]]$pmu)
    pupilQpopLM2 <- c(pupilQpopLM2,pupilsamples2@sim$samples[[n]]$qmu)
    pupilRpopLM2 <- c(pupilRpopLM2,pupilsamples2@sim$samples[[n]]$Rmaxmu)
  }
  
  pupilWLM2 <- 10^(map_estimate(log10(pupilweightpopLM2)))
  pupilZLM2 <- 10^(map_estimate(log10(pupilZpopLM2)))
  pupilKLM2 <- 10^(map_estimate(log10(pupilKpopLM2)))/sqrt(24)
  pupilPLM2 <- 10^(map_estimate(log10(pupilPpopLM2+pupilQpopLM2)))
  pupilQLM2 <- 10^(map_estimate(log10(pupilQpopLM2)))
  pupilRmaxLM2 <- 10^(map_estimate(log10(pupilRpopLM2)))
  
     load(paste0(datadir,'modeloutputS.RData'))

  nchains <- dim(pupilsamples2)[2]
  pupilweightpopS2 <- NULL
  pupilZpopS2 <- NULL
  pupilKpopS2 <- NULL
  pupilPpopS2 <- NULL
  pupilQpopS2 <- NULL
  pupilRpopS2 <- NULL
  
  for (n in 1:nchains){
    pupilweightpopS2 <- c(pupilweightpopS2,pupilsamples2@sim$samples[[n]]$wtmu)
    pupilZpopS2 <- c(pupilZpopS2,pupilsamples2@sim$samples[[n]]$Zmu)
    pupilKpopS2 <- c(pupilKpopS2,pupilsamples2@sim$samples[[n]]$kmu)
    pupilPpopS2 <- c(pupilPpopS2,pupilsamples2@sim$samples[[n]]$pmu)
    pupilQpopS2 <- c(pupilQpopS2,pupilsamples2@sim$samples[[n]]$qmu)
    pupilRpopS2 <- c(pupilRpopS2,pupilsamples2@sim$samples[[n]]$Rmaxmu)
  }
  
  pupilWS2 <- 10^(map_estimate(log10(pupilweightpopS2)))
  pupilZS2 <- 10^(map_estimate(log10(pupilZpopS2)))
  pupilKS2 <- 10^(map_estimate(log10(pupilKpopS2)))/sqrt(24)
  pupilPS2 <- 10^(map_estimate(log10(pupilPpopS2+pupilQpopS2)))
  pupilQS2 <- 10^(map_estimate(log10(pupilQpopS2)))
  pupilRmaxS2 <- 10^(map_estimate(log10(pupilRpopS2)))
  
getmodresps <- function(params){
contrastsfinedB <- 2:40
contrastsfine <- 10^(contrastsfinedB/20)

modresps <- matrix(0,nrow=4,ncol=length(contrastsfine))
modresps[1,] <- params[1]*(contrastsfine^params[2])/(params[3] + contrastsfine^params[6]) + params[5]

binresp <- 2*((contrastsfine^params[2])/(params[3] + contrastsfine^params[6] + params[4]*contrastsfine^params[6]))
modresps[2,] <- params[1]*binresp + params[5]

dichresp <- ((contrastsfine^params[2])/(params[3] + contrastsfine^params[6] + params[4]*48^params[6])) + ((48^params[2])/(params[3] + 48^params[6] + params[4]*contrastsfine^params[6]))
modresps[3,] <- params[1]*dichresp + params[5]

dichresp2 <- ((contrastsfine^params[2])/(params[3] + contrastsfine^params[6] + params[4]*48^params[6]))
modresps[4,] <- params[1]*dichresp2 + params[5]

return(modresps)}

params <- c(pupilRmaxLum,pupilPLum,pupilZLum,pupilWLum,pupilKLum,pupilQLum)
modrespsLum <- getmodresps(params)

params <- c(pupilRmaxMel,pupilPMel,pupilZMel,pupilWMel,pupilKMel,pupilQMel)
modrespsMel <- getmodresps(params)

params <- c(pupilRmaxLM,pupilPLM,pupilZLM,pupilWLM,pupilKLM,pupilQLM)
modrespsLM <- getmodresps(params)

params <- c(pupilRmaxS,pupilPS,pupilZS,pupilWS,pupilKS,pupilQS)
modrespsS <- getmodresps(params)

params <- c(pupilRmaxLum2,pupilPLum2,pupilZLum2,pupilWLum2,pupilKLum2,pupilQLum2)
modrespsLum2 <- getmodresps(params)

params <- c(pupilRmaxMel2,pupilPMel2,pupilZMel2,pupilWMel2,pupilKMel2,pupilQMel2)
modrespsMel2 <- getmodresps(params)

params <- c(pupilRmaxLM2,pupilPLM2,pupilZLM2,pupilWLM2,pupilKLM2,pupilQLM2)
modrespsLM2 <- getmodresps(params)

params <- c(pupilRmaxS2,pupilPS2,pupilZS2,pupilWS2,pupilKS2,pupilQS2)
modrespsS2 <- getmodresps(params)

```

```{r makemethodsfig, include=FALSE, results='hide'}

# create plots of spectra, cone absorption, waveforms and Fourier spectra
if (processdata > 0){

plotcontrasts <- 1 # either plot photoreceptor contrasts (1) or absolute irradiance change (0)
  
times <- seq((1/120)-1,13,1/120)
frequencies <- (0:299)/10
sinewave <- sin(0.5*times * 2*pi)
sinewave[1:120] <- 0
sinewave[1560:1680] <- 0

coneab <- read.csv('resources/coneabsorptions.csv',header=FALSE)
spectra <- read.csv('resources/spectra.csv',header=FALSE)

# calculate delta photoreceptor contrast
pcontrast <- coneab
for (n in 4:11){pcontrast[,n] <- 100*coneab[,n]/coneab[,2]}

  pdf(paste0(figdir,"methodsfig.pdf"), bg="transparent", height = 13, width = 12)

layout(matrix(1:20, 5, 4, byrow = TRUE))
par(mar=c(1.5,1,0.1,0.1))
    
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))  

  schematic <- readTIFF('resources/schematic.tiff')
  aspratio <- 15/12  # this is the aspect ratio of the output pdf
  imwidth <- 0.85
  xstart <- 0
  ystart <- 0
  rasterImage(schematic,xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth)

  text(0,0.88,'(a)',pos=4,cex=2)

  par(mar=c(3.5,6,1.5,2))
  
lspec <- read.csv('resources/STLAB_1_oo_irrad_spectra.csv',header=FALSE)
rspec <- read.csv('resources/STLAB_2_oo_irrad_spectra.csv',header=FALSE)

lall <- matrix(0,nrow=11,ncol=401)
lall[1,] <- unlist(lspec[1,3:403])
rall <- matrix(0,nrow=11,ncol=401)
rall[1,] <- unlist(rspec[1,3:403])
for (primary in 1:10){
  temp <- subset(lspec,V1==(primary-1) & V2=='4095')
  lall[primary+1,] <- unlist(temp[1,3:403])
  temp <- subset(rspec,V1==(primary-1) & V2=='4095')
  rall[primary+1,] <- unlist(temp[1,3:403])  
}

primaryrgbvals <- c(rgb(128/255,50/255,218/255),rgb(74/255,104/255,218/255),rgb(0,0,133/255),rgb(0,0,245/255),rgb(117/255,252/255,253/255),rgb(55/255,126/255,33/255),rgb(117/255,252/255,76/255),rgb(242/255,169/255,59/255),rgb(234/255,51/255,35/255),rgb(127/255,23/255,14/255))

plotlims <- c(380,800,0,0.2)
ticklocsx <- seq(400,800,100)    # locations of tick marks on x axis
ticklocsy <- seq(0,0.2,0.1)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Wavelength (nm)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab=expression(paste("Power (",mu,"W/cm"^"2","/nm)")), col.lab=rgb(0,0,0), line=2, cex.lab=1.5)

# for (primary in 1:10){polygon(c(lall[1,],780),c(lall[primary+1,],0),col=addalpha(primaryrgbvals[primary],0.5),border=NA)}
for (primary in 1:10){polygon(c(rall[1,],780),c(rall[primary+1,],0),col=addalpha(primaryrgbvals[primary],0.5),border=NA)}

legend(680,0.2,1:10,col=primaryrgbvals,lwd=2,box.lwd=2,title='Primary')
text(380,0.19,'(b)',pos=4,cex=2)


plotlims <- c(380,800,0,0.2)
ticklocsx <- seq(400,800,100)    # locations of tick marks on x axis
ticklocsy <- seq(0,0.2,0.1)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Wavelength (nm)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab=expression(paste("Power (",mu,"W/cm"^"2","/nm)")), col.lab=rgb(0,0,0), line=2, cex.lab=1.5)

lines(spectra[,1],spectra[,2],lwd=2,col=colpal[2])
lines(spectra[,1],spectra[,3],lwd=2,lty=2)

legend(380,0.2,c('Left eye', 'Right eye'),lty=1:2,lwd=2,col=c(colpal[2],'black'),box.lwd=2)

text(720,0.19,'(c)',pos=4,cex=2)


plotlims <- c(0.5,5.5,0,15)
ticklocsx <- 1:5    # locations of tick marks on x axis
ticklocsy <- seq(0,15,5)    # locations of tick marks on y axis
ticklabelsx <- c('sc','mc','lc','rh','mel')        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Photoreceptor class", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab=expression(paste(alpha,"-opic irradiance")), col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (b in 1:5){
  polygon(c(b-0.3,b,b,b-0.3),c(0,0,coneab[b,2],coneab[b,2]),col=colpal[2],border=NA)
  polygon(c(b+0.3,b,b,b+0.3),c(0,0,coneab[b,3],coneab[b,3]),col='black',border=NA)
}

text(4.5,14,'(d)',pos=4,cex=2)


plotlims <- c(380,800,-0.2,0.2)
ticklocsx <- seq(400,800,100)    # locations of tick marks on x axis
ticklocsy <- seq(-0.2,0.2,0.1)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Wavelength (nm)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Difference power", col.lab=rgb(0,0,0), line=2.8, cex.lab=1.5)
title(main='Luminance',cex.main=2)

polygon(c(spectra[,1],spectra[401,1]),c(spectra[,4],0),border=NA,col=stimcolours[1])
polygon(c(spectra[,1],spectra[401,1]),c(spectra[,5],0),border=NA,col=stimcolours[2])

lines(spectra[,1],spectra[,4],lwd=2)
lines(spectra[,1],spectra[,5],lwd=2)

lines(c(380,800),c(0,0),lwd=2)

text(720,0.18,'(e)',pos=4,cex=2)

plotlims <- c(380,800,-0.2,0.2)
ticklocsx <- seq(400,800,100)    # locations of tick marks on x axis
ticklocsy <- seq(-0.2,0.2,0.1)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Wavelength (nm)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Difference power", col.lab=rgb(0,0,0), line=2.8, cex.lab=1.5)
title(main='L-M cone',cex.main=2)

polygon(spectra[,1],spectra[,6],border=NA,col=stimcolours[3])
polygon(spectra[,1],spectra[,7],border=NA,col=stimcolours[4])

lines(spectra[,1],spectra[,6],lwd=2)
lines(spectra[,1],spectra[,7],lwd=2)

lines(c(380,800),c(0,0),lwd=2)

text(720,0.18,'(f)',pos=4,cex=2)

plotlims <- c(380,800,-0.2,0.2)
ticklocsx <- seq(400,800,100)    # locations of tick marks on x axis
ticklocsy <- seq(-0.2,0.2,0.1)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Wavelength (nm)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Difference power", col.lab=rgb(0,0,0), line=2.8, cex.lab=1.5)
title(main='S-cone',cex.main=2)

polygon(spectra[,1],spectra[,8],border=NA,col=stimcolours[5])
polygon(spectra[,1],spectra[,9],border=NA,col=stimcolours[6])

lines(spectra[,1],spectra[,8],lwd=2)
lines(spectra[,1],spectra[,9],lwd=2)

lines(c(380,800),c(0,0),lwd=2)

text(720,0.18,'(g)',pos=4,cex=2)

plotlims <- c(380,800,-0.2,0.2)
ticklocsx <- seq(400,800,100)    # locations of tick marks on x axis
ticklocsy <- seq(-0.2,0.2,0.1)    # locations of tick marks on y axis
ticklabelsx <- ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Wavelength (nm)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Difference power", col.lab=rgb(0,0,0), line=2.8, cex.lab=1.5)
title(main='Melanopsin',cex.main=2)

polygon(spectra[,1],spectra[,10],border=NA,col=stimcolours[7])
polygon(spectra[,1],spectra[,11],border=NA,col=stimcolours[8])

lines(spectra[,1],spectra[,10],lwd=2)
lines(spectra[,1],spectra[,11],lwd=2)

lines(c(380,800),c(0,0),lwd=2)

text(720,0.18,'(h)',pos=4,cex=2)


if (plotcontrasts==1){
  
plotlims <- c(0.5,5.5,-100,100)
ticklocsx <- 1:5    # locations of tick marks on x axis
ticklocsy <- seq(-100,100,50)    # locations of tick marks on y axis
ticklabelsx <- c('sc','mc','lc','rh','mel')        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Photoreceptor class", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Contrast (%)", col.lab=rgb(0,0,0), line=2, cex.lab=1.5)

for (b in 1:5){
  polygon(c(b-0.3,b+0.3,b+0.3,b-0.3),c(0,0,pcontrast[b,4],pcontrast[b,4]),col=stimcolours[1],border='black',lwd=2)
  polygon(c(b-0.3,b+0.3,b+0.3,b-0.3),c(0,0,pcontrast[b,5],pcontrast[b,5]),col=stimcolours[2],border='black',lwd=2)
}

lines(c(0.5,5.5),c(0,0),lwd=2)

text(4.55,80,'(i)',pos=4,cex=2)

plotlims <- c(0.5,5.5,-20,20)
ticklocsx <- 1:5    # locations of tick marks on x axis
ticklocsy <- seq(-20,20,10)    # locations of tick marks on y axis
ticklabelsx <- c('sc','mc','lc','rh','mel')        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Photoreceptor class", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Contrast (%)", col.lab=rgb(0,0,0), line=2, cex.lab=1.5)

for (b in 1:5){
  polygon(c(b-0.3,b+0.3,b+0.3,b-0.3),c(0,0,pcontrast[b,6],pcontrast[b,6]),col=stimcolours[3],border='black',lwd=2)
  polygon(c(b-0.3,b+0.3,b+0.3,b-0.3),c(0,0,pcontrast[b,7],pcontrast[b,7]),col=stimcolours[4],border='black',lwd=2)
}

lines(c(0.5,5.5),c(0,0),lwd=2)

text(4.6,18,'(j)',pos=4,cex=2)

plotlims <- c(0.5,5.5,-50,50)
ticklocsx <- 1:5    # locations of tick marks on x axis
ticklocsy <- seq(-50,50,25)    # locations of tick marks on y axis
ticklabelsx <- c('sc','mc','lc','rh','mel')        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Photoreceptor class", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Contrast (%)", col.lab=rgb(0,0,0), line=2, cex.lab=1.5)

for (b in 1:5){
  polygon(c(b-0.3,b+0.3,b+0.3,b-0.3),c(0,0,pcontrast[b,8],pcontrast[b,8]),col=stimcolours[5],border='black',lwd=2)
  polygon(c(b-0.3,b+0.3,b+0.3,b-0.3),c(0,0,pcontrast[b,9],pcontrast[b,9]),col=stimcolours[6],border='black',lwd=2)
}

lines(c(0.5,5.5),c(0,0),lwd=2)

text(4.6,45,'(k)',pos=4,cex=2)

plotlims <- c(0.5,5.5,-20,20)
ticklocsx <- 1:5    # locations of tick marks on x axis
ticklocsy <- seq(-20,20,20)    # locations of tick marks on y axis
ticklabelsx <- c('sc','mc','lc','rh','mel')        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Photoreceptor class", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Contrast (%)", col.lab=rgb(0,0,0), line=2, cex.lab=1.5)

for (b in 1:5){
  polygon(c(b-0.3,b+0.3,b+0.3,b-0.3),c(0,0,pcontrast[b,10],pcontrast[b,10]),col=stimcolours[7],border='black',lwd=2)
  polygon(c(b-0.3,b+0.3,b+0.3,b-0.3),c(0,0,pcontrast[b,11],pcontrast[b,11]),col=stimcolours[8],border='black',lwd=2)
}

lines(c(0.5,5.5),c(0,0),lwd=2)

text(0.5,18,'(l)',pos=4,cex=2)
}

if (plotcontrasts==0){
plotlims <- c(0.5,5.5,-15,15)
ticklocsx <- 1:5    # locations of tick marks on x axis
ticklocsy <- seq(-15,15,5)    # locations of tick marks on y axis
ticklabelsx <- c('sc','mc','lc','rh','mel')        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Photoreceptor class", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Irradiance change", col.lab=rgb(0,0,0), line=2.8, cex.lab=1.5)

for (b in 1:5){
  polygon(c(b-0.3,b+0.3,b+0.3,b-0.3),c(0,0,coneab[b,4],coneab[b,4]),col=stimcolours[1],border='black',lwd=2)
  polygon(c(b-0.3,b+0.3,b+0.3,b-0.3),c(0,0,coneab[b,5],coneab[b,5]),col=stimcolours[2],border='black',lwd=2)
}

lines(c(0.5,5.5),c(0,0),lwd=2)

text(4.5,14,'(i)',pos=4,cex=2)

plotlims <- c(0.5,5.5,-4,4)
ticklocsx <- 1:5    # locations of tick marks on x axis
ticklocsy <- seq(-4,4,2)    # locations of tick marks on y axis
ticklabelsx <- c('sc','mc','lc','rh','mel')        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Photoreceptor class", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Irradiance change", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (b in 1:5){
  polygon(c(b-0.3,b+0.3,b+0.3,b-0.3),c(0,0,coneab[b,6],coneab[b,6]),col=stimcolours[3],border='black',lwd=2)
  polygon(c(b-0.3,b+0.3,b+0.3,b-0.3),c(0,0,coneab[b,7],coneab[b,7]),col=stimcolours[4],border='black',lwd=2)
}

lines(c(0.5,5.5),c(0,0),lwd=2)

text(4.5,3.6,'(j)',pos=4,cex=2)

plotlims <- c(0.5,5.5,-4,4)
ticklocsx <- 1:5    # locations of tick marks on x axis
ticklocsy <- seq(-4,4,2)    # locations of tick marks on y axis
ticklabelsx <- c('sc','mc','lc','rh','mel')        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Photoreceptor class", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Irradiance change", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (b in 1:5){
  polygon(c(b-0.3,b+0.3,b+0.3,b-0.3),c(0,0,coneab[b,8],coneab[b,8]),col=stimcolours[5],border='black',lwd=2)
  polygon(c(b-0.3,b+0.3,b+0.3,b-0.3),c(0,0,coneab[b,9],coneab[b,9]),col=stimcolours[6],border='black',lwd=2)
}

lines(c(0.5,5.5),c(0,0),lwd=2)

text(4.5,3.6,'(k)',pos=4,cex=2)

plotlims <- c(0.5,5.5,-4,4)
ticklocsx <- 1:5    # locations of tick marks on x axis
ticklocsy <- seq(-4,4,2)    # locations of tick marks on y axis
ticklabelsx <- c('sc','mc','lc','rh','mel')        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Photoreceptor class", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Irradiance change", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)

for (b in 1:5){
  polygon(c(b-0.3,b+0.3,b+0.3,b-0.3),c(0,0,coneab[b,10],coneab[b,10]),col=stimcolours[7],border='black',lwd=2)
  polygon(c(b-0.3,b+0.3,b+0.3,b-0.3),c(0,0,coneab[b,11],coneab[b,11]),col=stimcolours[8],border='black',lwd=2)
}

lines(c(0.5,5.5),c(0,0),lwd=2)

text(4.5,3.6,'(l)',pos=4,cex=2)
}


  load(file=paste0(datadir,'AveragedataLum.RData'))

plotlims <- c(-1,13,-1,0.5)
ticklocsx <- c(-1,seq(0,12,2),13)    # locations of tick marks on x axis
ticklocsy <- seq(-1,0.5,0.5)    # locations of tick marks on y axis
ticklabelsx <- c('',seq(0,12,2),'')        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Diameter change (mm)", col.lab=rgb(0,0,0), line=2.8, cex.lab=1.5)

filt <- butter(3,0.083)
filtwaveP <- signal::filter(filt, meanwavesP)
filtU <- signal::filter(filt,meanwavesPCI[1,])
filtL <- signal::filter(filt,meanwavesPCI[2,])
polygon(times[c(1:length(times),length(times):1)],c(filtL,filtU[length(filtU):1]),col=addalpha(colpal[2],0.3),border=NA)
lines(times, filtwaveP, col=colpal[2], lwd=1.5)
lines(times, (sinewave/10)-0.9, col='black', lwd=2)

text(-1,0.4,'(m)',pos=4,cex=2)



  load(file=paste0(datadir,'AveragedataLM.RData'))


plotlims <- c(-1,13,-1,0.5)
ticklocsx <- c(-1,seq(0,12,2),13)    # locations of tick marks on x axis
ticklocsy <- seq(-1,0.5,0.5)    # locations of tick marks on y axis
ticklabelsx <- c('',seq(0,12,2),'')        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Diameter change (mm)", col.lab=rgb(0,0,0), line=2.8, cex.lab=1.5)

filt <- butter(3,0.083)
filtwaveP <- signal::filter(filt, meanwavesP)
filtU <- signal::filter(filt,meanwavesPCI[1,])
filtL <- signal::filter(filt,meanwavesPCI[2,])
polygon(times[c(1:length(times),length(times):1)],c(filtL,filtU[length(filtU):1]),col=addalpha(colpal[2],0.3),border=NA)
lines(times, filtwaveP, col=colpal[2], lwd=1.5)
lines(times, (sinewave/10)-0.9, col='black', lwd=2)

text(-1,0.4,'(n)',pos=4,cex=2)

  load(file=paste0(datadir,'AveragedataS.RData'))

plotlims <- c(-1,13,-1,0.5)
ticklocsx <- c(-1,seq(0,12,2),13)    # locations of tick marks on x axis
ticklocsy <- seq(-1,0.5,0.5)    # locations of tick marks on y axis
ticklabelsx <- c('',seq(0,12,2),'')        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Diameter change (mm)", col.lab=rgb(0,0,0), line=2.8, cex.lab=1.5)

filt <- butter(3,0.083)
filtwaveP <- signal::filter(filt, meanwavesP)
filtU <- signal::filter(filt,meanwavesPCI[1,])
filtL <- signal::filter(filt,meanwavesPCI[2,])
polygon(times[c(1:length(times),length(times):1)],c(filtL,filtU[length(filtU):1]),col=addalpha(colpal[2],0.3),border=NA)
lines(times, filtwaveP, col=colpal[2], lwd=1.5)
lines(times, (sinewave/10)-0.9, col='black', lwd=2)

text(-1,0.4,'(o)',pos=4,cex=2)

load(file=paste0(datadir,'AveragedataMel.RData'))


plotlims <- c(-1,13,-1,0.5)
ticklocsx <- c(-1,seq(0,12,2),13)    # locations of tick marks on x axis
ticklocsy <- seq(-1,0.5,0.5)    # locations of tick marks on y axis
ticklabelsx <- c('',seq(0,12,2),'')        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
title(ylab="Diameter change (mm)", col.lab=rgb(0,0,0), line=2.8, cex.lab=1.5)

filt <- butter(3,0.083)
filtwaveP <- signal::filter(filt, meanwavesP)
filtU <- signal::filter(filt,meanwavesPCI[1,])
filtL <- signal::filter(filt,meanwavesPCI[2,])
polygon(times[c(1:length(times),length(times):1)],c(filtL,filtU[length(filtU):1]),col=addalpha(colpal[2],0.3),border=NA)
lines(times, filtwaveP, col=colpal[2], lwd=1.5)
lines(times, (sinewave/10)-0.9, col='black', lwd=2)

text(-1,0.4,'(p)',pos=4,cex=2)

  load(file=paste0(datadir,'AveragedataLum.RData'))

plotlims <- c(0,2,0,0.15) 
ticklocsx <- seq(0,2,0.5)    # locations of tick marks on x axis
ticklocsy <- seq(0,0.15,0.05)    # locations of tick marks on y axis
ticklabelsx <-ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)  
title(ylab="Amplitude (mm)", col.lab=rgb(0,0,0), line=3.5, cex.lab=1.5)

polygon(frequencies[c(3:21,21:3)],c(meanspectraPCI[1,3:21],meanspectraPCI[2,21:3]),col=addalpha(colpal[2],0.3),border=NA)

lines(frequencies[3:21],abs(meanspectraP[3:21]), col=colpal[2], lwd=1.5, cex=0.5) 

text(0,0.14,'(q)',pos=4,cex=2)


load(file=paste0(datadir,'AveragedataLM.RData'))


plotlims <- c(0,2,0,0.015) 
ticklocsx <- seq(0,2,0.5)    # locations of tick marks on x axis
ticklocsy <- seq(0,0.015,0.005)    # locations of tick marks on y axis
ticklabelsx <-ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)  
title(ylab="Amplitude (mm)", col.lab=rgb(0,0,0), line=3.5, cex.lab=1.5)

polygon(frequencies[c(3:21,21:3)],c(meanspectraPCI[1,3:21],meanspectraPCI[2,21:3]),col=addalpha(colpal[2],0.3),border=NA)

lines(frequencies[3:21],abs(meanspectraP[3:21]), col=colpal[2], lwd=1.5, cex=0.5) 

text(0,0.014,'(r)',pos=4,cex=2)


  load(file=paste0(datadir,'AveragedataS.RData'))

plotlims <- c(0,2,0,0.015) 
ticklocsx <- seq(0,2,0.5)    # locations of tick marks on x axis
ticklocsy <- seq(0,0.015,0.005)    # locations of tick marks on y axis
ticklabelsx <-ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)  
title(ylab="Amplitude (mm)", col.lab=rgb(0,0,0), line=3.5, cex.lab=1.5)

polygon(frequencies[c(3:21,21:3)],c(meanspectraPCI[1,3:21],meanspectraPCI[2,21:3]),col=addalpha(colpal[2],0.3),border=NA)

lines(frequencies[3:21],abs(meanspectraP[3:21]), col=colpal[2], lwd=1.5, cex=0.5) 

text(0,0.014,'(s)',pos=4,cex=2)


load(file=paste0(datadir,'AveragedataMel.RData'))

plotlims <- c(0,2,0,0.015) 
ticklocsx <- seq(0,2,0.5)    # locations of tick marks on x axis
ticklocsy <- seq(0,0.015,0.005)    # locations of tick marks on y axis
ticklabelsx <-ticklocsx        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)  
title(ylab="Amplitude (mm)", col.lab=rgb(0,0,0), line=3.5, cex.lab=1.5)

polygon(frequencies[c(3:21,21:3)],c(meanspectraPCI[1,3:21],meanspectraPCI[2,21:3]),col=addalpha(colpal[2],0.3),border=NA)

lines(frequencies[3:21],abs(meanspectraP[3:21]), col=colpal[2], lwd=1.5, cex=0.5) 

text(0,0.014,'(t)',pos=4,cex=2)


  dev.off()
  
}

```

```{r plotCRFs, include=FALSE, results='hide'}

# create plots of spectra, cone absorption, waveforms and Fourier spectra
if (processdata > 0){

  contrastsfinedB <- 2:40

condlist <- c(1,2,6)
condlist2 <- c(1,2,4)
plotlims <- c(15,40,0,0.15)
plotlims2 <- c(15,40,0,0.015) 
ticklocsx <- contrastsdB    # locations of tick marks on x axis
ticklocsy <- seq(0,0.15,0.05)
ticklocsy2 <- seq(0,0.015,0.005)    # locations of tick marks on y axis
ticklabelsx <-c(6,12,24,48,96)        # set labels for x ticks
ticklabelsy <- ticklocsy
ticklabelsy2 <- ticklocsy2     # set labels for y ticks
  
  pdf(paste0(figdir,"CRFs.pdf"), bg="transparent", height = 6, width = 14)
  par(mfcol=c(2,4), mar=c(3,6,2,2))
  
  
load(file=paste0(datadir,'AveragedataLum.RData'))
  
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 0.5Hz (mm)", col.lab=rgb(0,0,0), line=3, cex.lab=1.5)
title(main='Luminance',cex.main=2)
for (cond in 1:3){
  lines(contrastsfinedB,modrespsLum[condlist2[cond],], col=colpal[condlist[cond]], lwd=3, cex=0.5)
  # lines(contrastsfinedB,abs(cleanmeansP[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansP[condlist[cond],]), pch = 20+cond, col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
legend(15,0.125,c('Monocular','Binocular','Dichoptic cross'),pch=21:23,pt.bg=colpal[condlist],pt.lwd=3,pt.cex=1.6,box.lwd=2,cex=1.2)
text(17,0.14,'(a)',adj=0.5,cex=2.5)


plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims2[1:2], ylim=plotlims2[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy2, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy2, side = 2, at=ticklocsy2, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 1Hz (mm)", col.lab=rgb(0,0,0), line=3.5, cex.lab=1.5)
for (cond in 1:3){
  lines(contrastsfinedB,modrespsLum2[condlist2[cond],], col=colpal[condlist[cond]], lwd=3, cex=0.5)
  # lines(contrastsdB,abs(cleanmeansP2[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansP2[condlist[cond],]),contrastsdB,cleanmeansP2CI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP2[condlist[cond],]),contrastsdB,cleanmeansP2CI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansP2[condlist[cond],]), pch = 20+cond, col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
text(17,0.014,'(e)',adj=0.5,cex=2.5)


load(file=paste0(datadir,'AveragedataLM.RData'))
  
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims2[1:2], ylim=plotlims2[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy2, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy2, side = 2, at=ticklocsy2, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 0.5Hz (mm)", col.lab=rgb(0,0,0), line=3.5, cex.lab=1.5)
title(main='L-M cone',cex.main=2)
for (cond in 1:3){
  lines(contrastsfinedB,modrespsLM[condlist2[cond],], col=colpal[condlist[cond]], lwd=3, cex=0.5)
  # lines(contrastsdB,abs(cleanmeansP[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansP[condlist[cond],]), pch = 20+cond, col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
text(17,0.014,'(b)',adj=0.5,cex=2.5)


plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims2[1:2], ylim=plotlims2[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy2, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy2, side = 2, at=ticklocsy2, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 1Hz (mm)", col.lab=rgb(0,0,0), line=3.5, cex.lab=1.5)
for (cond in 1:3){
  lines(contrastsfinedB,modrespsLM2[condlist2[cond],], col=colpal[condlist[cond]], lwd=3, cex=0.5)
  # lines(contrastsdB,abs(cleanmeansP2[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansP2[condlist[cond],]),contrastsdB,cleanmeansP2CI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP2[condlist[cond],]),contrastsdB,cleanmeansP2CI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansP2[condlist[cond],]), pch = 20+cond, col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
text(17,0.014,'(f)',adj=0.5,cex=2.5)


load(file=paste0(datadir,'AveragedataS.RData'))
  
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims2[1:2], ylim=plotlims2[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy2, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy2, side = 2, at=ticklocsy2, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 0.5Hz (mm)", col.lab=rgb(0,0,0), line=3.5, cex.lab=1.5)
title(main='S cone',cex.main=2)
for (cond in 1:3){
  lines(contrastsfinedB,modrespsS[condlist2[cond],], col=colpal[condlist[cond]], lwd=3, cex=0.5)
  # lines(contrastsdB,abs(cleanmeansP[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansP[condlist[cond],]), pch = 20+cond, col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
text(17,0.014,'(c)',adj=0.5,cex=2.5)


plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims2[1:2], ylim=plotlims2[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy2, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy2, side = 2, at=ticklocsy2, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 1Hz (mm)", col.lab=rgb(0,0,0), line=3.5, cex.lab=1.5)
for (cond in 1:3){
  lines(contrastsfinedB,modrespsS2[condlist2[cond],], col=colpal[condlist[cond]], lwd=3, cex=0.5)
  # lines(contrastsdB,abs(cleanmeansP2[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansP2[condlist[cond],]),contrastsdB,cleanmeansP2CI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP2[condlist[cond],]),contrastsdB,cleanmeansP2CI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansP2[condlist[cond],]), pch = 20+cond, col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
text(17,0.014,'(g)',adj=0.5,cex=2.5)


load(file=paste0(datadir,'AveragedataMel.RData'))
  
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims2[1:2], ylim=plotlims2[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy2, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy2, side = 2, at=ticklocsy2, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 0.5Hz (mm)", col.lab=rgb(0,0,0), line=3.5, cex.lab=1.5)
title(main='Melanopsin',cex.main=2)
for (cond in 1:3){
  lines(contrastsfinedB,modrespsMel[condlist2[cond],], col=colpal[condlist[cond]], lwd=3, cex=0.5)
  # lines(contrastsdB,abs(cleanmeansP[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP[condlist[cond],]),contrastsdB,cleanmeansPCI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansP[condlist[cond],]), pch = 20+cond, col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
text(17,0.014,'(d)',adj=0.5,cex=2.5)


plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims2[1:2], ylim=plotlims2[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy2, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.3)     # add the tick labels
mtext(text = ticklabelsy2, side = 2, at=ticklocsy2, line=0.2, las=1) 
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude at 1Hz (mm)", col.lab=rgb(0,0,0), line=3.5, cex.lab=1.5)
for (cond in 1:3){
  lines(contrastsfinedB,modrespsMel2[condlist2[cond],], col=colpal[condlist[cond]], lwd=3, cex=0.5)
  # lines(contrastsdB,abs(cleanmeansP2[condlist[cond],]), col=colpal[condlist[cond]], lwd=3, cex=0.5)
  arrows(contrastsdB,abs(cleanmeansP2[condlist[cond],]),contrastsdB,cleanmeansP2CI[1,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  arrows(contrastsdB,abs(cleanmeansP2[condlist[cond],]),contrastsdB,cleanmeansP2CI[2,condlist[cond],],lwd=3,col=colpal[condlist[cond]],length=0.05,angle=90)
  points(contrastsdB,abs(cleanmeansP2[condlist[cond],]), pch = 20+cond, col='black', bg=colpal[condlist[cond]], cex=1.6, lwd=3)   
}  
text(17,0.014,'(h)',adj=0.5,cex=2.5)



dev.off()  
  
}


```

```{r plotsuppression, include=FALSE, results='hide'}

if (processdata > 0){

pdf(paste(figdir,"suppressionfig.pdf",sep=''), bg="transparent", height = 10, width = 10)

par(mfrow=c(2,2))

allbin <- matrix(0,nrow=8,ncol=5)
alldich <- matrix(0,nrow=8,ncol=5)
justbin <- matrix(0,nrow=8,ncol=5)
justdich <- matrix(0,nrow=8,ncol=5)

load(file=paste0(datadir,'AveragedataLum.RData'))
allbin[1,] <- abs(cleanmeansP[2,])/abs(cleanmeansP[1,])
allbin[5,] <- abs(cleanmeansP2[2,])/abs(cleanmeansP2[1,])
alldich[1,] <- abs(cleanmeansP[1,])/abs(cleanmeansP[6,])
alldich[5,] <- abs(cleanmeansP2[1,])/abs(cleanmeansP2[6,])
justbin[1,] <- abs(cleanmeansP[2,])
justbin[5,] <- abs(cleanmeansP2[2,])
justdich[1,] <- abs(cleanmeansP[6,])
justdich[5,] <- abs(cleanmeansP2[6,])


load(file=paste0(datadir,'AveragedataLM.RData'))
allbin[2,] <- abs(cleanmeansP[2,])/abs(cleanmeansP[1,])
allbin[6,] <- abs(cleanmeansP2[2,])/abs(cleanmeansP2[1,])
alldich[2,] <- abs(cleanmeansP[1,])/abs(cleanmeansP[6,])
alldich[6,] <- abs(cleanmeansP2[1,])/abs(cleanmeansP2[6,])
justbin[2,] <- abs(cleanmeansP[2,])
justbin[6,] <- abs(cleanmeansP2[2,])
justdich[2,] <- abs(cleanmeansP[6,])
justdich[6,] <- abs(cleanmeansP2[6,])

load(file=paste0(datadir,'AveragedataS.RData'))
allbin[3,] <- abs(cleanmeansP[2,])/abs(cleanmeansP[1,])
allbin[7,] <- abs(cleanmeansP2[2,])/abs(cleanmeansP2[1,])
alldich[3,] <- abs(cleanmeansP[1,])/abs(cleanmeansP[6,])
alldich[7,] <- abs(cleanmeansP2[1,])/abs(cleanmeansP2[6,])
justbin[3,] <- abs(cleanmeansP[2,])
justbin[7,] <- abs(cleanmeansP2[2,])
justdich[3,] <- abs(cleanmeansP[6,])
justdich[7,] <- abs(cleanmeansP2[6,])

load(file=paste0(datadir,'AveragedataMel.RData'))
allbin[4,] <- abs(cleanmeansP[2,])/abs(cleanmeansP[1,])
allbin[8,] <- abs(cleanmeansP2[2,])/abs(cleanmeansP2[1,])
alldich[4,] <- abs(cleanmeansP[1,])/abs(cleanmeansP[6,])
alldich[8,] <- abs(cleanmeansP2[1,])/abs(cleanmeansP2[6,])
justbin[4,] <- abs(cleanmeansP[2,])
justbin[8,] <- abs(cleanmeansP2[2,])
justdich[4,] <- abs(cleanmeansP[6,])
justdich[8,] <- abs(cleanmeansP2[6,])

allbin <- 20*log10(allbin)
alldich <- 20*log10(alldich)

allfacilitation <- matrix(0,nrow=2,ncol=4)
allsuppression <- matrix(0,nrow=2,ncol=4)

allfacilitation[1,1] <- mean(modrespsLum[2,]/modrespsLum[1,])
allsuppression[1,1] <- mean(modrespsLum[1,]/modrespsLum[4,])
allfacilitation[1,2] <- mean(modrespsLM[2,]/modrespsLM[1,])
allsuppression[1,2] <- mean(modrespsLM[1,]/modrespsLM[4,])
allfacilitation[1,3] <- mean(modrespsS[2,]/modrespsS[1,])
allsuppression[1,3] <- mean(modrespsS[1,]/modrespsS[4,])
allfacilitation[1,4] <- mean(modrespsMel[2,]/modrespsMel[1,])
allsuppression[1,4] <- mean(modrespsMel[1,]/modrespsMel[4,])

allfacilitation[2,1] <- mean(modrespsLum2[2,]/modrespsLum2[1,])
allsuppression[2,1] <- mean(modrespsLum2[1,]/modrespsLum2[4,])
allfacilitation[2,2] <- mean(modrespsLM2[2,]/modrespsLM2[1,])
allsuppression[2,2] <- mean(modrespsLM2[1,]/modrespsLM2[4,])
allfacilitation[2,3] <- mean(modrespsS2[2,]/modrespsS2[1,])
allsuppression[2,3] <- mean(modrespsS2[1,]/modrespsS2[4,])
allfacilitation[2,4] <- mean(modrespsMel2[2,]/modrespsMel2[1,])
allsuppression[2,4] <- mean(modrespsMel2[1,]/modrespsMel2[4,])


plotlims <- c(1,2,1,2) 
ticklocsx <- seq(1,2,0.2)    
ticklocsy <- seq(1,2,0.2)      
ticklabelsx <- ticklocsx        
ticklabelsy <- ticklocsy    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.2)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)   

title(xlab="Binocular facilitation", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Dichoptic suppression", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)


points(allfacilitation[1,1],allsuppression[1,1],pch=21,col=stimcolours[1],bg=stimcolours[2],cex=2,lwd=3)
points(allfacilitation[1,2],allsuppression[1,2],pch=21,col=stimcolours[3],bg=stimcolours[4],cex=2,lwd=3)
points(allfacilitation[1,3],allsuppression[1,3],pch=21,col=stimcolours[6],bg=stimcolours[5],cex=2,lwd=3)
points(allfacilitation[1,4],allsuppression[1,4],pch=21,col=stimcolours[7],bg=stimcolours[8],cex=2,lwd=3)

points(allfacilitation[2,1],allsuppression[2,1],pch=22,col=stimcolours[1],bg=stimcolours[2],cex=2,lwd=3)
points(allfacilitation[2,2],allsuppression[2,2],pch=22,col=stimcolours[3],bg=stimcolours[4],cex=2,lwd=3)
points(allfacilitation[2,3],allsuppression[2,3],pch=22,col=stimcolours[6],bg=stimcolours[5],cex=2,lwd=3)
points(allfacilitation[2,4],allsuppression[2,4],pch=22,col=stimcolours[7],bg=stimcolours[8],cex=2,lwd=3)

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])  
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.2)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)   

title(xlab="Binocular facilitation", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Dichoptic suppression", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)


plotlims <- c(-24,12,0,0.6) 
ticklocsx <- seq(-24,12,12)    
ticklocsy <- seq(0,0.6,0.1)    
ticklabelsx <- c('1/16','1/4','1','4')        
ticklabelsy <- ticklocsy    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.2)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)   

title(xlab="w", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Probability", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)
title(main='Suppressive weight 1F',cex.main=2)

a <- density(20*log10(pupilweightpopLum),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=addalpha(colpalmod[1],0.5),border=NA) 

a <- density(20*log10(pupilweightpopMel),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=addalpha(colpalmod[2],0.5),border=NA) 

a<- density(20*log10(pupilweightpopLM),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=addalpha(colpalmod[3],0.5),border=NA) 

a <- density(20*log10(pupilweightpopS),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=addalpha(colpalmod[4],0.5),border=NA) 

prior <- dnorm(10^((-48:12)/20),1,0.5)
prior <- 0.5*prior/max(prior)
lines(-48:12,prior)

lines(20*log10(c(mean(pupilWLum),mean(pupilWLum))),c(0,0.6),lwd=3,col=colpalmod[1])
lines(20*log10(c(mean(pupilWMel),mean(pupilWMel))),c(0,0.6),lwd=3,col=colpalmod[2])
lines(20*log10(c(mean(pupilWLM),mean(pupilWLM))),c(0,0.6),lwd=3,col=colpalmod[3])
lines(20*log10(c(mean(pupilWS),mean(pupilWS))),c(0,0.6),lwd=3,col=colpalmod[4])

legend(-24,0.6,c('Prior','Lum 1F', 'Mel 1F', 'LM 1F', 'S 1F'),col=c('black',colpalmod[1:4]),lwd=c(1,3,3,3,3),lty=1, cex=1.5, box.lwd=2, bg='white')

text(10,0.58,'(c)',adj=0.5,cex=2.5)

plotlims <- c(-24,12,0,0.6) 
ticklocsx <- seq(-24,12,12)    
ticklocsy <- seq(0,0.6,0.1)    
ticklabelsx <- c('1/16','1/4','1','4')        
ticklabelsy <- ticklocsy    # set labels for y ticks

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   # create an empty axis of the correct dimensions
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx, line=0.2)    
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)   
 
title(xlab="w", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Probability", col.lab=rgb(0,0,0), line=1.8, cex.lab=1.5)
title(main='Suppressive weight 2F',cex.main=2)

a <- density(20*log10(pupilweightpopLum2),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=addalpha(colpalmod[1],0.5),border=NA) 

a <- density(20*log10(pupilweightpopMel2),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=addalpha(colpalmod[2],0.5),border=NA) 

a <- density(20*log10(pupilweightpopLM2),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=addalpha(colpalmod[3],0.5),border=NA) 

a <- density(20*log10(pupilweightpopS2),from=-48,to=12)   
polygon(c(-48,a$x,12), c(0,a$y,0), col=addalpha(colpalmod[4],0.5),border=NA) 

prior <- dnorm(10^((-48:12)/20),1,0.5)
prior <- 0.5*prior/max(prior)
lines(-48:12,prior)

lines(20*log10(c(mean(pupilWLum2),mean(pupilWLum2))),c(0,0.6),lwd=3,col=colpalmod[1])
lines(20*log10(c(mean(pupilWMel2),mean(pupilWMel2))),c(0,0.6),lwd=3,col=colpalmod[2])
lines(20*log10(c(mean(pupilWLM2),mean(pupilWLM2))),c(0,0.6),lwd=3,col=colpalmod[3])
lines(20*log10(c(mean(pupilWS2),mean(pupilWS2))),c(0,0.6),lwd=3,col=colpalmod[4])

legend(-24,0.6,c('Prior','Lum 2F', 'Mel 2F', 'LM 2F', 'S 2F'),col=c('black',colpalmod[1:4]),lwd=c(1,3,3,3,3),lty=1, cex=1.5, box.lwd=2, bg='white')

text(10,0.58,'(d)',adj=0.5,cex=2.5)

dev.off()

}

```

```{r makephaseplots, include=FALSE, results='hide'}

# generate plots showing the phase angles
if (processdata > 0){

load(file=paste0(datadir,'AveragedataLum.RData'))
xlum <- Re(cleanmeansP)
ylum <- Im(cleanmeansP)
xlum2 <- Re(cleanmeansP2)
ylum2 <- Im(cleanmeansP2)
load(file=paste0(datadir,'AveragedataMel.RData'))
xmel <- Re(cleanmeansP)
ymel <- Im(cleanmeansP)
xmel2 <- Re(cleanmeansP2)
ymel2 <- Im(cleanmeansP2)
load(file=paste0(datadir,'AveragedataLM.RData'))
xlm <- Re(cleanmeansP)
ylm <- Im(cleanmeansP)
xlm2 <- Re(cleanmeansP2)
ylm2 <- Im(cleanmeansP2)
load(file=paste0(datadir,'AveragedataS.RData'))
xs <- Re(cleanmeansP)
ys <- Im(cleanmeansP)
xs2 <- Re(cleanmeansP2)
ys2 <- Im(cleanmeansP2)

pdf(paste(figdir,"phaseplots.pdf",sep=''), bg="transparent", height = 5, width = 10)

par(mfrow=c(1,2),mar=c(1,1,1,1))


plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-0.022,0.022), ylim=c(-0.022,0.022))   

rangles <- seq(0,360)*(pi/180)
r <- seq(0.005,0.02,0.005)
for (n in 1:length(r)){
  lines(r[n]*cos(rangles),r[n]*sin(rangles),col='gray')
}
lines(c(0,0),c(-0.02,0.02),lwd=2)
lines(c(-0.02,0.02),c(0,0),lwd=2)

text(0.015,-0.001,'Amplitude',cex=1.25,adj=0.5)
text(0.021,0,'Phase',cex=1.25,adj=0.5,srt=-90)

lines(xlum[2,]/10,ylum[2,]/10,col=stimcolours[1],lwd=3)
points(xlum[2,]/10,ylum[2,]/10,pch=21,col=stimcolours[1],bg=stimcolours[2],cex=2,lwd=3)

lines(xmel[2,],ymel[2,],col=stimcolours[7],lwd=3)
points(xmel[2,],ymel[2,],pch=21,col=stimcolours[7],bg=stimcolours[8],cex=2,lwd=3)

lines(xlm[2,],ylm[2,],col=stimcolours[3],lwd=3)
points(xlm[2,],ylm[2,],pch=21,col=stimcolours[3],bg=stimcolours[4],cex=2,lwd=3)

lines(xs[2,],ys[2,],col=stimcolours[6],lwd=3)
points(xs[2,],ys[2,],pch=21,col=stimcolours[6],bg=stimcolours[5],cex=2,lwd=3)

text(-0.019,0.019,'(a)',cex=3)
text(0.016,0.019,'1F',cex=2.5)

legend(-0.019,0.0155,c('Luminance','L-M','S','Melanopsin'),lty=1,col=stimcolours[c(1,3,6,7)],lwd=3,pch=21,pt.cex=2,pt.bg=stimcolours[c(2,4,5,8)],cex=1.1,box.lwd=3,bg='white')


plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(-0.022,0.022), ylim=c(-0.022,0.022))   

rangles <- seq(0,360)*(pi/180)
r <- seq(0.005,0.02,0.005)
for (n in 1:length(r)){
  lines(r[n]*cos(rangles),r[n]*sin(rangles),col='gray')
}
lines(c(0,0),c(-0.02,0.02),lwd=2)
lines(c(-0.02,0.02),c(0,0),lwd=2)

text(0.015,-0.001,'Amplitude',cex=1.25,adj=0.5)
text(0.021,0,'Phase',cex=1.25,adj=0.5,srt=-90)

lines(xlum2[2,],ylum2[2,],col=stimcolours[1],lwd=3)
points(xlum2[2,],ylum2[2,],pch=21,col=stimcolours[1],bg=stimcolours[2],cex=2,lwd=3)

lines(xmel2[2,],ymel2[2,],col=stimcolours[7],lwd=3)
points(xmel2[2,],ymel2[2,],pch=21,col=stimcolours[7],bg=stimcolours[8],cex=2,lwd=3)

lines(xlm2[2,],ylm2[2,],col=stimcolours[3],lwd=3)
points(xlm2[2,],ylm2[2,],pch=21,col=stimcolours[3],bg=stimcolours[4],cex=2,lwd=3)

lines(xs2[2,],ys2[2,],col=stimcolours[6],lwd=3)
points(xs2[2,],ys2[2,],pch=21,col=stimcolours[6],bg=stimcolours[5],cex=2,lwd=3)


text(-0.019,0.019,'(b)',cex=3)
text(0.016,0.019,'2F',cex=2.5)



dev.off()

}
  
```


# Abstract (250 words)

The diameter of the pupil fluctuates in response to levels of ambient light and is regulated by the autonomic nervous system. Increasing light in one eye causes both pupils to constrict, implying the system must combine signals across the two eyes, a process of binocular integration occuring independently of visual cortex. Distinct classes of retinal photoreceptor are involved in controlling and maintaining pupil diameter, with cones and rods driving the initial constriction and intrinsically photosensitive retinal ganglion cells maintaining diameter over prolonged time periods. Here, we used silent substitution to investigate binocular combination while targeting different photoreceptor pathways with sinusoidally modulated inputs. We find different patterns of binocular response in each pathway, and across the first and second harmonic frequencies. At the first harmonic, luminance and S-cone responses showed strong binocular facilitation, and weak interocular suppression. Melanopsin responses were invariant to the number of eyes stimulated. Notably, the L-M pathway involved binocular inhibition, whereby responses to binocular stimulation were weaker than for monocular stimulation. The second harmonic involved greater binocular facilitation in all pathways, and we show that binocular facilitation is negatively correlated with the magnitude of dichoptic masking. Our results are consistent with a computational model of binocular signal combination (implemented in a Bayesian hierarchical framework), in which the weight of interocular suppression differs across pathways. We also find pathway differences in response phase, consistent with different lag times for phototransduction. This work demonstrates for the first time the algorithm governing binocular combination in the autonomic nervous system.

# Significance statement (120 words)


# Introduction

The autonomic nervous system regulates many involuntary bodily processes, including the constriction and dilation of the pupils in response to light [@McDougal2015]. The anatomical pathway from the retina to the subcortical nuclei controlling the pupillary light response (PLR) is well established: it includes the Pretectal Olivary nucleus (PON), the Superior Cervical ganglion and the Edinger-Westphal nucleus, which project to the iris sphincter muscles that directly control the pupil size [@McDougal2008; @McDougal2015; @Wang2015]. Evidence of a binocular component to the PLR is shown by the existence of a consensual response of the pupil [the stimulation of one eye will cause constriction of the other eye; @Wyatt1981]. The anatomical segregation of the subcortical pathway from the rest of the brain means that this binocular combination of signals must occur independently of the cortical processes of binocular integration required for visual perception. Our recent work [@Segala2023] has shown that the algorithm underlying binocular combination of light in the pupil pathway differs from that in the cortex. Here we extend this paradigm to compare binocular combination in different photoreceptor pathways that feed into the autonomic nervous system.

Different classes of retinal photoreceptors, including cones, rods and the recently discovered melanopsin-containing intrinsically photosensitive retinal ganglion cells (ipRGCs), are directly involved in controlling and maintaining the size of the pupils [@Barrionuevo2014; @Barrionuevo2018; @Dacey2005; @Murray2018; @Spitschan2014; @Spitschan2019; @Woelders2018]. The cones have been shown to drive the initial rapid constriction of the pupils [@Mathot2018], while the slower and longer activation of the ipRGCs shows their role in maintaining the constriction over a prolonged period of time and in regulating the post-illumination pupillary response [@Markwell2010; @McDougal2010]. The ipRGCs are a unique photoreceptor class that has been discovered recently [@Provencio2000]. They express the photopigment melanopsin, and are involved in the regulation of the circadian rhythm [@Provencio2000; @Panda2002; @Ruby2002], forming a major input to the PON [@Dacey2003]. The first direct evidence of the involvement of the ipRGCs in the PLR was shown in rats by @Lucas2003 who genetically deleted the melanopsin gene from rats, resulting in the loss of the intrinsic photosensitivity of the cells and a reduced pupil constriction. This same behaviour was later also observed in primates and humans [@Gamlin2007], where it was demonstrated that the PLR continues during light presentation even when cone and rod signalling is blocked, indicating the primary role of the ipRGCs in maintaining pupil constriction over a prolonged time.

A technique known as silent substitution [@Estevez1982] can be used to selectively stimulate specific photoreceptor classes. Silent substitution exploits the fact that each photoreceptor class has a distinct spectral tuning that overlaps with the others. Using a multiprimary system, in which the primaries have different spectra, it is possible to target one class of photoreceptors while maintaining the others at a constant activity level, effectively silencing them [@Shapiro1996; @Spitschan2018, this paper also offers a clear explanation of how to implement silent substitution]. Studies using silent substitution have shown that the pupils behave differently depending on which photoreceptor or pathway is being stimulated. For example, pupil responses have been shown to be out of phase when the S cones are stimulated, relative to when the ipRGCs or the L+M cones are stimulated [@Spitschan2014; @Cao2015]. Additionally, when L and M cones are stimulated individually, there appears to be a paradoxical pupil response: increments in L cone stimulation cause a constriction of the pupil, while increments in M cone stimulation lead to a dilation of the pupil [@Woelders2018; @Murray2018].

Binocular combination has been extensively studied in visual perception, where it is mediated by neurons in primary visual cortex [@Hubel1962; @Moradi2009]. For pattern vision, binocular summation occurs at threshold, such that less contrast is required to detect a target shown to both eyes than for a target shown to only one eye [@Baker2018; @Campbell1965; @Legge1984]. At higher contrasts, a process of 'ocularity invariance' is observed, in which the response to monocularly- and binocularly-presented patterns is equal [@Baker2007; @Ding2006; @Meese2006; @Moradi2009]. This is thought to be due to a process of interocular suppression that compensates for the additional excitatory drive caused by stimulating two eyes. Our recent work [@Segala2023] has shown that cortical signal combination for luminance flicker is substantially more linear than for spatial patterns, whereas there is evidence of interocular suppression in the pupil pathway.

Most studies that use silent substitution to investigate the PLR stimulate only one eye. If the stimulated eye is pharmacologically dilated to control pupil size, the response from the unstimulated eye (known as the consensual response) can be recorded [e.g. @McDougal2010; @Spitschan2014]. While this approach controls the total amount of light incident at the retina, it does not permit investigation of binocular combination for specific photoreceptor pathways. Here we take a different approach, using a custom binocular multiprimary system (see Figure \@ref(fig:spectraplots)a,b) that can modulate each (undilated) eye independently, and a binocular eye tracker to measure the diameter of both pupils. We measure the amplitude of pupil modulation (using Fourier analysis) in response to sinusoidal stimulation at 0.5Hz, for stimuli directed at the luminnce pathway, L-M cone pathway, S-cone pathway, and melanopsin pathway. Our key comparisons are between monocular and binocular stimulation, and between monocular stimulation and a dichoptic masking condition in which the non-target eye is stimulated by a high contrast mask signal at a different frequency (0.4Hz). The results are interpreted using a contemporary model of binocular vision [@Meese2006] implemented within a hierarchical Bayesian framework

# Results

Figure \@ref(fig:spectraplots)m-p shows averaged waveforms of pupil diameter in response to binocular stimulation. For luminance stimuli (Figure \@ref(fig:spectraplots)m) a strong modulation is apparent at the stimulation frequency (0.5Hz), which is also clear in the Fourier amplitude spectrum (Figure \@ref(fig:spectraplots)q). For binocular stimulation of the L-M pathway, S-cone pathway and melanopsin pathway, pupil modulations were less than 10\% of the amplitude of the luminance modulation (note the change in y-axis scale for the Fourier spectra), but still apparent at 0.5Hz in the Fourier spectra (Figure \@ref(fig:spectraplots)n-p). We also observed a second harmonic response (at 1Hz) for all conditions, which was weaker than the first harmonic for luminance and melanopsin stimulation, but stronger for L-M and S-cone stimulation. The additional component is also apparent in the pupil waveforms shown in Figure \@ref(fig:spectraplots)n-p. Our main analysis therefore focuses on the amplitude of the pupil modulations at both the first and second harmonic frequencies across different stimulus conditions.

```{r spectraplots, fig.cap="Summary of the spectral power distributions and alpha-opic irradiances for the background and each condition, as well as averaged pupil diameters and Fourier spectra. Panel (a) shows a schematic of the binocular stimulation system for presenting spectrally tuned modulations independently to each eye. The VR headset was attached to a clamp stand that the experimenters could use to adjust the height and align the headset with the eyes of the participant. The participant's head was supported by a chin rest to keep it in position throughout the experiment. Panel (b) shows the outputs of each LED primary at maximum intensity, and panels (c) and (d) show the overall spectral power distributions and the alpha-opic irradiances of the background spectra used for both eyes. The subsequent rows show the power differences (e-h), and photoreceptor contrasts (i-l) relative to the background, averaged pupil diameter waveforms (m-p) and Fourier spectra (q-t) for binocular stimulation. Column headings indicate the pathway stimulated, and shaded regions in panels m-t indicate bootstrapped 95\\% confidence intervals.", fig.align="center", out.width = '80%', echo=FALSE}

knitr::include_graphics(paste0(figdir,'methodsfig.pdf'))

```

Figure \@ref(fig:CRFplots) shows contrast response functions across stimulation conditions for responses at the first harmonic (panels a-d) and the second harmonic (panels e-h) frequencies. In each plot, the response to monocular stimulation is given by the red circles and typically increases monotonically as a function of stimulus (temporal) contrast (main effects of stimulus contrast are significant for all data sets, see Supplementary Materials). Relative to monocular stimulation, binocular stimulation typically led to higher response amplitudes, indicating a binocular facilitation effect (main effects of condition are significant for all data sets, see Supplementary Materials). This is strongest for the luminance and S-cone conditions at the first harmonic (Figure \@ref(fig:CRFplots)a,c) and the L-M cone and Melanopsin conditions at the second harmonic (Figure \@ref(fig:CRFplots)f,h). One striking exception to this pattern is in the L-M cone condition at the first harmonic (Figure \@ref(fig:CRFplots)b): this condition produced a binocular suppression effect, where the response to binocular stimulation is weaker than the response to monocular stimulation (blue squares below red circles). These results indicate that the magnitude of binocular facilitation differs across photoreceptor pathway, suggesting heterogeneity in the underlying neural computation.

```{r CRFplots, fig.cap="Contrast response functions for monocular (red circles), binocular (blue squares) and dichoptic (yellow diamonds) conditions, for stimulation of different pathways (columns) at the first and second harmonic frequencies (rows). Error bars indicate bootstrapped 95\\% confidence intervals", fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'CRFs.pdf'))

```

In contemporary models of binocular signal combination, the amount of binocular facilitation is determined by the magnitude of interocular suppression, with strong suppression reducing facilitation [@Kingdom2015]. We can estimate the strength of interocular suppression by measuring how much monocular responses are reduced when a high contrast dichoptic mask is shown to the other eye. In our paradigm, this mask flickered at a lower frequency (0.4Hz) so that the two stimulus components remain distinct in the Fourier spectrum [e.g. @Busse2009]. The yellow diamond symbols in Figure \@ref(fig:CRFplots) show the target responses in this condition, and in most cases are weaker than the monocular responses (red circles). The strongest dichoptic masking is found in the first harmonic L-M condition, where we also observed the binocular suppression effect. 

```{r suppressionfig, fig.cap="P.", fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'suppressionfig.pdf'))

```

Next, we fitted all 8 data sets using a Bayesian hierarchical implementation of a simple binocular combination model [@Meese2006; @Segala2023]. Our primary objective was to compare posterior distributions of the weight of interocular suppression, which are shown in Figure \@ref(fig:suppressionfig). Consistent with our earlier observations, at the first harmonic the strongest suppressive weight corresponds to the L-M condition, and the weakest suppression corresponds to the luminance condition [also consistent with @Segala2023]. The model fits were of good quality, as shown by the curves in Figure \@ref(fig:CRFplots). Further details of fitted parameters, and model behaviour in other empirical conditions are provided in the Supplementary Materials. We used the model fits to summarise the relationship between binocular facilitation and interocular suppression by calculating an index for each effect, and show that the facilitation effect is negatively correlated with the dichoptic masking effect (see Figure \@ref(fig:suppressionfig)).

Finally, we inspected the response phase of our four stimulation conditions, given previous reports that these differ across pathways [@Spitschan2014], and may be in antiphase for melanopsin and S-cone signals. Figure \@ref(fig:phaseplots) shows the phase angles for the first (a) and second (b) harmonic frequencies for binocular stimulation (monocular stimulation produced very similar results). At the first harmonic, melanopsin and S-cone signals differed in phase by more than 90 degrees, though they were not fully in antiphase. The luminance and L-M responses were more closely in antiphase to each other, however this is likely due to our choice to modulate L+M- in the first half-cycle (corresponding to a luminance increase in the luminance condition), and L-M+ in the second half-cycle (corresponding to a luminance decrease in the luminance condition). Had we reversed this phase arrangement, we would likely have seen a close phase correspondence between the L-M and luminance conditions. Phase differences between the luminance, S-cone and melanopsin conditions are likely attributable to different lags in phototransduction at the earliest stage (i.e. in the retina). At the second harmonic frequency (Figure \@ref(fig:phaseplots)b), the luminance condition was again out of phase with the other three, and was approximately in quadrature phase with the L-M condition, and in antiphase with both the S-cone and melanopsin conditions (which were in phase with each other).

```{r phaseplots, fig.cap="Pupil phase plots at the first and second harmonic frequencies for the luminance, melanopsin, L-M pathway and the S-(L+M) pathway conditions Panel (a) shows the pupil response at the first harmonic frequency during binocular stimulation. Panel (b) shows the pupil response at the second harmonic frequency during binocular stimulation. In panel (a) the luminance amplitudes have been scaled down by a factor of 10 to enable comparison with the other conditions.", fig.align="center", echo=FALSE}

knitr::include_graphics(paste0(figdir,'phaseplots.pdf'))

```

# Discussion

We used pupillometry and silent substitution to measure monocular and binocular responses of the pupils to flickering stimuli when stimulating specific photoreceptor pathways. In our luminance experiment, we found that peripheral stimulation of the retina can elicit a pupillary response and we were also able to record a response at the second harmonic, which was not seen when we stimulated the fovea [@Segala2023]. In all four experiments, we were able to record contrast response functions at both the first and the second harmonics. All experiments showed that binocular combination in the autonomic nervous system happens in a non-linear manner, with evidence of different magnitudes of interocular suppression depending on the photoreceptor pathway. This pattern of results was confirmed by a computational model, which allowed us to compare the weight of interocular suppression for each pathway. We found that, at the first harmonic frequency, the L-M pathway had a bigger suppression weight than the other pathways, while, at the second harmonic frequency, the S-(L+M) pathway had a bigger suppression weight. Finally, we looked at the pupil phases and observed different behaviours for the different pathways at the first and second harmonic frequencies. While the patterns differed between the first and second harmonics, within the same harmonic, whether the stimuli were presented monocularly or binocularly, the patterns were similar. 

Our four experiments produced results that we were expecting based on our previous pupillometry findings [@Segala2023]: the signals between the 2 pupils are combined non-linearly regardless of which photoreceptor pathway is being stimulated and whether the fovea or the periphery of the retina is being stimulated. We also observed responses at both the first and the second harmonic frequencies, which were expected based on previous literature [@Spitschan2014; @Stark1957; @Verdon1988]. There was, however, one aspect of our results that we were surprised to observe: the amplitude of this second harmonic response in the different photoreceptor pathways. It is true that we had already observed second harmonic responses when stimulating the periphery of the retina with achromatic luminance modulations flickering at 2 Hz (see Figure \@ref(fig:appendixfig1)b), but the peak was very small when compared to the first harmonic peak, which is similar to what we observed in the luminance experiment here. On the other hand, in the melanopsin and L-M pathway experiments, the first and second harmonics are similar in amplitudes, and in the S-(L+M) pathway experiment, the peak of the second harmonic is even bigger than the peak of the first harmonic. One reason for why this might be happening may be because the driving signal is stronger when using a lower flicker frequency [indeed, pupillometry is more responsive to slow flicker frequencies of less than 1 Hz, @Spitschan2014] and when stimulating the periphery of the retina (we have a very clear waveform for the luminance experiment in Figure \@ref(fig:pupildataLum)b). However, this explanation is not entirely satisfactory: we observed a second harmonic when stimulating the periphery using a higher flicker frequency and the pupil waveforms from the other three experiments are not as clear as the one from the luminance experiment. The presence of a second harmonic might indicate the existence of non-linearities that are not observable in the fovea: indeed, steady-state visual responses can contain activity beyond the first harmonic and these harmonics reflect non-linearities (e.g. squaring, exponentiation, rectification) in the visual response [@Norcia2015]. Additionally, it can be the case that, when these non-linearities are strong, then the higher harmonics can have equal or even higher peaks than the first harmonic. Here, we did observe strong non-linearities in our photoreceptor pathways, as reflected by the interocular suppression weights that were output by our computational model. For the S-(L+M) pathway specifically, it seems that the higher peak of the second harmonic is a behaviour intrinsic to S cones, as this was observed previously [@Spitschan2014].

The pupil phases shown in Figure \@ref(fig:phaseplots) give us more information about the pathways controlling the pupil response. The first thing that we  notice is that the luminance and L-M pathway responses are in anti-phase. It is important to note that, for our L-M pathway stimulation, the stimulus flickered between magenta (first half of the cycle) and cyan (second half of the cycle), which means that the pupil was dilating during the magenta stimulation and then constricting during the cyan presentation. This seems to suggest that increments in magenta would correspond to decrements in brightness and increments in cyan would correspond to increments in brightness. It is possible that, if we had reversed the presentation cycle for the L-M pathway, the pupil response would have been in phase with the luminance responses. It has been recently shown that L-cone and melanopsin stimulation induce an opponent pupillary response to M- and S-cone stimulation [@Murray2018; @Woelders2018]. Our melanopsin and S-(L+M) results show a similar behaviour both for monocular and binocular responses. The L-M pathways results are desynchronised approximately in quadrature phase from the melanopsin and S-(L+M) results. These results also seem to align with what was previously found: combining L and M responses should display results that are between the opponency shown by the isolated cone stimulation. Additionally, this could explain the very strong suppression that binocular (L-M) stimulation displays compared to the monocular stimulation: if L and M produce pupil responses that are in anti-phase with each other, then combining the two together should elicit smaller responses. Finally, since the results from our experiments are not in phase, it would suggest that the photoreceptors control the pupil diameter through different pathways.

# Conclusions

We have demonstrated that binocular combination of temporal flickering light in the autonomic nervous system depends on the photoreceptor pathway. We were able to elicit pupil responses by stimulating only the periphery of the retina and we were able to record contrast response functions for all photoreceptor pathways. While all pathways showed non-linear combination, they showed a variation in how the signals are combined, particularly in the weight of interocular suppression.

# Materials and methods

## Participants

Twenty-four participants were recruited for each of the four experiments for a total of ninety-six (68 females) adult participants, whose ages ranged from 18 to 41. All participants had normal or corrected to normal binocular vision and normal colour vision, and gave written informed consent. Our procedures were approved by the Ethics Committee of the Department of Psychology at the University of York (identification number 184).

## Apparatus & stimuli

To present synchronised stimulus modulations independently to each eye, two light engines, each with 10 independently addressable LED colour channels (SpectraTuneLAB: LEDMOTIVE Technologies, LLC, Barcelona, Spain), were integrated into a customised viewing system. The light engines were operated via a Python interface to their REST API [@Martin2022], which supports synchronous launch and playback of spectral sequences prepared in advance and stored in JSON format. When preparing the spectral sequences, the age of participants was recorded to account for the yellowing of the lenses. We calculated silent substitution solutions using the _PySilSub_ toolbox [@Martin2023], using linear algebra. The outputs of the two light engines (see Figure \@ref(fig:spectraplots)b,c) were calibrated using an Ocean Optics Jaz spectroradiometer, which was wavelength-calibrated to an Argon lamp and intensity calibrated using a NIST-traceable light source. We used the @Stockman2000 10-degree cone fundamentals, and estimates of melanopsin absorbance spectra from CIE S 026 [discussed in @Martin2023] to calculate $\alpha$-opic irradiance.

The output from the light engines was directed through liquid light guides (LLG3-8H: Thorlabs Ltd, Cambridgeshire, UK) and diffused onto semi-opaque and highly diffusive white glass discs with a diameter of 50 mm for even illumination (34-473: Edmund Optics, York, UK). The light guide gaskets were butt-coupled to the light engine diffusers with threaded adapters (SM1A9, AD3LLG: Thorlabs Ltd, Cambridgeshire, UK) and the exiting ends of the light guides were mated with 51 mm depth optical cylinders (SM2L20: Thorlabs Ltd, Cambridgeshire, UK) via appropriately threaded adapters (AD3LLG, SM2A6: Thorlabs Ltd, Cambridgeshire, UK). The stimulus diffuser discs were retained at the front end of the optical cylinders approximately 51 mm from the light source, at which distance the output beam was sufficiently dispersed to afford even illumination of the diffuser when viewed from the front. To guarantee safe illumination levels, a circular neutral-density filter with the same diameter of the white glass discs (50 mm) and an optical density of 0.6 log units was placed in the optical path between the light source and the diffusers. A small circular piece of blackout material with a diameter of approximately 8 degrees (10 mm) was positioned centrally on the front of each diffuser disc to aid as a fusion lock, as a fixation point, and to occlude the fovea.

The diffuser discs were positioned in the objective planes of the lenses of a modified VR headset (SHINECON SC-G01, Dongguan Shinecon Industrial Co. Ltd., Guangdong, China), which was used by the participants to view the stimuli. The stimuli were two discs of flickering light with a diameter of approximately 30 degrees, which were fused together into a cyclopean percept resembling a donut-shaped ring of light, similar to that used in other studies [e.g., @Barrionuevo2016; @Murray2018; @Spitschan2014; @Zele2018]. The VR headset modifications allowed for small adjustments to account for individual differences in interpupillary distance and focal length. The use of this set up allowed us to modulate the stimuli in three different ocular configurations, similar to the ones we used in our previous study [@Segala2023]: monocular, binocular and dichoptic. In the monocular configuration, the unstimulated eye still saw a non-flickering disc of mean luminance. A schematic of the stimulation system is shown in Figure \@ref(fig:spectraplots)a. Pupillometry data were collected using a binocular Pupil Core eye-tracker headset [Pupil Labs GmbH, Berlin, Germany, @Kassner2014] running at 120 Hz, and the signals were recorded with the Pupil Capture software.

Our previous study [@Segala2023] used a temporal frequency of 2Hz for foveal luminance flicker, and recorded EEG data simultaneously with pupillometry. Initial pilot experiments indicated that this frequency was too high to elicit measurable responses when stimulating individual photoreceptor pathways. For all experiments, we therefore used a primary flicker frequency of 0.5Hz, as previous literature showed that it was slow enough to elicit a pupil response from all photoreceptor classes [@Spitschan2014]. We also focussed on only recording pupillometry data as this frequency would be well below the minimum threshold to elicit steady-state EEG responses [@Norcia2015].

For all experiments, sinusoidal temporal modulations were presented against the same background spectrum (matched between the eyes), which was used to achieve silent substitution in the three photoreceptor modulation experiments. The background spectra were defined by setting all channels to half maximum output for the brighter of the two devices (STLab 1, left eye) and then using the STLab 1/STLab 2 calibration ratio to find the equivalent settings for the companion device (STLab 2, right eye). The background spectrum illuminance was approximately 74 lux, or 68.5 cd/m$^2$. The spectral power distributions and $\alpha$-opic irradiances of the background spectra for both eyes are shown in Figure \@ref(fig:spectraplots)c-d.

In the luminance experiment, the stimulus intensity was increased and decreased relative to the background, which we expected to modulate all photoreceptor classes (see Figure \@ref(fig:spectraplots)e,i). In the L-M cone modulation experiment, we used silent substution to increase the L-cone activity, and simultaneously decrease the M-cone activity, during the first half-cycle of the sine wave. In the second half-cycle the polarity of the modulation reversed (see Figure \@ref(fig:spectraplots)f,j). The maximum available L-M contrast was approximately 10\%. In the S-cone modulation experiment, we increased and decreased S-cone-directed signals, whilst keeping activity in the other photoreceptors constant (see Figure \@ref(fig:spectraplots)g,k). Our system allowed a maximum contrast of 45\%. Finally, in the melanopsin experiment, we modulated the activity of the melanopsin-containing intrinsically photoreceptive retinal ganglion cells, whilst keeping cone activity constant (see Figure \@ref(fig:spectraplots)h,l). The maximum available melanopsin contrast was 22\%. We assume that the activity of rods was constant at the high background luminance intensity used here, and so did not attempt to silence rod activity in any condition, as this would have greatly reduced the available dynamic range. Splatter on nominally silenced photoreceptors was very small (see Figure \@ref(fig:spectraplots)j-l), well below the levels that would be expected to generate measureable pupil modulations.

## Procedure

Before the start of each experiment, participants adjusted the objective planes of the lenses with the help of the experimenter until the stimulus was in focus and they perceived the two pieces of blackout material as one fused disc. Pupil responses to binocular temporal contrast modulations were examined in a factorial design that combined six ocular conditions and five temporal contrast levels (6, 12, 24, 48 and 96%) of the available dynamic range. This design, similar to that used in our previous studies [@Segala2023; @Baker2017; @Baker2020], was applied in four separate experiments, each with a different mode of photoreceptor stimulation. In the first three conditions, the discs flickered at 0.5 Hz, in either a monocular, binocular or dichoptic arrangement. In the dichoptic condition the non-target eye saw a flickering fixed contrast of 48% of the available dynamic range. In the remaining three conditions (the cross-frequency conditions) one eyes disc flickered at 0.4 Hz, and the other eyes disc flickered at 0.5 Hz. We also tested monocular responses at 0.4 Hz, as well as binocular (one eye sees each frequency at the target contrast) and dichoptic (target stimulus flickering at 0.5 Hz, mask contrast of 48% at 0.4 Hz in the other eye) arrangements. We counterbalanced presentation of the target stimulus across the left and right eyes.

The experiments were conducted in a windowless room, in which the only source of light was the modified VR headset. The participants sat as close as possible to the VR headset, leaving enough space for the eye-tracker to record the eyes. The experiment was carried out in a single session of around 45-60 minutes, divided into three blocks of 15-17 minutes each. In each block, there were a total of 60 trials lasting 15 seconds each (12s of stimulus presentation, followed by 3s of interstimulus interval). The participants were given no task other than look at the black fixation dot while trying to minimise their blinking during the presentation period. For all experiments other than the luminance condition, participants adapted to the mean luminance for two minutes before stimulation began.

Before the start of the L-M experiment, participants completed a luminance nulling perceptual calibration procedure in L-M cone space on an Iiyama $\textrm{VisionMaster}^{\textrm{TM}}$ Pro 510 display (800 x 600 pixels, 60 Hz refresh rate). During the task, participants were presented with a disc flickering within the L-M cone space (between magenta and cyan). Using a trackball, participants adjusted the angle in cone space to find their subjective isoluminant point, which resulted in changing the flickering intensity of the stimulus until the amplitude of the flicker appeared to be minimised. The result was used to modify the requested contrasts during stimulus preparation so as to account for individual differences affecting perceived illuminance, principally the L:M cone ratio [@Carroll2002; @Hofer2005].

## Data analysis

The pupillometry data were analysed using the same method we used in our previous study [@Segala2023]. The data were converted from mp4 videos to a csv text file using the Pupil Player software [@Kassner2014], which estimated pupil diameter for each eye on each frame using a 3D model of the eyeball. The individual data were then loaded into R for analysis, where a ten-second waveform for each trial in each eye was extracted (excluding the first two seconds after stimulus onset). We interpolated across any dropped or missing frames to ensure regular and continuous sampling over time. The Fourier transform was calculated for each waveform, and all repetitions of each condition were pooled across eye and then averaged. Finally, data were averaged across all participants to obtain the group results. We used coherent averaging and at each stage we excluded data points with a Mahalanobis distance exceeding $D$ = `r SDthresh` from the complex-valued mean [@Baker2021]. For monocular stimulation, we confirmed that the consensual response was equivalent to the response in the stimulated eye.

For all experiments, we used a bootstrapping procedure with `r nbootstraps` iterations to estimate standard errors across participants. All analysis and figure construction was conducted using a single R-script, available online, making this study fully computationally reproducible: https://osf.io/gdvt4/.

## Computational model and parameter estimation

To describe our data, we chose the same model described in our previous study [@Segala2023]. The model has the same general form as the first stage of the contrast gain control model proposed by @Meese2006 and omits the second stage. For the previous model that we used [@Segala2023], the exponent of the numerator and denominator had fixed values of 2 and (implicitly) 1. Here, we allow these parameters (called _p_ and _q_) to be free, in order to permit different shapes of contrast response function, e.g. saturating or super-saturating. The responses of the left eye and right eye channels are as follows:

\begin{equation}
\label{eq:respLchap4}
Resp_L = \frac{L^p}{Z + L^q + wR^q},
\end{equation}

\begin{equation}
\label{eq:respRchap4}
Resp_R = \frac{R^p}{Z + R^q + wL^q},
\end{equation}

\noindent where _L_ and _R_ are the contrast signals from the left and right eyes, _p_ and _q_ are exponents, _Z_ is a saturation constant that shifts the contrast-response function laterally, and _w_ is the weight of suppression from the other eye.

The responses from the two eyes are then summed binocularly:

\begin{equation}
\label{eq:respBchap4}
Resp_B = R_{max}(Resp_L + Resp_R) + k,
\end{equation}

\noindent where _k_ is a noise parameter, and $R_{max}$ scales the overall response amplitude.

We performed model fitting on the normalised amplitudes to account for amplitude differences between the experiments. The models were fit using a hierarchical Bayesian framework implemented in Stan [@Carpenter2017]. The data for each photoreceptor type and response frequency was fit separately, for a total of 8 model fits. The prior

# Acknowledgements and funding sources

Supported by Biotechnology and Biological Sciences Research Council grant BB/V007580/1 awarded to DHB and ARW.

# References

<div id='refs'> </div>


# Supplementary Materials


```{r paramtable1F, echo=FALSE}

condnames <- c('Luminance 1F', 'Melanopsin 1F', 'L-M 1F', 'S 1F')
zlist <- c(pupilZLum, pupilZMel, pupilZLM, pupilZS)
klist <- c(pupilKLum, pupilKMel, pupilKLM, pupilKS)
wlist <- c(pupilWLum, pupilWMel, pupilWLM, pupilWS)
plist <- c(pupilPLum, pupilPMel, pupilPLM, pupilPS)
qlist <- c(pupilQLum, pupilQMel, pupilQLM, pupilQS)
Rlist <- c(round(c(pupilRmaxLum, pupilRmaxMel, pupilRmaxLM, pupilRmaxS),5))
tabledata <- data.frame(condnames,round(zlist,digits=2),round(klist,digits=2),round(wlist,digits=2),round(plist,digits=2),round(qlist,digits=2),Rlist)

colnames(tabledata) <- c('Experiment','Z','k','w','p','q','Rmax')
kable(tabledata, align='lcccccc',caption = 'Summary of median parameter values at the first harmonic frequency.') 

```

```{r paramtable2F, echo=FALSE}

condnames <- c('Luminance 2F', 'Melanopsin 2F', 'L-M 2F', 'S 2F')
zlist <- c(pupilZLum2, pupilZMel2, pupilZLM2, pupilZS2)
klist <- c(pupilKLum2, pupilKMel2, pupilKLM2, pupilKS2)
wlist <- c(pupilWLum2, pupilWMel2, pupilWLM2, pupilWS2)
plist <- c(pupilPLum2, pupilPMel2, pupilPLM2, pupilPS2)
qlist <- c(pupilQLum2, pupilQMel2, pupilQLM2, pupilQS2)
Rlist <- c(round(c(pupilRmaxLum2, pupilRmaxMel2, pupilRmaxLM2, pupilRmaxS2),5))
tabledata <- data.frame(condnames,round(zlist,digits=2),round(klist,digits=2),round(wlist,digits=2),round(plist,digits=2),round(qlist,digits=2),Rlist)

colnames(tabledata) <- c('Experiment','Z','k','w','p','q','Rmax')
kable(tabledata, align='lcccccc',caption = 'Summary of median parameter values at the second harmonic frequency.') 

```


